<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" []>
<!-- This document was created with Syntext Serna Free. --><chapter id="chapter_development" lang="ru">
  <title>Разработка приложений</title>
  <para>Данная глава содержит практическую информацию по созданию приложений на основе платформы.</para>
  <section>
    <title>Рекомендуемый стиль кода</title>
    <para><emphasis role="bold">Форматирование кода</emphasis></para>
    <itemizedlist>
      <listitem>
        <para>Для Java и Groovy кода рекомендуется придерживаться стандартного стиля, описанного в документе <ulink url="http://www.oracle.com/technetwork/java/codeconv-138413.html">Code Conventions for the Java Programming Language</ulink>. При программировании в <application>IntelliJ IDEA</application> для этого достаточно использовать стиль по умолчанию, а для переформатирования применять сочетание клавиш <keycap>Ctrl-Alt-L</keycap>.</para>
        <para>Максимальная длина строки − 120 символов. Длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.</para>
      </listitem>
      <listitem>
        <para>XML код: длина отступа - 4 символа, использование пробелов вместо символов табуляции включено.</para>
      </listitem>
    </itemizedlist>
    <para><emphasis role="bold">Соглашения по именованию</emphasis></para>
    <informaltable frame="all" align="center">
      <tgroup cols="3" align="center">
        <colspec colname="c1"/>
        <colspec colname="c2"/>
        <colspec colname="c3"/>
        <thead wordsize="16">
          <row>
            <entry colname="Имя атрибута" role="bord">Идентификатор</entry>
            <entry colname="Тип атрибута" role="caption">Правило именования</entry>
            <entry colname="Тип атрибута" role="caption">Пример</entry>
          </row>
        </thead>
        <tbody>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">Java и Groovy классы </emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Класс контроллера экрана</entry>
            <entry align="left">
              <para>UpperCamelCase</para>
              <para>Контроллер экрана  списка сущностей − <code>{КлассСущности}Browse</code></para>
              <para>Контроллер экрана редактирования − <code>{КлассСущности}Edit</code></para>
            </entry>
            <entry align="left">
              <para><code>CustomerBrowse</code></para>
              <para><code>OrderEdit</code></para>
            </entry>
          </row>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">XML дескрипторы экранов</emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Идентификатор компонента, имена параметров в запросах</entry>
            <entry align="left">
              <para>lowerCamelCase, только буквы и цифры</para>
            </entry>
            <entry align="left">
              <para><literal>attributesTable</literal></para>
              <para><literal>:component$relevantTo</literal></para>
              <para><literal>:ds$attributesDs</literal></para>
            </entry>
          </row>
          <row>
            <entry align="left">Идентификатор источника данных</entry>
            <entry align="left">
              <para>lowerCamelCase, только буквы и цифры, оканчивается на <code>Ds</code></para>
            </entry>
            <entry align="left">
              <code>attributesDs</code>
            </entry>
          </row>
          <row>
            <entry namest="c1" nameend="c3" align="center">
              <emphasis role="bold">SQL скрипты</emphasis>
            </entry>
          </row>
          <row>
            <entry align="left">Зарезервированные слова</entry>
            <entry align="left">lowercase</entry>
            <entry align="left">
              <literal>create table</literal>
            </entry>
          </row>
          <row>
            <entry align="left">Таблицы</entry>
            <entry align="left">UPPER_CASE. Название предваряется именем проекта для формирования пространства имен. В именах таблиц рекомендуется использовать единственное число.</entry>
            <entry align="left">
              <para><literal>SALES_CUSTOMER</literal></para>
            </entry>
          </row>
          <row>
            <entry align="left">Колонки</entry>
            <entry align="left">UPPER_CASE</entry>
            <entry align="left">
              <para><literal>CUSTOMER</literal></para>
              <para><literal>TOTAL_AMOUNT</literal></para>
            </entry>
          </row>
          <row>
            <entry align="left">Колонки внешних ключей</entry>
            <entry align="left">UPPER_CASE. Состоит из имени таблицы, на которую ссылается колонка (без префикса проекта), и суффикса _ID.</entry>
            <entry align="left">
              <literal>CUSTOMER_ID</literal>
            </entry>
          </row>
          <row>
            <entry align="left">Индексы</entry>
            <entry align="left">UPPER_CASE. Состоит из префикса IDX_, имени таблицы, для которой создается индекс (с префиксом проекта), и имен полей, включенных в индекс.</entry>
            <entry align="left">
              <literal>IDX_SALES_CUSTOMER_NAME</literal>
            </entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>
  </section>
  <section id="project_file_structure">
    <title>Файловая структура проекта</title>
    <para>Рассмотрим файловую структуру  проекта на примере простого приложения <application>Sales</application>, состоящего из <link linkend="app_tiers">блоков</link><structname> Middleware</structname>,  <structname>Web Client</structname> и <structname>Web Portal</structname>.</para>
    <figure>
      <title>Файловая структура проекта</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="" align="center" fileref="img/project_structure.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>В корне проекта расположены скрипты сборки <filename>build.gradle</filename>, <filename>settings.gradle</filename> и проектные файлы <application>IntelliJ IDEA</application>.</para>
    <para id="text_module_id">В каталоге <filename>modules</filename> расположены подкаталоги <link linkend="app_modules">модулей</link> проекта − <structname>global</structname>, <structname>core</structname>, <structname>gui</structname>, <structname>portal, web</structname>. </para>
    <figure>
      <title>Структура модуля global</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="" align="center" fileref="img/project_structure_global.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Модуль <structname>global</structname> содержит каталог исходных текстов <filename>src</filename>, в корне которого располагаются конфигурационные файлы <filename>
        <link linkend="metadata.xml">metadata.xml</link>
      </filename>, <filename>
        <link linkend="persistence.xml">persistence.xml</link>
      </filename> и <link linkend="views.xml">views.xml</link>.  Пакет <code>com.sample.sales.service</code> содержит интерфейсы сервисов <structname>Middleware</structname>, пакет <code>com.sample.sales.entity</code> - классы <link linkend="data_model">сущностей</link> и <link linkend="message_packs">файлы локализации</link> для них.</para>
    <figure>
      <title>Структура модуля core</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="" align="center" fileref="img/project_structure_core.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Модуль <structname>core</structname> содержит следующие каталоги:<itemizedlist>
        <listitem>
          <para><filename>db</filename> - каталог <link linkend="db_scripts">скриптов создания и обновления</link> базы данных.</para>
        </listitem>
        <listitem>
          <para><filename>src</filename> - каталог исходных текстов, в корне которого расположены файл <link linkend="app_properties_files">свойств приложения</link> блока <structname>Middleware</structname> и конфигурационный файл <filename>
              <link linkend="spring.xml">spring.xml</link>
            </filename>. Пакет <code>com.samples.sales.service</code> содержит классы  реализации <link linkend="services">сервисов</link>.</para>
        </listitem>
        <listitem>
          <para><filename>web</filename> - каталог с конфигурационными файлами веб-приложения, в которое собирается блок <structname>Middleware</structname>: <filename>
              <link linkend="context.xml">context.xml</link>
            </filename> и <filename>
              <link linkend="web.xml">web.xml</link>
            </filename>.</para>
        </listitem>
      </itemizedlist></para>
    <figure>
      <title>Структура модуля gui</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="" align="center" fileref="img/project_structure_gui.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Модуль <structname>gui</structname> содержит каталог исходных текстов <filename>src</filename>, в корне которого располагается конфигурационный файл <filename>
        <link linkend="screens.xml">screens.xml</link>
      </filename>. Пакет <code>com.sample.sales.gui</code> содержит XML-дескрипторы и контроллеры экранов и  <link linkend="message_packs">файлы локализации</link> для них.</para>
    <figure>
      <title>Структура модуля web</title>
      <mediaobject>
        <imageobject>
          <imagedata contentwidth="" align="center" fileref="img/project_structure_web.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Модуль <structname>web</structname> содержит следующие каталоги:<itemizedlist>
        <listitem>
          <para><filename>src</filename> - каталог исходных текстов, в корне которого расположены файл <link linkend="app_properties_files">свойств приложения</link> блока <structname>Web Client</structname> и конфигурационные файлы <filename>
              <link linkend="menu.xml">web-menu.xml</link>
            </filename>, <filename>
              <link linkend="permissions.xml">web-permissions.xml</link>
            </filename>, <filename>
              <link linkend="screens.xml">web-screens.xml</link>
            </filename> и <filename>
              <link linkend="spring.xml">web-spring.xml</link>
            </filename>. Пакет <code>com.samples.sales.web</code> содержит главный класс блока <structname>Web Client</structname> (наследник <code>DefaultApp</code>) и <link linkend="main_message_pack">главный пакет локализованных сообщений</link>.</para>
        </listitem>
        <listitem>
          <para><filename>web</filename> - каталог с конфигурационными файлами веб-приложения, в которое собирается блок <structname>Web Client</structname>: <filename>
              <link linkend="context.xml">context.xml</link>
            </filename> и <filename>
              <link linkend="web.xml">web.xml</link>
            </filename>.</para>
        </listitem>
      </itemizedlist></para>
  </section>
  <section id="build_scripts">
    <title>Описание скриптов сборки</title>
    <para>Для  сборки проектов на основе платформы используется система сборки <application>Gradle</application>. Скрипты сборки  представляют собой два файла в корневом каталоге проекта: <itemizedlist>
        <listitem>
          <para><filename>settings.gradle</filename> - задает название и состав <link linkend="app_modules">модулей</link> проекта</para>
        </listitem>
        <listitem>
          <para><filename>build.gradle</filename> - определяет конфигурацию сборки.</para>
        </listitem>
      </itemizedlist></para>
    <para>В данном разделе описывается структура скриптов, а также предназначение и параметры задач (tasks) Gradle.</para>
    <section id="build.gradle">
      <title>Структура build.gradle</title>
      <para>Секция <code>allprojects</code> задает группу и версию собираемых <link linkend="artifact">артефактов</link> проекта. Имена артефактов формируются на основе имен модулей, заданных в <filename>settings.gradle</filename>. Если свойство <code>ext.isSnapshot</code> равно <code>true</code>, то в именах  артефактов будет присутствовать суффикс <code>SNAPSHOT</code>. Свойство <code>ext.tomcatDir</code> задает расположение каталога <link linkend="build.gradle_setupTomcat">установки</link> <application>Tomcat</application>. Кроме того, в секции <code>allprojects</code> могут быть заданы следующие опциональные свойства:<itemizedlist>
          <listitem>
            <para><code>ext.copyright</code> - текст Copyright Notice,  вставляемый <application>IntelliJ IDEA</application> в файлы исходных текстов.</para>
          </listitem>
          <listitem>
            <para><code>ext.vcs</code> - тип используемой в проекте VCS. Если данное свойство указано, то в сгенерированных проектных файлах IntelliJ IDEA будет установлен параметр интеграции с данной VCS. Возможные значения: <literal>svn</literal>, <literal>Git</literal>. </para>
          </listitem>
          <listitem>
            <para><code>ext.uploadUrl</code> - URL <link linkend="artifact_repository">репозитория</link>, в который будут выгружатся собранные артефакты проекта при выполнении задачи <code>uploadArchives</code>. По умолчанию используется репозиторий <orgname>Haulmont</orgname>.</para>
          </listitem>
          <listitem>
            <para><code>ext.uploadUser</code> - имя пользователя репозитория для выгрузки собранных артефактов проекта. По умолчанию используется значение переменной окружения <literal>HAULMONT_REPOSITORY_USER</literal>.</para>
          </listitem>
          <listitem>
            <para><code>ext.uploadPassword</code> - пароль пользователя репозитория для выгрузки собранных артефактов проекта. По умолчанию используется значение переменной окружения <literal>HAULMONT_REPOSITORY_PASSWORD</literal>. </para>
          </listitem>
        </itemizedlist><tip>
          <para>Любое из свойств проекта можно задать не в самом <filename>build.gradle</filename>, а путем передачи в командной строке аргумента с префиксом <literal>-P</literal>, например:</para>
          <para><prompt>gradlew uploadArchives -PuploadUser=myuser -PuploadPassword=mypassword</prompt></para>
        </tip></para>
      <para>В секции  <code>buildscript</code> выполняется следующее:<itemizedlist>
          <listitem>
            <para>Задается версия базовых проектов платформы, на которой основан данный проект.</para>
          </listitem>
          <listitem>
            <para>Задается набор репозиториев, из которых будут загружаться зависимости проекта. В качестве имени и пароля для доступа к репозиторию зависимостей используются либо значения свойств проекта <code>repoUser</code> и <code>repoPass</code>, либо стандартные значения, явно указанные в скрипте сборки. Как и другие свойства проекта, <code>repoUser</code> и <code>repoPass</code> можно передать в командной строке в аргументах <literal>-P</literal>.</para>
          </listitem>
          <listitem>
            <para>Объявляется зависимость от плагина <structname>cuba-plugin</structname>, в котором сосредоточена специфика сборки проектов на платформе. Плагин подключается далее в конфигурацию сборки модулей с помощью метода<programlisting>apply(plugin: &apos;cuba&apos;)</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Далее в секциях <code>configure</code> определяются параметры сборки модулей приложения.</para>
      <para>Исполняемыми единицами в Gradle являются <firstterm>задачи</firstterm> (tasks). Они задаются как внутри плагинов, так и в самом скрипте сборки. Рассмотрим специфические для CUBA задачи, параметры которых могут быть сконфигурированы в <filename>build.gradle</filename>.<itemizedlist>
          <listitem>
            <para><code>enhance</code> - задача типа <code>CubaEnhancing</code>, выполняющая bytecode enhancement классов персистентных сущностей. Объявляется в <link linkend="app_modules">модуле</link> <structname>global</structname>. В параметре задачи <code>persistenceXml</code> указывается путь к файлу <link linkend="persistence.xml">
                <filename>persistence.xml</filename>
              </link> проекта.</para>
            <para>Например:<programlisting>task enhance(type: CubaEnhancing) {
    persistenceXml = &quot;${globalModule.projectDir}/src/persistence.xml&quot;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_enhanceTransient">
            <para><code>enhanceTransient</code> - задача типа <code>CubaEnhanceTransient</code>, выполняющая bytecode enhancement классов неперсистентных сущностей. В параметре задачи <code>metadataXml</code> указывается путь к файлу <link linkend="metadata.xml">
                <filename>metadata.xml</filename>
              </link> проекта.</para>
            <para>Например: <programlisting>task enhanceTransient(type: CubaEnhanceTransient) {
    &quot;${globalModule.projectDir}/src/metadata.xml&quot;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_setupTomcat">
            <para><code>setupTomcat</code> - задача типа <code>CubaSetupTomcat</code>, выполняющая установку и инициализацию локального сервера Tomcat для последующего <link linkend="fast_deployment">быстрого развертывания</link> приложения. Эта задача автоматически добавляется в проект при подключении плагина сборки <structname>cuba</structname>, поэтому объявлять ее в <filename>build.gradle</filename> не нужно. Каталог установки Tomcat задается свойством <code>ext.tomcatDir</code> в секции <code>allprojects</code>. По умолчанию это подкаталог <filename>build/tomcat</filename> проекта.</para>
          </listitem>
          <listitem id="build.gradle_deploy">
            <para><code>deploy</code> - задача типа <code>CubaDeployment</code>, выполняющая <link linkend="fast_deployment">быстрое развертывание</link> модуля в Tomcat. Объявляется в модулях <structname>core</structname>, <structname>web</structname>, <structname>portal</structname>. Параметры:<itemizedlist>
                <listitem>
                  <para><code>appName</code> - имя веб-приложения, которое будет создано из модуля. Фактически это имя подкаталога внутри <filename>tomcat/webapps</filename>.</para>
                </listitem>
                <listitem>
                  <para><code>jarNames</code> - список имен JAR файлов (без версии), получающихся в результате сборки модуля, которые надо поместить в каталог <filename>WEB-INF/lib</filename> веб-приложения. Все остальные артефакты модуля и зависимостей будут записаны в <filename>tomcat/shared/lib</filename>.</para>
                </listitem>
              </itemizedlist></para>
            <para>Например:<programlisting>task deploy(dependsOn: assemble, type: CubaDeployment) {
    appName = &apos;app-core&apos;
    jarNames = [&apos;cuba-global&apos;, &apos;cuba-core&apos;, &apos;app-global&apos;, &apos;app-core&apos;]
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_buildWar">
            <para><code>buildWar</code> - задача типа <code>CubaWarBuilding</code>, выполняющая сборку модуля в WAR-файл. Может быть объявлена в модулях <structname>core</structname>, <structname>web</structname>, <structname>portal</structname>, если требуется <link linkend="war_deployment">развертывание приложения в WAR</link>. Собранные WAR-файлы находятся в подкаталогах <filename>build/distributions</filename> модулей.</para>
            <para>Параметры задачи:<itemizedlist>
                <listitem>
                  <para><code>appName</code> - имя результирующего WAR-файла.</para>
                </listitem>
                <listitem>
                  <para><code>appHome</code> - путь к домашнему каталогу приложения. В домашнем каталоге будут располагаться файл конфигурации <link linkend="logging">логгирования</link>; каталог <link linkend="db_dir"> скриптов базы данных</link>; <link linkend="conf_dir">конфигурационный</link>, <link linkend="temp_dir">временный</link> и <link linkend="work_dir">рабочий</link> каталоги приложения.</para>
                  <para>В параметре <code>appHome</code> можно указать как абсолютный путь к домашнему каталогу, так и системную переменную, которая должна быть задана при запуске сервера. Например: <code>appHome = &apos;/work/sales_home&apos;</code> или <code>appHome = &apos;${app.home}&apos;</code></para>
                </listitem>
                <listitem>
                  <para><code>appProperties</code> - мэп свойств, которые будут записаны в файл <filename>WEB-INF/local.app.properties</filename> в дополнение к определенным в самой задаче. По умолчанию задача <code>buildWar</code> создает данный файл и определяет в нем свойства <code>cuba.logDir</code>, <code>cuba.confDir</code>, <code>cuba.tempDir</code>, <code>cuba.dataDir</code> для работы с домашним каталогом приложения, упомянутым выше. Кроме того, для приложения среднего слоя задается параметр <programlisting>cuba.dataSourceJndiName = jdbc/CubaDS</programlisting>а для приложения веб-клиента параметры <programlisting>cuba.connectionUrlList = http://localhost:8080/${appName}-core
cuba.useLocalServiceInvocation = false</programlisting></para>
                </listitem>
              </itemizedlist></para>
            <para>Пример задачи в модуле <structname>web</structname>:<programlisting>task buildWar(dependsOn: assemble, type: CubaWarBuilding) {
    appName = &apos;app&apos;
    appHome = &apos;${app.home}&apos;
    appProperties = [&apos;cuba.connectionUrlList&apos;: &apos;http://server/app-core&apos;]
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_createWarDistr">
            <para><code>createWarDistr</code> - задача типа <code>CubaWarDistribution</code>, выполняющая подготовку дистрибутива, включающего в себя <link linkend="war_deployment">WAR-файлы</link> приложений и их домашний каталог. Задача обязательно должна зависеть от задач <code>buildWar</code> модулей, и  имеет следующие параметры:<itemizedlist>
                <listitem>
                  <para><code>appHome</code> - путь к домашнему каталогу приложения (подробнее см. описание задачи <code>buildWar</code>).</para>
                </listitem>
                <listitem>
                  <para><code>distrDir</code> - путь к каталогу, в который копируется содержимое дистрибутива. Это необязательный параметр, по умолчанию используется подкаталог <filename>build/war</filename> проекта.</para>
                </listitem>
              </itemizedlist></para>
            <para>Пример описания задачи:<programlisting>task createWarDistr(dependsOn: [coreModule.buildWar, webModule.buildWar], type: CubaWarDistribution) {
    appHome = &apos;${app.home}&apos;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_createDb">
            <para><code>createDb</code> - задача типа <code>CubaDbCreation</code>, создающая базу данных приложения путем выполнения соответствующих <link linkend="db_scripts">скриптов</link>. Объявляется в модуле <structname>core</structname>. Параметры:<itemizedlist>
                <listitem>
                  <para><code>dbms</code> - тип СУБД, задается строкой <code>hsql</code>, <code>postgres</code>, <code>mssql</code> или <code>oracle</code>.</para>
                </listitem>
                <listitem>
                  <para><code>dbName</code> - имя базы данных. </para>
                </listitem>
                <listitem>
                  <para><code>dbUser</code> - имя пользователя СУБД.</para>
                </listitem>
                <listitem>
                  <para><code>dbPassword</code> - пароль пользователя СУБД.</para>
                </listitem>
                <listitem>
                  <para><code>host</code> - хост и, опционально, порт СУБД в формате <code>host[:port]</code>. Если не задан, используется <code>localhost</code>. </para>
                </listitem>
                <listitem>
                  <para><code>dropDbSql</code> - команда SQL для удаления БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД. </para>
                </listitem>
                <listitem>
                  <para><code>createDbSql</code> - команда SQL для создания БД. Если не задана, используется значение по умолчанию, зависящее от типа СУБД. </para>
                </listitem>
                <listitem>
                  <para><code>driverClasspath</code> - список JAR файлов, содержащих JDBC драйвер. Элементы списка разделяются символом &quot;:&quot; на Linux и символом &quot;;&quot; на Windows. Если не задан, используются зависимости, входящие в конфигурацию <code>jdbc</code> данного модуля. Явное задание <code>driverClasspath</code> актуально при использовании Oracle, т.к. его JDBC драйвер не присутствует в зависимостях. </para>
                </listitem>
                <listitem>
                  <para><code>oracleSystemPassword</code> - при использовании Oracle пароль пользователя SYSTEM.</para>
                </listitem>
              </itemizedlist></para>
            <para>Пример для PostgreSQL:<programlisting>task createDb(dependsOn: assemble, description: &apos;Creates local database&apos;, type: CubaDbCreation) {
    dbms = &apos;postgres&apos;
    dbName = &apos;sales&apos;
    dbUser = &apos;cuba&apos;
    dbPassword = &apos;cuba&apos;
}</programlisting></para>
            <para>Пример для MS SQL Server:<programlisting>task createDb(dependsOn: assemble, description: &apos;Creates local database&apos;, type: CubaDbCreation) {
    dbms = &apos;mssql&apos;
    dbName = &apos;sales&apos;
    dbUser = &apos;sa&apos;
    dbPassword = &apos;saPass1&apos;
}</programlisting></para>
            <para>Пример для Oracle:<programlisting>task createDb(dependsOn: assemble, description: &apos;Creates database&apos;, type: CubaDbCreation) {
    dbms = &apos;oracle&apos;
    host = &apos;192.168.1.10&apos;
    dbName = &apos;orcl&apos;
    dbUser = &apos;sales&apos;
    dbPassword = &apos;sales&apos;
    oracleSystemPassword = &apos;manager&apos;
    driverClasspath = &quot;$tomcatDir/lib/ojdbc6.jar&quot;
}</programlisting></para>
          </listitem>
          <listitem id="build.gradle_updateDb">
            <para><code>updateDb</code> - задача типа <code>CubaDbUpdate</code>, обновляющая базу данных приложения путем выполнения соответствующих <link linkend="db_scripts">скриптов</link>. Аналогична задаче <code>createDb</code>, за исключением отсутствия параметров <code>dropDbSql</code> и <code>createDbSql</code>.</para>
          </listitem>
          <listitem id="build.gradle_start">
            <para><code>start</code> - задача типа <code>CubaStartTomcat</code>, выполняющая запуск локального сервера Tomcat, установленного задачей <link linkend="build.gradle_setupTomcat">setupTomcat</link>. Эта задача автоматически добавляется в проект при подключении плагина <structname>cuba</structname>, поэтому объявлять ее в <filename>build.gradle</filename> не нужно.</para>
          </listitem>
          <listitem id="build.gradle_stop">
            <para><code>stop</code> - задача типа <code>CubaStopTomcat</code>, выполняющая остановку локального сервера Tomcat, установленного задачей <link linkend="build.gradle_setupTomcat">setupTomcat</link>. Эта задача автоматически добавляется в проект при подключении плагина <structname>cuba</structname>, поэтому объявлять ее в <filename>build.gradle</filename> не нужно.</para>
          </listitem>
          <listitem id="build.gradle_restart">
            <para><code>restart</code> - задача, выполняющая остановку, <link linkend="fast_deployment">быстрое развертывание</link>, и старт локального сервера Tomcat. </para>
          </listitem>
        </itemizedlist></para>
    </section>
    <section>
      <title>Запуск задач сборки</title>
      <para>Задачи (tasks) Gradle, описанные в скриптах сборки, запускаются на исполнение следующими способами:<itemizedlist>
          <listitem>
            <para>Если работа с проектом ведется с помощью <application> CUBA Studio</application>, то при выполнении пунктов меню <guimenu>Build</guimenu> и <guimenu>Run</guimenu> производится подключение к демону Gradle (запущенному на старте сервера Studio), который и выполняет соответствующие задачи.</para>
          </listitem>
          <listitem>
            <para>С помощью исполняемого скрипта <filename>gradlew</filename> (Gradle wrapper), включенного в проект. Этот скрипт должен находится в корневом каталоге проекта, и может быть создан в Studio с помощью команды <guimenu>Build</guimenu> -&gt; <guimenu>Create Gradle wrapper</guimenu>.</para>
          </listitem>
          <listitem>
            <para>С помощью установленного вручную Gradle версии <xi:include xmlns:xi="http://www.w3.org/2001/XInclude" href="var/gradleVersion.txt" encoding="UTF-8" parse="text"/>. В этом случае используется исполняемый скрипт <filename>gradle</filename>, находящийся в подкаталоге <filename>bin</filename> установленного Gradle.</para>
          </listitem>
        </itemizedlist></para>
      <tip>
        <para>Рекомендуется запускать команды <literal>gradlew</literal> или <literal>gradle</literal> с ключом <literal>--daemon</literal>, в этом случае демон Gradle остается в памяти и существенно ускоряет последующее выполнение.</para>
        <para>Для удаления демона из памяти используется ключ <literal>--stop</literal></para>
      </tip>
      <para>Например, чтобы выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта, необходимо запустить следующую команду:</para>
      <para><prompt>gradlew --daemon assemble</prompt></para>
      <para>Рассмотрим типичные задачи сборки в обычном порядке их использования.</para>
      <itemizedlist>
        <listitem>
          <para><code>idea</code> - создать проектные файлы <application>IntelliJ IDEA</application>. При выполнении этой задачи из репозитория артефактов в локальный кэш <application>Gradle</application> загружаются зависимости вместе со своими исходными кодами.</para>
        </listitem>
        <listitem>
          <para><code>cleanIdea</code> - удалить проектные файлы <application>IntelliJ IDEA</application>.</para>
        </listitem>
        <listitem>
          <para><code>assemble</code> - выполнить компиляцию Java файлов и сборку JAR файлов артефактов проекта в подкаталогах <filename>build</filename> модулей.</para>
        </listitem>
        <listitem>
          <para><code>clean</code> - удалить подкаталоги <filename>build</filename> всех модулей проекта.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_setupTomcat">setupTomcat</link> - установить сервер <application>Tomcat</application> в путь, заданный свойством <code>ext.tomcatDir</code> скрипта <filename>build.gradle</filename>. </para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_deploy">deploy</link> - <link linkend="fast_deployment">быстрое развертывание</link> приложения на сервере <application>Tomcat</application>, предварительно установленном задачей <code>setupTomcat</code>.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_createDb">createDb</link> - создание базы данных приложения и выполнение соответствующих <link linkend="db_scripts">скриптов</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_updateDb">updateDb</link> - обновление существующей базы данных приложения путем выполнения соответствующих <link linkend="db_scripts">скриптов</link>.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_start">start</link> - запуск сервера <application>Tomcat</application>.</para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_stop">stop</link> - остановка запущенного сервера <application>Tomcat</application>. </para>
        </listitem>
        <listitem>
          <para><link linkend="build.gradle_restart">restart</link> - последовательное выполнение задач <code>stop</code>, <code>deploy</code>, <code>start</code>. </para>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section>
    <title>Создание проекта</title>
    <para>Рекомендуемый способ создания нового проекта - использование <application>CUBA Studio</application>. Пример рассмотрен в главе &quot;Быстрый старт&quot; данного руководства: <xref linkend="qs_studio_setup"/></para>
    <para>Если применение <application>CUBA Studio</application> невозможно, для создания нового проекта необходимо выполнить следующее:<itemizedlist>
        <listitem>
          <para>Загрузить шаблон проекта, описанного в <xref linkend="qs_setup"/> главы &quot;Быстрый старт&quot;, и распаковать его в локальный каталог.</para>
        </listitem>
        <listitem>
          <para>Выбрать название проекта. Оно должно состоять только из латинских букв в нижнем регистре и быть не слишком длинным. Далее для примера используется название <code>bookstore</code>.</para>
        </listitem>
        <listitem>
          <para>Выбрать корневой Java пакет. Далее для примера используется  <code>com.sample.bookstore</code>.</para>
        </listitem>
        <listitem>
          <para>В файле <filename>settings.gradle</filename>  изменить строку с именем проекта:<programlisting>rootProject.name = &apos;bookstore&apos;</programlisting></para>
        </listitem>
        <listitem>
          <para>В файле <filename>build.gradle</filename> произвести следующие изменения:<itemizedlist>
              <listitem>
                <para>В переменной <code>ext.artifactGroup</code> указать желаемое название группы для артефактов. Этот параметр играет роль только при выгрузке собранных артефактов приложения в <link linkend="artifact_repository">репозиторий</link>. Например:<programlisting>allprojects {
    ext.artifactGroup = &apos;com.sample.bookstore&apos;
...</programlisting></para>
              </listitem>
              <listitem>
                <para>В секциях конфигурации модулей <structname>gui</structname>  и <structname>web</structname> указать для задачи <code>deployConf</code> директорию, из которой будут копироваться файлы. Например: </para>
                <programlisting>configure(guiModule) {
...
    task deployConf(type: Copy) {
        from file(&apos;src&apos;)
        include &quot;com/sample/bookstore/**&quot;
        into &quot;$tomcatDir/conf/app&quot;
    }
}


configure(webModule) {
...
    task deployConf(type: Copy) {
        from file(&apos;src&apos;)
        include &quot;com/sample/bookstore/**&quot;
        into &quot;$tomcatDir/conf/app&quot;
    }
}</programlisting>
              </listitem>
              <listitem>
                <para>В секции конфигурации модуля <structname>core</structname> указать для задач <code>startDB</code>, <code>stopDb</code>,    <code>createDb</code> и <code>updateDb</code> желаемое имя базы данных. Например:<programlisting>configure(coreModule) {
...
    task startDb(description: &apos;Starts local HSQLDB server&apos;, type: CubaHsqlStart) {
        dbName = &apos;bookstore&apos;
    }

    task stopDb(description: &apos;Stops local HSQLDB server&apos;, type: CubaHsqlStop)  {
        dbName = &apos;bookstore&apos;
    }

    task createDb(dependsOn: assemble, description: &apos;Creates local database&apos;, type: CubaDbCreation) {
        host = &apos;localhost&apos;
        dbms = &apos;hsql&apos;
        dbName = &apos;bookstore&apos;
        dbUser = &apos;sa&apos;
        dbPassword = &apos;&apos;
    }

    task updateDb(dependsOn: assemble, description: &apos;Updates local database&apos;, type: CubaDbUpdate) {
        host = &apos;localhost&apos;
        dbms = &apos;hsql&apos;
        dbName = &apos;bookstore&apos;
        dbUser = &apos;sa&apos;
        dbPassword = &apos;&apos;
    }
...</programlisting></para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>В модуле <structname>core</structname>: </para>
          <para>В файле <link linkend="context.xml">
              <filename>context.xml</filename>
            </link>  изменить URL подключения к базе данных:<programlisting language="xml">&lt;Context&gt;
    &lt;!-- PostgreSQL connection --&gt;
    &lt;Resource
...
      username=&quot;sa&quot;
      password=&quot;&quot;
      url=&quot;jdbc:hsqldb:hsql://localhost/bookstore&quot;/&gt;
...</programlisting></para>
          <para>В файле <filename>
              <link linkend="spring.xml">spring.xml</link>
            </filename> изменить базовый пакет поиска аннотированных бинов:<programlisting language="xml">&lt;context:component-scan base-package=&quot;com.sample.bookstore&quot;/&gt;</programlisting></para>
          <para>В файле <filename>app.properties</filename> изменить значение свойства приложения <link linkend="cuba.mainMessagePack">
              <property>cuba.mainMessagePack</property>
            </link>:<programlisting>cuba.mainMessagePack=com.haulmont.cuba.core com.sample.bookstore.core</programlisting> </para>
        </listitem>
        <listitem>
          <para>В модуле <structname>web</structname>: </para>
          <para>Перенести класс <code>App</code> и <link linkend="main_message_pack">файлы локализованных сообщений</link> в пакет <code>com.sample.bookstore.web</code>, и в файле <filename>web/WEB-INF/<link linkend="web.xml">web.xml</link></filename> указать новое расположение этого класса для сервлета <code>app_servlet</code>:<programlisting language="xml">&lt;servlet&gt;
    &lt;servlet-name&gt;app_servlet&lt;/servlet-name&gt;
    &lt;servlet-class&gt;com.haulmont.cuba.web.sys.CubaApplicationServlet&lt;/servlet-class&gt;
    &lt;init-param&gt;
        &lt;param-name&gt;application&lt;/param-name&gt;
        &lt;param-value&gt;com.sample.bookstore.web.App&lt;/param-value&gt;
    &lt;/init-param&gt;
...</programlisting></para>
          <para>Изменить значение свойства приложения <property>
              <link linkend="cuba.mainMessagePack">cuba.mainMessagePack</link>
            </property> в <filename>web-app.properties</filename>:<programlisting>cuba.mainMessagePack=com.haulmont.cuba.web com.sample.bookstore.web</programlisting></para>
          <para>В файле <filename>web-spring.xml</filename> изменить базовый пакет поиска аннотированных бинов:<programlisting>&lt;context:component-scan base-package=&quot;com.sample.bookstore&quot;/&gt;</programlisting> </para>
        </listitem>
        <listitem>
          <para>В модуле <structname>global</structname>:</para>
          <para>В файле <filename>
              <link linkend="metadata.xml">metadata.xml</link>
            </filename> необходимо исправить корневой пакет проекта:<programlisting>&lt;metadata-model root-package=&quot;com.sample.bookstore&quot;/&gt;</programlisting></para>
          <para>В файле <link linkend="persistence.xml">
              <filename>persistence.xml</filename>
            </link> необходимо исправить элемент <code>persistence-unit</code>:<programlisting>&lt;persistence-unit name=&quot;bookstore&quot; transaction-type=&quot;RESOURCE_LOCAL&quot;&gt;
&lt;/persistence-unit&gt;</programlisting></para>
        </listitem>
      </itemizedlist></para>
    <para>После выполнения вышеописанных действий можно собрать новый проект:</para>
    <para><prompt>gradlew idea assemble setupTomcat deploy</prompt></para>
  </section>
  <section id="db_dev">
    <title>Проектирование БД</title>
    <para>В данном разделе приведены практические рекомендации по работе с базой данных на этапе разработки приложения.</para>
    <para>Рекомендации по работе с базой данных на стадии эксплуатации приложения приведены в <xref linkend="db_update_in_prod"/>.</para>
    <section id="db_update_in_dev">
      <title>Создание схемы БД</title>
      <para>В процессе разработки приложения возникает необходимость создания и поддержания схемы базы данных, соответствующей моделируемым сущностям. Для решения этой задачи платформа предлагает подход на основе <link linkend="db_scripts">скриптов создания и обновления БД</link>. Далее рассматриваются практические шаги по применению этого подхода.</para>
      <para>Задача по созданию и поддержке схемы БД состоит из двух частей: создание скриптов и их выполнение.</para>
      <para>Скрипты могут быть созданы как вручную, так и с помощью Studio. Рассмотрим процесс создания скриптов в Studio. Для этого выполните команду <guibutton>Generate DB scripts</guibutton>, расположенную в секции <guilabel>Entities</guilabel>. При этом Studio подключается к базе данных, определенной на странице <guilabel>Project properties</guilabel>, и сравнивает имеющуюся схему БД с текущей моделью данных.</para>
      <para>Если  база данных отсутствует, либо в ней нет таблиц <database>SYS_DB_CHANGELOG</database> и <database>SEC_USER</database>, то генерируются только скрипты инициализации БД. В противном случае создаются также и скрипты обновления. Затем открывается страница, содержащая сгенерированные скрипты. </para>
      <para>На вкладке <guilabel>Update scripts</guilabel> отображаются скрипты обновления. Скрипты со статусом <guilabel>new</guilabel> отражают разницу между текущим состоянием  модели данных и схемы БД. Для каждой создаваемой или изменяемой таблицы создается отдельный скрипт. В отдельные скрипты помещаются также наборы ограничений целостности таблиц (referential integrity constraints). При закрытии страницы нажатием <guibutton>OK</guibutton> скрипты сохраняются в каталог <filename>db/update/{db_type}</filename> модуля <structname>core</structname>.</para>
      <para>Со статусом <guilabel>applied</guilabel> отображаются скрипты, уже имеющиеся в проекте и примененные в БД ранее. Они не могут быть отредактированы или удалены.</para>
      <para>На вкладке <guilabel>Update scripts</guilabel> могут также отображаться скрипты со статусом <guilabel>to be deleted</guilabel>. Это файлы, имеющиеся в проекте, но не примененные в БД. При закрытии страницы нажатием <guibutton>OK</guibutton> эти файлы будут удалены. Это нормально, если эти скрипты были созданы вами при предыдущей генерации, но не были применены вызовом <guibutton>Update database</guibutton>. В этом случае они больше не нужны, так как текущая разница между схемой  БД и моделью данных отражена в новых только что сгенерированных скриптах. Если же, например,  эти скрипты получены вами из системы контроля версий от другого разработчика, то вам следует отменить сохранение и сначала применить чужие скрипты на своей БД, а уже потом генерировать новые.</para>
      <para>Вкладки <guilabel>Init tables</guilabel>, <guilabel>Init constraints</guilabel>, <guilabel>Init data</guilabel> отображают скрипты <emphasis>создания</emphasis> БД, располагающиеся в каталоге <filename>db/init/{db_type}</filename> модуля <structname>core</structname>.</para>
      <para>На вкладке <guilabel>Init tables</guilabel> отображается скрипт создания таблиц <filename>10.create-db.sql</filename>. Код, относящийся к одной таблице, отделяется комментариями <code>begin {table_name} ... end {table_name}</code>. При изменении некоторой сущности в модели  Studio заменит код только между комментариями для соответствующей таблицы, не трогая  остальной код, в который могли быть внесены ручные изменения. Поэтому при ручном редактировании не удаляйте эти комментарии, иначе Studio не сможет правильно встраивать свои изменения в существующие файлы. </para>
      <para>На вкладке <guilabel>Init constraints</guilabel> отображается скрипт создания ограничений целостности <filename>20.create-db.sql</filename>. В нем также присутствуют разделяющие таблицы комментарии, которые нельзя удалять.</para>
      <para>На вкладке <guilabel>Init constraints</guilabel> отображается скрипт <filename>30.create-db.sql</filename>, предназначенный для внесения дополнительной информации при инициализации БД. Это могут быть, например, функции, триггеры, или DML операторы для наполнения базы необходимыми данными. Содержимое данного скрипта создается вручную при необходимости.</para>
      <tip>
        <para>На начальной стадии разработки приложения, когда модель данных активно меняется, рекомендуется пользоваться только скриптами <emphasis>создания</emphasis> БД (расположенными на вкладках  <guilabel>Init tables</guilabel>, <guilabel>Init constraints</guilabel>, <guilabel>Init data</guilabel>), а скрипты обновления на вкладке <guilabel>Update scripts</guilabel> удалять сразу после вызова команды <guibutton>Generate DB scripts</guibutton>. Это наиболее простой и надежный способ поддержания БД в актуальном состоянии. Разумеется, он имеет один существенный недостаток - при применении скриптов БД пересоздается с нуля, поэтому все внесенные в нее данные теряются. Этот недостаток можно частично компенсировать на этапе разработки, добавив в скрипт <guilabel>Init data</guilabel> команды для создания первичных данных при инициализации.</para>
        <para>Скрипты <emphasis>обновления</emphasis> становятся удобным и необходимым инструментом разработки и сопровождения БД на более позднем этапе, когда модель данных относительно стабильна, а в базах данных у разработчиков и в эксплуатации накоплены данные, которые нельзя терять при пересоздании БД с нуля.</para>
      </tip>
      <para>Для применения  скриптов используйте механизм <link linkend="db_update_gradle">выполнения скриптов БД задачами Gradle</link>: чтобы пересоздать базу данных полностью, вызовите в главном меню пункт <guimenu>Run</guimenu> -&gt; <guimenu>Create database</guimenu>, а чтобы применить скрипты обновления - пункт <guimenu>Run</guimenu> -&gt; <guimenu>Update database</guimenu>. Следует иметь в виду, что эти пункты доступны, только если сервер приложения остановлен. Разумеется, соответствующие задачи Gradle (<code>createDb</code> и <code>updateDb</code>) можно вызвать в любой момент из командной строки, но если при этом база данных или какие-либо ее объекты заняты, выполнение скриптов  завершится с ошибкой.</para>
    </section>
    <section id="db_hsql_connect">
      <title>Подключение к HSQLDB внешними инструментами</title>
      <para><application>HSQLDB</application>, он же <application>HyperSQL</application>, является удобной СУБД для прототипирования приложений, так как не требует установки, и запускается автоматически в CUBA Studio, если для проекта выбрано использование этой СУБД. В данном разделе описаны способы подключения к базе данных HSQLDB внешними инструментами, позволяющими работать со структурой и данными напрямую средствами SQL.</para>
      <section>
        <title>Подключение с помощью Squirrel SQL</title>
        <para><application>SQuirreL SQL Client</application> является свободно распространяемым Java-приложением, позволяющим работать с базами данных через JDBC. Загрузить Squirrel SQL можно по адресу <ulink url="http://squirrel-sql.sourceforge.net">http://squirrel-sql.sourceforge.net</ulink>.</para>
        <para>Запустите <application>Squirrel SQL</application> и перейдите на вкладку <guilabel>Drivers</guilabel>. Выделите в списке драйвер <guilabel>HSQLDB Server</guilabel>, нажмите на правую кнопку мыши и выберите <guilabel>Modify Driver</guilabel>.</para>
        <figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_modifyDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Перейдите в открывшемся окне на вкладку <guilabel>Extra Class Path</guilabel> и нажмите на кнопку <guibutton>Add</guibutton>, чтобы добавить <filename>.jar</filename>-файл с драйвером. </para>
        <figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_addDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Далее нужно выбрать драйвер <filename>hsqldb-x.x.x.jar</filename>. Можно воспользоваться JAR-файлом, который поставляется вместе с <application>CUBA Studio</application> - он находится в подкаталоге <filename>lib</filename>.</para>
        <figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_selectDriver.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>Далее создайте алиас для подключения к базе данных приложения.</para>
        <figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_createAlias.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>В открывшемся окне укажите параметры подключения - Database URL, пользователя и пароль. По-умолчанию пользователь - sa, пароль отсутствует. Database URL можно найти на вкладке <guilabel>Project properties</guilabel> в CUBA Studio или скопировать из файла <filename>modules/core/web/META-INF/context.xml</filename> проекта.</para>
        <figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/dev_setAliasProperties.png"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
      <section>
        <title>Подключение с помощью IntelliJ IDEA Ultimate</title>
        <para><application>IntelliJ IDEA Ultimate Edition</application> имеет удобные средства работы с базами данных. Рассмотрим, как подключиться к <application>HSQLDB</application> с ее помощью. Запустите <application>IDEA</application> и откройте панель <guilabel>Database</guilabel>. </para>
        <para>Создайте новый источник данных с помощью контекстного меню.</para>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/dev_idea_createDataSource.png"/>
          </imageobject>
        </mediaobject>
        <para>В открывшемся окне  выберите драйвер <filename>hsqldb-x.x.x.jar</filename>. Можно воспользоваться JAR-файлом, который поставляется вместе с <application>CUBA Studio</application> - он находится в подкаталоге <filename>lib</filename>.</para>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/dev_idea_selectDriver.png"/>
          </imageobject>
        </mediaobject>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/dev_idea_selectDriver2.png"/>
          </imageobject>
        </mediaobject>
        <para>Далее необходимо указать свойства источника данных: Dаtabase URL, пользователя и  пароль. Database URL можно найти на вкладке <guilabel>Project properties</guilabel> в CUBA Studio или скопировать из файла <filename>modules/core/web/META-INF/context.xml</filename> проекта. По-умолчанию пользователь - sa, пароль отсутствует.</para>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/dev_idea_setDbProperties.png"/>
          </imageobject>
        </mediaobject>
        <tip>
          <para>Если вы используете <application>PostgreSQL</application> в качестве СУБД и  <sgmltag>uuid</sgmltag> в качестве идентификатора, то при редактировании данных  в <application>IDEA</application> может возникнуть ошибка <userinput>ERROR: operator does not exist: uuid = character varying</userinput>.</para>
          <para>Для решения этой проблемы  в настройках источника данных перейдите на вкладку <guilabel>Advanced</guilabel> и присвойте свойству <property>stringtype</property> значение <literal>unspecified</literal>.</para>
          <figure>
            <title/>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/dev_idea_setStringtype.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </tip>
      </section>
    </section>
    <section id="db_postgres_features">
      <title>Особенности PostgreSQL</title>
      <para>Для создания базы данных PostgreSQL на Ubuntu-подобных операционных системах требуется установка пакета <application>postgresql-contrib</application>, содержащего функцию генерации UUID.</para>
    </section>
    <section id="db_mssql_features">
      <title>Особенности MS SQL Server</title>
      <para><application>Microsoft SQL Server</application> использует кластерные индексы для таблиц.</para>
      <para>По умолчанию кластерный индекс создается по первичному ключу таблицы, однако используемые в CUBA-приложении ключи типа <code>UUID</code> плохо подходят для кластерного индекса. Поэтому необходимо для каждой таблицы правильно выбрать и создать кластерный индекс. Поле для кластерного индекса должно быть небольшим и монотонно возрастающим, поэтому ориентировочные правила следующие:<itemizedlist>
          <listitem>
            <para>Для большинства таблиц подходит поле <database>CREATE_TS</database>. При этом записи будут физически располагаться в порядке их создания. </para>
          </listitem>
          <listitem>
            <para>Для композитных сущностей, если чтение превалирует над записью, имеет смысл использовать ссылку на владельца. При этом записи будут сгруппированы по владельцам, и их извлечение вместе с владельцем будет происходить быстрее. </para>
          </listitem>
          <listitem>
            <para>Для небольших (&lt; 100 записей) редко изменяемых таблиц тип кластерного индекса не важен, можно оставить <database>ID</database>. </para>
          </listitem>
          <listitem>
            <para>Для таблиц сущностей, унаследованных по стратегии <code>JOINED</code>, в которых нет поля <database>CREATE_TS</database>, нужно создать его искусственно с параметром <literal>default current_timestamp</literal>. </para>
          </listitem>
        </itemizedlist></para>
      <para>Пример:<programlisting>create table SALES_CUSTOMER (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    primary key nonclustered (ID)
)^

create clustered index IDX_SALES_CUSTOMER_CREATE_TS on SALES_CUSTOMER (CREATE_TS)^</programlisting></para>
      <para>Пример композитной сущности: <programlisting>create table SALES_ITEM (
    ID uniqueidentifier not null,
    CREATE_TS datetime,
    ...
    ORDER_ID uniqueidentifier,
    ...
    primary key nonclustered (ID),
    constraint FK_SALES_ITEM_ORDER foreign key (ORDER_ID) references SALES_ORDER(ID)
)^

create clustered index IDX_SALES_ITEM_ORDER on SALES_ITEM (ORDER_ID)^</programlisting></para>
      <para>Пример унаследованной сущности: <programlisting>create table SALES_DOC (
    CARD_ID uniqueidentifier,
    CREATE_TS datetime default current_timestamp,
    NUMBER varchar(50),
    primary key nonclustered (CARD_ID),
    constraint FK_SALES_DOC_CARD foreign key (CARD_ID) references WF_CARD (ID)
)^

create clustered index IDX_SALES_DOC_CREATE_TS on SALES_DOC (CREATE_TS)^

create index IDX_SALES_DOC_CARD on SALES_DOC (CARD_ID)^</programlisting></para>
    </section>
    <section id="db_oracle_features">
      <title>Особенности Oracle Database</title>
      <para>В связи с политикой распространения JDBC драйвера Oracle его можно скачать только вручную с сайта <ulink url="http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html">http://www.oracle.com/technetwork/database/features/jdbc/index-091264.html</ulink>. После скачивания скопируйте JAR с драйвером <filename>ojdbc6.jar</filename>  в  подкаталог <filename>lib</filename> <application>Studio</application> и подкаталог <filename>lib</filename> установленного сервера <application>Tomcat</application>. После этого необходимо остановить Studio, остановить демона Gradle, выполнив в командной строке <prompt>gradle --stop</prompt>, а затем снова запустить Studio.</para>
    </section>
  </section>
  <section id="logging">
    <title>Логгирование</title>
    <para>Для ведения логов в платформе используется фреймворк <application>Apache Log4j</application> версии 1.2.</para>
    <para>Для вывода в лог рекомендуется использовать <application>Commons Logging</application> API, получая логгер по имени текущего класса. Пример создания логгера и вывода в него:<programlisting language="java">import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

public class ...

    private Log log = LogFactory.getLog(getClass()); // create logger

    private void someMethod() {
        log.debug(&quot;someMethod invoked&quot;); // output message with DEBUG level
    }</programlisting> </para>
    <para>Настройка логгирования для <link linkend="app_tiers">блоков</link> <structname>Middleware</structname>, <structname>Web Client</structname> и <structname>Web Portal</structname> производится на уровне сервера приложения - в варианте <link linkend="fast_deployment">быстрого развертывания</link> это Tomcat. Блок <structname>Desktop Client</structname> имеет самостоятельную настройку логгирования.</para>
    <section id="logging_setup_tomcat">
      <title>Настройка логгирования в Tomcat</title>
      <para>При выполнении задачи Gradle <link linkend="build.gradle_setupTomcat">setupTomcat</link> в каталог проекта устанавливается сервер Tomcat, и производится его дополнительная конфигурация. В частности, в подкаталоге <filename>tomcat/bin</filename> создаются файлы <filename>setenv.bat</filename> и <filename>setenv.sh</filename>, а в подкаталоге <filename>tomcat/conf</filename> файл <filename>log4j.xml</filename>.</para>
      <para>Файлы <filename>setenv.*</filename> в переменной <code>CATALINA_OPTS</code> в числе прочего устанавливают параметры загрузки конфигурационного файла <filename>log4j.xml</filename>.</para>
      <para>Файл <filename>log4j.xml</filename> определяет конфигурацию логгирования. Рассмотрим структуру этого файла.<itemizedlist>
          <listitem>
            <para>Элементы <sgmltag>appender</sgmltag> задают &quot;устройства вывода&quot; логов. Основными аппендерами являются <code>FILE</code> и <code>CONSOLE</code>. В параметре <code>Threshold</code> аппендера можно задать порог уровня сообщения. По умолчанию порог для файла - <code>DEBUG</code>, для консоли - <code>INFO</code>. Это означает, что  в файл выводятся сообщения с уровнями <code>ERROR</code>, <code>WARN</code>, <code>INFO</code>, <code>DEBUG</code>, а в консоль - с уровнями <code>ERROR</code>, <code>WARN</code> и <code>INFO</code>.</para>
            <para>Для файлового аппендера в параметре <code>File</code> задается путь к файлу лога, а в параметре <code>Append</code> - признак, стирать ли содержимое файла при перезапуске сервера, или добавлять в конец. Настройки по умолчанию задают файл <filename>tomcat/logs/app.log</filename> и режим стирания при перезапуске. На этапе эксплуатации приложения рекомендуется установить для параметра <code>Append</code> значение <code>true</code>.</para>
            <para>Файловый аппендер по умолчанию реализуется классом <code>org.apache.log4j.DailyRollingFileAppender</code>, который ежедневно в 00:00:00 переименовывает накопившийся за день файл лога в имя с прошедшей датой, и начинает новый лог. Это позволяет избежать создания слишком больших файлов логов.</para>
          </listitem>
          <listitem>
            <para>Элементы <sgmltag>category</sgmltag> задают параметры логгеров, через которые производится посылка сообщений из кода программы. Имена категорий иерархические, то есть например настройки для категории <code>com.company.sample</code> влияют на логгеры <code>com.company.sample.core.CustomerServiceBean</code>, <code>com.company.sample.web.CustomerBrowse</code>, если для них явно не заданы собственные настройки.</para>
            <para>Минимальный уровень указывается в элементе <sgmltag>priority</sgmltag>. Например, если для категории задан приоритет <code>INFO</code>, то сообщения с уровнями <code>DEBUG</code> и <code>TRACE</code> выводиться не будут. Следует иметь в виду, что на вывод сообщения также влияет порог уровня, заданный в аппендере.</para>
          </listitem>
        </itemizedlist></para>
      <para>Оперативно изменять уровни для категорий и пороги аппендеров для работающего сервера можно с помощью экрана <guimenu>Администрирование</guimenu> -&gt; <guimenu>Журнал сервера</guimenu>, доступного в веб клиенте. Сделанные настройки логгирования действуют только в текущем сеансе работы сервера и в файл не сохраняются. Этот экран позволяет также просматривать и загружать файлы логов из <link linkend="log_dir">каталога журналов</link> сервера  <filename>tomcat/logs</filename>. </para>
      <para>Платформа автоматически добавляет к сообщениям, выводимым в лог, следующую информацию:<itemizedlist>
          <listitem>
            <para><userinput>[приложение]</userinput> - имя веб приложения, развернутого в Tomcat, код которого выводит данное сообщение. Эта информация помогает различить сообщения от разных блоков приложения (<structname>Middleware</structname>, <structname>Web Client</structname>), так как они выводятся в один файл.</para>
          </listitem>
          <listitem>
            <para><userinput>[пользователь]</userinput> - логин пользователя приложения, от имени которого в данный момент работает код, выводящий сообщение. Это позволяет в общем логе отслеживать активность конкретных пользователей. Если код, выводящий сообщение, не связан в момент вывода с пользовательской сессией, информация о пользователе не выводится.</para>
          </listitem>
        </itemizedlist></para>
      <para>Например, следующее сообщение в логе выведено кодом блока <structname>Middleware</structname> (<userinput>app-core</userinput>), работающим от имени пользователя <userinput>admin</userinput>:<programlisting>2013-12-19 18:48:17,282 DEBUG [com.haulmont.cuba.core.app.DataWorkerBean] [app-core] [admin] loadList: metaClass=sec$User, view=com.haulmont.cuba.security.entity.User/user.browse, query=select u from sec$User u, max=100</programlisting></para>
    </section>
    <section id="logging_setup_desktop">
      <title>Настройка логгирования в десктоп клиенте</title>
      <para>Для десктоп клиента файл <filename>log4j.xml</filename> должен находиться в каталоге исходников модуля <structname>desktop</structname> проекта. При сборке приложения  он упаковывается в соответствующий JAR файл и доступен в CLASSPATH. </para>
      <para>Для настройки логгирования в своем проекте выполните следующее:<itemizedlist>
          <listitem>
            <para>Создайте в каталоге <filename>src</filename> модуля <structname>desktop</structname> новый файл, например, <filename>sample-log4j.xml</filename>, и скопируйте в него содержимое файла <filename>cuba-log4j.xml</filename>. Файл <filename>cuba-log4j.xml</filename> находится внутри одного из JAR-файлов платформы и его легко найти поиском в IDE, если правильно сконфигурированы базовые проекты.</para>
          </listitem>
          <listitem>
            <para>Установите путь к файлу лога в параметре <code>File</code> аппендера <code>FILE</code>.</para>
          </listitem>
          <listitem>
            <para>Добавьте настройки для категорий логгеров вашего проекта.</para>
          </listitem>
          <listitem>
            <para>В классе-наследнике <code>com.haulmont.cuba.desktop.App</code> вашего проекта, например <code>SampleApp</code>, переопределите метод <code>getDefaultLog4jConfig()</code> и верните в нем путь относительно корня CLASSPATH к вашему файлу настроек. Например:<programlisting language="java">public class SampleApp extends App {
...
    @Override
    protected String getDefaultLog4jConfig() {
        return &quot;sample-log4j.xml&quot;;
    }</programlisting></para>
          </listitem>
          <listitem>
            <para>При необходимости можно переопределить местонахождение файла конфигурации на старте приложения с помощью системного свойства <property>
                <link linkend="log4j.configuration">log4j.configuration</link>
              </property>.</para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>
  <section id="debug_and_testing">
    <title>Отладка и тестирование</title>
    <para>В данном разделе рассмотрены различные аспекты отладки и тестирования  CUBA-приложений.</para>
    <section id="debug_setup">
      <title>Подключение отладчика</title>
      <para>Запустить сервер Tomcat в режиме отладки можно либо выполнением команды сборки</para>
      <para><prompt>gradle start</prompt></para>
      <para>либо запуском командного файла <filename>bin/debug.*</filename> установленного <application>Tomcat</application>.</para>
      <para>После этого сервер будет принимать подключения отладчика на порту 8787. Порт можно изменить в файле <filename>bin/setenv.*</filename> в переменной <code>JPDA_OPTS</code>.</para>
      <para>Для пошаговой отладки в <application>Intellij IDEA</application> необходимо в проекте приложения создать новый элемент  <guilabel>Run/Debug Configuration</guilabel> типа <guilabel>Remote</guilabel>, и в его поле <guilabel>Port</guilabel> указать 8787.</para>
    </section>
    <section id="testing">
      <title>Тестирование</title>
      <section id="unit_tests">
        <title>Модульные тесты</title>
        <para>Модульные тесты (unit tests) можно создавать и выполнять и на <link linkend="app_tiers">уровне</link> <structname>Middleware</structname>, и на клиентском уровне. Для этого платформа включает в себя фреймворки <ulink url="http://junit.org">JUnit</ulink> и <ulink url="http://code.google.com/p/jmockit">JMockit</ulink>.</para>
        <para>Допустим, имеется следующий контроллер экрана:<programlisting language="java">public class OrderEditor extends AbstractEditor {

    @Named(&quot;itemsTable.add&quot;)
    protected AddAction addAction;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        addAction.setWindowId(&quot;sales$Product.lookup&quot;);
        addAction.setHandler(new Lookup.Handler() {
            @Override
            public void handleLookup(Collection items) {
                // some code
            }
        });
    }
}</programlisting></para>
        <para>Тогда можно написать следующий тест, проверяющий работу метода <code>init()</code>:<programlisting language="java">public class OrderEditorTest {

    OrderEditor editor;

    @Mocked
    Window.Editor frame;

    @Mocked
    AddAction addAction;

    @Before
    public void setUp() throws Exception {
        editor = new OrderEditor();
        editor.setWrappedFrame(frame);
        editor.addAction = addAction;
    }

    @Test
    public void testInit() {
        editor.init(Collections.&lt;String, Object&gt;emptyMap());
        editor.setItem(new Order());

        new Verifications() {
            {
                addAction.setWindowId(&quot;sales$Product.lookup&quot;);
                addAction.setHandler(withInstanceOf(Window.Lookup.Handler.class));
            }
        };
    }
}</programlisting></para>
      </section>
      <section id="integration_tests_mw">
        <title>Интеграционные тесты Middleware</title>
        <para>На уровне <structname>Middleware</structname> можно создавать интеграционные тесты, которые выполняются в полнофункциональном контейнере <application>Spring</application> с подключением к базе данных. В тестах такого типа можно выполнять код любого слоя внутри <structname>Middleware</structname> - от сервисов до ORM. </para>
        <para>Для создания интеграционных тестов в модуле <structname>core</structname> проекта приложения должен быть создан базовый класс - наследник <code>CubaTestCase</code>. В этом классе должны быть переопределены методы инициализации доступа к данным  и получения списка файлов конфигурации. Например: <programlisting language="java">public class SalesTestCase extends CubaTestCase {

    @Override
    protected void initDataSources() throws Exception {
        Class.forName(&quot;org.postgresql.Driver&quot;);
        TestDataSource ds = new TestDataSource(&quot;jdbc:postgresql://localhost/sales_test&quot;, &quot;cuba&quot;, &quot;cuba&quot;);
        TestContext.getInstance().bind(&quot;java:comp/env/jdbc/CubaDS&quot;, ds);
    }

    @Override
    protected List&lt;String&gt; getTestAppProperties() {
        String[] files = {
                &quot;cuba-app.properties&quot;,
                &quot;app.properties&quot;,
                &quot;test-app.properties&quot;,
        };
        return Arrays.asList(files);
    }
}</programlisting></para>
        <para>В качестве базы данных  рекомендуется использовать отдельную тестовую БД, которую можно создавать, например, следующей задачей в <filename>build.gradle</filename>: <programlisting>configure(coreModule) {
...
    task createTestDb(dependsOn: assemble, description: &apos;Creates local Postgres database for tests&apos;, type: CubaDbCreation) {
        dbms = &apos;postgres&apos;
        dbName = &apos;sales_test&apos;
        dbUser = &apos;cuba&apos;
        dbPassword = &apos;cuba&apos;
    }</programlisting></para>
        <para>Класс <code>CubaTestCase</code>  содержит следующие поля и методы, которые можно использовать в коде тестов:<itemizedlist>
            <listitem>
              <para><code>persistence</code> - ссылка на интерфейс <code>
                  <link linkend="persistence">Persistence</link>
                </code></para>
            </listitem>
            <listitem>
              <para><code>metadata</code> - ссылка на интерфейс <code>
                  <link linkend="metadata">Metadata</link>
                </code></para>
            </listitem>
            <listitem>
              <para><code>deleteRecord()</code> - метод, который удобно использовать в <code>tearDown()</code> для удаления тестовых объектов из БД.</para>
            </listitem>
          </itemizedlist></para>
        <para>Пример теста, проверяющего чтение сущностей из базы данных:<programlisting language="java">public class CustomerLoadTest extends SalesTestCase {

    private UUID customerId;

    @Override
    public void setUp() throws Exception {
        super.setUp();
        persistence.createTransaction().execute(new Transaction.Runnable() {
            @Override
            public void run(EntityManager em) {
                Customer customer = new Customer();
                customerId = customer.getId();
                customer.setName(&quot;testCustomer&quot;);
                em.persist(customer);
            }
        });
    }

    @Override
    public void tearDown() throws Exception {
        deleteRecord(&quot;SALES_CUSTOMER&quot;, customerId);
        super.tearDown();
    }

    public void test() {
        Transaction tx = persistence.createTransaction();
        try {
            EntityManager em = persistence.getEntityManager();
            TypedQuery&lt;Customer&gt; query = em.createQuery(
                &quot;select c from sales$Customer c&quot;, Customer.class);
            List&lt;Customer&gt; list = query.getResultList();
            tx.commit();
            assertTrue(list.size() &gt; 0);
        } finally {
            tx.end();
        }
    }
}</programlisting></para>
      </section>
      <section id="integration_tests_client">
        <title>Интеграционные тесты клиентского уровня</title>
        <para>Интеграционные тесты на клиентском уровне реализуются с применением  фреймворка <application>
            <ulink url="http://code.google.com/p/jmockit">JMockit</ulink>
          </application>. С его помощью тест изолируется от <structname>Middleware</structname>, а также создаются необходимые объекты инфраструктуры. </para>
        <para>Класс клиентского интеграционного теста должен быть унаследован от <code>CubaClientTestCase</code>. В методе <code>@Before</code> необходимо вызвать унаследованные методы <code>addEntityPackage()</code>, <code>setViewConfig()</code> и затем <code>setupInfrastructure()</code> для создания объектов <code>
            <link linkend="metadata">Metadata</link>
          </code> и <code>
            <link linkend="configuration">Configuration</link>
          </code> и развертывания метаданных по выбранным сущностям. Далее в методе <code>@Before</code> можно дополнить инфраструктуру необходимыми мок-объектами с помощью конструкции <code>Expectations</code> или <code>NonStrictExpectations</code>. </para>
        <para>Пример инициализирующего метода <code>@Before</code> одного из тестов платформы:<programlisting language="java">@Before
public void setUp() throws Exception {
    addEntityPackage(&quot;com.haulmont.cuba.security.entity&quot;);
    addEntityPackage(&quot;com.haulmont.cuba.core.entity&quot;);
    addEntityPackage(&quot;com.haulmont.cuba.gui.data.impl.testmodel1&quot;);
    setViewConfig(&quot;/com/haulmont/cuba/gui/data/impl/testmodel1/test-views.xml&quot;);
    setupInfrastructure();

    metadataSession = metadata.getSession();
    dataService = new TestDataSupplier();

    dataService.commitCount = 0;

    new NonStrictExpectations() {
        @Mocked ClientConfig clientConfig;
        @Mocked PersistenceHelper persistenceHelper;
        {
            configuration.getConfig(ClientConfig.class); result = clientConfig;

            clientConfig.getCollectionDatasourceDbSortEnabled(); result = true;

            persistenceManager.getMaxFetchUI(anyString); result = 10000;

            PersistenceHelper.isNew(any); result = false;
        }
    };
}</programlisting></para>
      </section>
    </section>
  </section>
  <section id="dev_recipes">
    <title>Рецепты разработки</title>
    <para>В данном разделе рассматриваются способы решения некоторых практических задач. </para>
    <section id="getting_messages">
      <title>Получение локализованных сообщений</title>
      <para>В данном разделе рассмотрены способы получения <link linkend="localization">локализованных сообщений</link> в различных компонентах приложения.</para>
      <itemizedlist>
        <listitem>
          <para>В <link linkend="screen_xml">XML-дескрипторах</link> экранов атрибуты компонентов, отображающие статичный текст (например <link linkend="gui_attr_basic_caption">caption</link>), могут обращаться к  локализованным сообщениям по правилам метода <link linkend="messageTools.loadString">MessageTools.loadString()</link>. Например:<itemizedlist>
              <listitem>
                <para><code>caption=&quot;msg://roleName&quot;</code> - получить сообщение, заданное ключом <code>roleName</code> в пакете сообщений текущего экрана. Пакет сообщений экрана задается в атрибуте <code>messagesPack</code> корневого элемента <code>window</code>.</para>
              </listitem>
              <listitem>
                <para><code>caption=&quot;msg://com.company.sample.entity/Role.name&quot;</code> - получить сообщение, заданное ключом <code>Role.name</code> в пакете сообщений <code>com.company.sample.entity</code>.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>В <link linkend="screen_controller">контроллерах экранов</link> локализованные сообщения можно получать следующими способами:<itemizedlist>
              <listitem>
                <para>Из пакета сообщений текущего экрана:<itemizedlist>
                    <listitem>
                      <para>Методом <code>getMessage()</code>, унаследованным от базового класса <link linkend="abstractFrame">AbstractFrame</link>. Например:<programlisting language="java">String msg = getMessage(&quot;warningMessage&quot;);</programlisting></para>
                    </listitem>
                    <listitem>
                      <para>Методом <code>formatMessage()</code>, унаследованным от базового класса <code>AbstractFrame</code>. В этом случае сообщение используется для форматирования  переданных параметров по правилам метода <code>String.format()</code>. Например:</para>
                      <para>messages.properties:<programlisting>warningMessage = Invalid email address: &apos;%s&apos;</programlisting></para>
                      <para>Java-контроллер:<programlisting language="java">String msg = formatMessage(&quot;warningMessage&quot;, email);</programlisting></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para>Из произвольного пакета сообщений путем инжекции  интерфейса инфраструктуры <link linkend="messages">Messages</link>. Например:<programlisting language="java">@Inject
private Messages messages;

@Override
public void init(Map&lt;String, Object&gt; params) {
    String msg = messages.getMessage(getClass(), &quot;warningMessage&quot;);
    ...
} </programlisting></para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para>В компонентах, управляемых контейнером Spring (<link linkend="managed_beans">управляемых бинах</link>, <link linkend="services">сервисах</link>, <link linkend="jmx_beans">JMX-бинах</link>, контроллерах Spring MVC модуля <structname>portal</structname>) локализованные сообщения можно получать путем инжекции  интерфейса инфраструктуры <link linkend="messages">Messages</link>:<programlisting language="java">@Inject
protected Messages messages;
...
String msg = messages.getMessage(getClass(), &quot;warningMessage&quot;);</programlisting></para>
        </listitem>
        <listitem>
          <para>В любом коде приложения, где невозможна инжекция, интерфейс <code>Messages</code> может быть получен с помощью статического метода <code>get()</code> класса <code>AppBeans</code>:<programlisting language="java">protected Messages messages = AppBeans.get(Messages.class);
...
String msg = messages.getMessage(getClass(), &quot;warningMessage&quot;);</programlisting></para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="init_values">
      <title>Присвоение начальных значений</title>
      <para>Присвоение начальных значений атрибутам новых экземпляров сущностей можно производить несколькими способами.</para>
      <section id="init_values_in_class">
        <title>Инициализация полей сущности</title>
        <para>Атрибуты простых типов (<code>Boolean</code>, <code>Integer</code> и т.д.) можно инициализировать прямо в объявлении соответствующего поля класса сущности, например:<programlisting language="java">public class User extends StandardEntity {
...
    @Column(name = &quot;ACTIVE&quot;)
    protected Boolean active = true;
...
}</programlisting></para>
        <para>Кроме того, в классе сущности можно создать специальный метод инициализации и добавить ему аннотацию <link linkend="postConstruct_entity_annotation">@PostConstruct</link>. В этом случае в процессе  инициализации можно использовать вызов любых глобальных <link linkend="infrastructure_interfaces">интерфейсов инфраструктуры</link> и <link linkend="managed_beans">бинов</link>, например:<programlisting language="java">public class MyEntity extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;USER_ID&quot;)
    protected User creator;
...
    @PostConstruct
    protected void init() {
       setCreator(AppBeans.get(UserSessionSource.class).getUser());
    }
}</programlisting></para>
      </section>
      <section id="init_values_in_CreateAction">
        <title>Инициализация с помощью CreateAction</title>
        <para>Если начальное значение атрибута зависит от данных вызывающего экрана, то можно воспользоваться методом <code>setInitialValues()</code> класса <link linkend="createAction">CreateAction</link>.</para>
        <para>Рассмотрим для примера две связанные сущности:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/init_values_recipe_1.png"/>
            </imageobject>
          </mediaobject></para>
        <para>Фрагмент XML-дескриптора экрана, отображающего одновременно  списки обоих сущностей:<programlisting language="xml">&lt;dsContext&gt;
    &lt;collectionDatasource id=&quot;typesDs&quot;
                          class=&quot;com.haulmont.sample.entity.DeviceType&quot;
                          view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select e from sample$DeviceType e
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
    &lt;collectionDatasource id=&quot;descriptionsDs&quot;
                          class=&quot;com.haulmont.sample.entity.DeviceDescription&quot;
                          view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select e from sample$DeviceDescription e where e.deviceType.id = :ds$typesDs
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
...
        &lt;table id=&quot;typeTable&quot;&gt;
            &lt;actions&gt;
                &lt;action id=&quot;create&quot;/&gt;
                &lt;action id=&quot;edit&quot;/&gt;
                &lt;action id=&quot;remove&quot;/&gt;
            &lt;/actions&gt;
            &lt;columns&gt;
                &lt;column id=&quot;name&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;typesDs&quot;/&gt;
        &lt;/table&gt;
...
        &lt;table id=&quot;descriptionTable&quot;&gt;
            &lt;actions&gt;
                &lt;action id=&quot;create&quot;/&gt;
                &lt;action id=&quot;edit&quot;/&gt;
                &lt;action id=&quot;remove&quot;/&gt;
            &lt;/actions&gt;
            &lt;columns&gt;
                &lt;column id=&quot;description&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;descriptionsDs&quot;/&gt;
        &lt;/table&gt;
    &lt;/split&gt;
&lt;/layout&gt;</programlisting></para>
        <para>Контроллер этого экрана:<programlisting language="java">public class DeviceTypeBrowse extends AbstractLookup {

    @Inject
    private CollectionDatasource&lt;DeviceType, UUID&gt; typesDs;

    @Named(&quot;descriptionTable.create&quot;)
    private CreateAction descrCreateAction;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        typesDs.addListener(new CollectionDsListenerAdapter&lt;DeviceType&gt;() {
            @Override
            public void itemChanged(Datasource&lt;DeviceType&gt; ds, @Nullable DeviceType prevItem, @Nullable DeviceType item) {
                descrCreateAction.setInitialValues(Collections.&lt;String, Object&gt;singletonMap(&quot;deviceType&quot;, item));
            }
        });
    }
}</programlisting></para>
        <para>В контроллере источнику данных <code>typesDs</code> добавляется слушатель на событие изменения выбранной записи. При смене выбранной записи вызывается метод <code>setInitialValues()</code> действия, и ему передается мэп с одним элементом, ключом которого является навание атрибута - <code>deviceType</code>, а значением - выбранный экземпляр <code>DeviceType</code>. Таким образом при выполнении действия <code>CreateAction</code> в атрибуте <code>deviceType</code> нового экземпляра <code>DeviceDescription</code> будет сразу установлен выбранный в таблице экземпляр <code>DeviceType</code>.</para>
      </section>
      <section id="init_values_in_initNewItem">
        <title>Использование метода initNewItem </title>
        <para>Начальные значения можно также задать в контроллере экрана создаваемой сущности в методе <link linkend="initNewItem">initNewItem()</link>.</para>
        <para>В качестве примера рассмотрим следующую задачу: в проекте имеется сущность <code>Employee</code> (сотрудник компании), которая должна быть связана один-к-одному с платформенной сущностью <code>User</code> (пользователь системы). При создании сотрудника должен создаваться новый экземпляр пользователя.<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/init_values_recipe_2.png"/>
            </imageobject>
          </mediaobject></para>
        <para>В XML-дескрипторе экрана редактирования сотрудника объявляем источник данных для экземпляра сотрудника и вложенный источник - для связанного пользователя:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;employeeDs&quot;
                class=&quot;com.haulmont.sample.entity.Employee&quot;
                view=&quot;employee-edit&quot;&gt;
        &lt;datasource id=&quot;userDs&quot;
                    property=&quot;user&quot;/&gt;
    &lt;/datasource&gt;
&lt;/dsContext&gt;</programlisting></para>
        <para>В контроллере экрана редактирования сотрудника определяем:<programlisting language="java">@Inject
private Metadata metadata;

private Group defaultGroup;
private Role defaultRole;

@Override
protected void initNewItem(Employee item) {
    User user = metadata.create(User.class);
    user.setGroup(defaultGroup);
    final UserRole userRole = metadata.create(UserRole.class);
    userRole.setUser(user);
    userRole.setRole(defaultRole);
    getDsContext().addListener(new DsContext.CommitListenerAdapter() {
        @Override
        public void beforeCommit(CommitContext context) {
            context.getCommitInstances().add(userRole);
        }
    });
    item.setUser(user);
}</programlisting></para>
        <para>Здесь в методе <code>initNewItem()</code> создается новый экземпляр <code>User</code>, и для него устанавливается некоторая группа доступа <code>defaultGroup</code>. Связь с ролью <code>defaultRole</code> устанавливается с помощью нового экземпляра сущности <code>UserRole</code>. Для сохранения этой связи в БД при коммите экрана, экземпляр <code>UserRole</code> добавляется в коллекцию сохраняемых сущностей в методе <code>beforeCommit()</code> слушателя <link linkend="dsContext">DsContext.CommitListener</link>. </para>
        <para>Новый экземпляр <code>User</code>  устанавливается в соответствующем атрибуте редактируемой сущности <code>Employee</code>, и тем самым оказывается во вложенном источнике данных <code>userDs</code>. Это дает возможность редактировать нужные атрибуты пользователя в экране сотрудника, а также приводит к автоматическому сохранению экземпляра пользователя при коммите экрана в одной транзакции с остальными сущностями.</para>
      </section>
    </section>
    <section id="composition_recipe">
      <title>Редактирование композитных сущностей</title>
      <para>Платформа CUBA поддерживает два типа связи между сущностями: ассоциацию  и композицию. В интерфейсе <application>CUBA Studio</application> они названы соответственно ASSOCIATION и COMPOSITION. Ассоциация - это связь между объектами, которые могут существовать отдельно друг от друга. Композиция же используется для связи типа &quot;master-detail&quot; когда экземпляры detail существуют только в составе master. Примером композиции может служить связь аэропорта и терминалов: терминал, не относящийся ни к какому аэропорту, не имеет смысла.</para>
      <para>Как правило, редактирование сущностей, входящих в состав композиции, удобно осуществлять совместно. То есть, например, пользователь открывает экран редактирования аэропорта, видит в нем список терминалов, может создавать и редактировать их, но все изменения, как аэропорта, так и терминалов,  сохраняются в базу данных вместе в одной транзакции, и  только тогда, когда пользователь подтвердит сохранение главной сущности - аэропорта.</para>
      <section>
        <title>Реализация композиции</title>
        <para>Рассмотрим реализацию композиции на примере сущностей <code>Airport</code> и <code>Terminal</code>:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/composition_recipe_1.png"/>
            </imageobject>
          </mediaobject></para>
        <orderedlist>
          <listitem>
            <para>Сущность <code>Terminal</code> содержит обязательную ссылку на <code>Airport</code>:<programlisting language="java">@Entity(name = &quot;sample$Terminal&quot;)
@Table(name = &quot;SAMPLE_TERMINAL&quot;)
public class Terminal extends StandardEntity {
...    
    @ManyToOne(optional = false, fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;AIRPORT_ID&quot;)
    private Airport airport;

    public Airport getAirport() {
        return airport;
    }

    public void setAirport(Airport airport) {
        this.airport = airport;
    }
}</programlisting></para>
          </listitem>
          <listitem>
            <para>Сущность <code>Airport</code> содержит one-to-many коллекцию терминалов. Соответствующее поле помечается аннотацией <link linkend="composition_annotation">@Composition</link> для огранизации композиции и <link linkend="onDelete_annotation">@OnDelete</link> для каскадного мягкого удаления:<programlisting language="java">@Entity(name = &quot;sample$Airport&quot;)
@Table(name = &quot;SAMPLE_AIRPORT&quot;)
public class Airport extends StandardEntity {
...
    @OneToMany(fetch = FetchType.LAZY, mappedBy = &quot;airport&quot;)
    @OnDelete(DeletePolicy.CASCADE)
    @Composition
    protected List&lt;Terminal&gt; terminals;

    public List&lt;Terminal&gt; getTerminals() {
        return terminals;
    }

    public void setTerminals(List&lt;Terminal&gt; terminals) {
        this.terminals = terminals;
    }
}</programlisting></para>
          </listitem>
          <listitem>
            <para><link linkend="views">Представление</link>, используемое в экране редактирования аэропорта, должно содержать атрибут-коллецию <code>terminals</code>:<programlisting language="xml">&lt;view entity=&quot;sample$Airport&quot; name=&quot;airport-edit&quot; extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;terminals&quot; view=&quot;_local&quot;/&gt;
&lt;/view&gt;</programlisting></para>
            <para>Для сущности <code>Terminal</code> здесь выбрано представление <code>_local</code>, хотя она содержит ссылочный атрибут <code>airport</code> - ссылку на аэропорт. Дело в том, что атрибут <code>airport</code> устанавливается только при создании нового экземпляра <code>Terminal</code>, и не меняется в дальнейшем, поэтому загружать его не обязательно.</para>
          </listitem>
          <listitem>
            <para>В XML-дескрипторе экрана редактирования аэропорта определяем источники данных для экземпляра <code>Airport</code> и коллекции его терминалов:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;airportDs&quot;
                class=&quot;com.haulmont.sample.entity.Airport&quot;
                view=&quot;airport-edit&quot;&gt;
        &lt;collectionDatasource id=&quot;terminalsDs&quot; property=&quot;terminals&quot;/&gt;
    &lt;/datasource&gt;
&lt;/dsContext&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>В XML-дескрипторе экрана редактирования аэропорта определяем таблицу, отображающую терминалы, и <link linkend="list_actions">стандартные действия</link> для нее:<programlisting language="xml">&lt;table id=&quot;terminalsTable&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;create&quot;/&gt;
        &lt;action id=&quot;edit&quot;/&gt;
        &lt;action id=&quot;remove&quot;/&gt;
    &lt;/actions&gt;
    &lt;buttonsPanel&gt;
        &lt;button action=&quot;terminalsTable.create&quot;/&gt;
        &lt;button action=&quot;terminalsTable.edit&quot;/&gt;
        &lt;button action=&quot;terminalsTable.remove&quot;/&gt;
    &lt;/buttonsPanel&gt;
    &lt;columns&gt;
        &lt;column id=&quot;code&quot;/&gt;
        &lt;column id=&quot;name&quot;/&gt;
        &lt;column id=&quot;address&quot;/&gt;
    &lt;/columns&gt;
    &lt;rows datasource=&quot;terminalsDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>В экране редактирования терминала достаточно  определить стандартные элементы: <code>datasource</code> для экземпляра <code>Terminal</code> и визуальные компоненты, связанные с этим <code>datasource</code>, для редактирования атрибутов терминала.</para>
          </listitem>
        </orderedlist>
        <para>В результате редактирование экземпляра аэропорта работает следующим образом:<itemizedlist>
            <listitem>
              <para>В экране редактирования аэропорта отображается таблица терминалов.</para>
            </listitem>
            <listitem>
              <para>Пользователь может выбрать терминал и открыть экран его редактирования. При нажатии <guibutton>OK</guibutton> в экране редактирования терминала измененный экземпляр терминала сохраняется не в базу данных, а в источник данных <code>terminalsDs</code> экрана редактирования аэропорта. </para>
            </listitem>
            <listitem>
              <para>Пользователь может создавать новые или удалять терминалы - все изменения сохраняются в источнике данных <code>terminalsDs</code>.</para>
            </listitem>
            <listitem>
              <para>Пользователь нажимает <guibutton>OK</guibutton> в экране редактирования аэропорта, и измененный <code>Airport</code> вместе со всеми измененными экземплярами <code>Terminal</code> отправляется на Middleware в метод <link linkend="dataService">DataService</link>.commit() и сохраняется в базе данных в рамках одной транзакции. </para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Глубокая композиция</title>
        <para>Композиция может быть более глубокой, то есть состоять из нескольких уровней вложенности. Усложним приведенный выше пример, добавив сущность <code>MeetingPoint</code>, описывающую место встречи у терминала аэропорта:<mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/composition_recipe_2.png"/>
            </imageobject>
          </mediaobject></para>
        <para>Теперь сущность <code>Terminal</code> содержит атрибут <code>meetingPoints</code> - коллекцию экземпляров <code>MeetingPoint</code>. Для того, чтобы все три сущности представляли собой единую композицию и редактировались совместно, нужно в дополнение к описанному в предыдущем разделе выполнить следующее:<orderedlist>
            <listitem>
              <para>Атрибуту <code>meetingPoints</code> класса <code>Terminal</code> добавить аннотации <code>@Composition</code> и <code>@OnDelete</code> аналогично атрибуту <code>terminals</code> класса <code>Airport</code>.</para>
            </listitem>
            <listitem>
              <para>Создать новое представление для <code>Terminal</code>:<programlisting language="xml">&lt;view entity=&quot;sample$Terminal&quot; name=&quot;terminal-edit&quot; extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;meetingPoints&quot; view=&quot;_local&quot;/&gt;
&lt;/view&gt;</programlisting></para>
              <para>И использовать его в представлении <code>Airport</code> вместо <code>_local</code>:<programlisting language="xml">&lt;view entity=&quot;sample$Airport&quot; name=&quot;airport-edit&quot; extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;terminals&quot; view=&quot;terminal-edit&quot;/&gt;
&lt;/view&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>В XML-дескрипторе экрана редактирования аэропорта определить источники данных для экземпляра <code>Airport</code> и вложенных сущностей на всю глубину композиции:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;airportDs&quot;
                class=&quot;com.haulmont.sample.entity.Airport&quot;
                view=&quot;airport-edit&quot;&gt;
        &lt;collectionDatasource id=&quot;terminalsDs&quot; property=&quot;terminals&quot;&gt;
            &lt;collectionDatasource id=&quot;meetingPointsDs&quot; property=&quot;meetingPoints&quot;/&gt;
        &lt;/collectionDatasource&gt;  
    &lt;/datasource&gt;
&lt;/dsContext&gt;</programlisting></para>
              <para>Здесь источник данных <code>meetingPointsDs</code> не связан ни с какими визуальными компонентами, однако он необходим для корректной работы совместного редактирования композиции.</para>
            </listitem>
            <listitem>
              <para>В XML-дескрипторе экрана редактирования терминала в свою очередь определить для коллекции <code>meetingPoints</code> вложенный источник данных и соответствующую таблицу.</para>
            </listitem>
          </orderedlist></para>
        <para>В результате измененные эземпляры <code>MeetingPoint</code>, так же как и экземпляры <code>Terminal</code>, будут сохраняться в базу данных только вместе с экземпляром <code>Airport</code> в одной транзакции.</para>
      </section>
    </section>
    <section id="app_start_recipe">
      <title>Выполнение кода на старте приложения</title>
      <para>Иногда бывает необходимо выполнить некоторый код сразу после старта приложения в момент, когда все механизмы гарантированно работоспособны. Для этого можно воспользоваться слушателем <link linkend="appContext">AppContext.Listener</link>.</para>
      <para>Рассмотрим следующую задачу: в проекте имеется сущность <code>Employee</code> (сотрудник компании), которая связана один-к-одному с платформенной сущностью <code>User</code> (пользователь системы):<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/init_values_recipe_2.png"/>
          </imageobject>
        </mediaobject></para>
      <para>Если атрибут <code>name</code> сущности <code>User</code> изменяется, например через стандартный экран управления пользователями, необходимо, чтобы изменялся также и атрибут <code>name</code> связанной сущности <code>Employee</code>. Это обычная задача для  &quot;денормализованных&quot; данных, и решается она, как правило, с использованием <link linkend="entity_listeners">entity listeners</link>. В данном случае ситуация осложняется тем, что необходимо отслеживать изменения не проектной, а платформенной сущности <code>User</code>, и добавить entity listener с  помощью аннотации <link linkend="listeners_annotation">@Listeners</link>  невозможно. Однако, можно добавить listener динамически через бин <code>EntityListenerManager</code>, и сделать это лучше всего на старте приложения.</para>
      <para>Для этого создадим в модуле <structname>core</structname> приложения бин <code>AppLifecycle</code>, имплементирующий интерфейс <code>AppContext.Listener</code>, и зарегистрируем его  вызовом метода <code>AppContext.addListener()</code> в конструкторе объекта:<programlisting language="java">@ManagedBean(&quot;sample_AppLifecycle&quot;)
public class AppLifecycle implements AppContext.Listener {

    @Inject
    private EntityListenerManager entityListenerManager;

    public AppLifecycle() {
        AppContext.addListener(this);
    }

    @Override
    public void applicationStarted() {
        entityListenerManager.addListener(User.class, UserEntityListener.class);
    }

    @Override
    public void applicationStopped() {
    }

    public static class UserEntityListener implements BeforeUpdateEntityListener&lt;User&gt; {
        @Override
        public void onBeforeUpdate(User user) {
            Persistence persistence = AppBeans.get(Persistence.class);
            if (persistence.getTools().getDirtyFields(user).contains(&quot;name&quot;)) {
                EntityManager em = persistence.getEntityManager();
                TypedQuery&lt;Employee&gt; query = em.createQuery(
                        &quot;select e from sample$Employee e where e.user.id = ?1&quot;, Employee.class);
                query.setParameter(1, user.getId());
                Employee employee = query.getFirstResult();
                if (employee != null) {
                    employee.setName(user.getName());
                }
            }
        }
    }
}</programlisting></para>
      <para>В результате сразу после старта <link linkend="app_tiers">блока</link> Middleware будет вызван метод <code>applicationStarted()</code> данного бина. В этом методе в качестве entity listener сущности <code>User</code> регистрируется внутренний класс <code>UserEntityListener</code>. </para>
      <para>Метод <code>onBeforeUpdate()</code> класс <code>UserEntityListener</code> будет вызываться перед каждым сохранением изменений экземпляров  <code>User</code> в базу данных. В методе проверяется, есть ли атрибут <code>name</code> среди измененных, и если да, загружается связанный экземпляр <code> Employee</code>, и в нем  устанавливается это же значение <code>name</code>.</para>
    </section>
    <section id="images_recipe">
      <title>Загрузка и вывод изображений</title>
      <para>Рассмотрим  задачу загрузки, хранения и отображения фотографий сотрудников:<itemizedlist>
          <listitem>
            <para>Сотрудник представлен сущностью <code>Employee</code>.</para>
          </listitem>
          <listitem>
            <para>Файлы изображений хранятся в <link linkend="file_storage">FileStorage</link>. Сущность <code>Employee</code> содержит ссылку на соответствующий <code>FileDescriptor</code>.</para>
          </listitem>
          <listitem>
            <para>Экран редактирования <code>Employee</code> отображает фотографию, а также дает возможность загрузить, выгрузить и очистить изображение.</para>
          </listitem>
        </itemizedlist></para>
      <para>Класс сущности со ссылкой на файл изображения:<programlisting language="java">@Table(name = &quot;SAMPLE_EMPLOYEE&quot;)
@Entity(name = &quot;sample$Employee&quot;)
public class Employee extends StandardEntity {
...
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = &quot;IMAGE_FILE_ID&quot;)
    protected FileDescriptor imageFile;

    public void setImageFile(FileDescriptor imageFile) {
        this.imageFile = imageFile;
    }

    public FileDescriptor getImageFile() {
        return imageFile;
    }
}</programlisting></para>
      <para>Фрагмент XML-дескриптора экрана редактирования <code>Employee</code>:<programlisting language="xml">&lt;groupBox caption=&quot;Photo&quot; spacing=&quot;true&quot;
          height=&quot;250px&quot; width=&quot;250px&quot; expand=&quot;embeddedImage&quot;&gt;
        &lt;embedded id=&quot;embeddedImage&quot; width=&quot;100%&quot;
                  align=&quot;MIDDLE_CENTER&quot;/&gt;
    &lt;hbox align=&quot;BOTTOM_LEFT&quot;
          spacing=&quot;true&quot;&gt;
        &lt;upload id=&quot;uploadField&quot;/&gt;
        &lt;button id=&quot;downloadImageBtn&quot;
                caption=&quot;Download&quot;
                invoke=&quot;onDownloadImageBtnClick&quot;/&gt;
        &lt;button id=&quot;clearImageBtn&quot;
                caption=&quot;Clear&quot;
                invoke=&quot;onClearImageBtnClick&quot;/&gt;
    &lt;/hbox&gt;
&lt;/groupBox&gt;</programlisting></para>
      <para>Компоненты отображения  и загрузки/выгрузки фотографии заключены внутрь контейнера <link linkend="gui_GroupBoxLayout">groupBox</link>. В верхней его части с помощью компонента <link linkend="gui_Embedded">embedded</link> выводится изображение, а в нижней слева направо расположены компонент <link linkend="gui_FileUploadField">upload</link> для загрузки файла и <link linkend="gui_Button">кнопки</link> выгрузки и очистки изображения. В результате эта часть экрана должна выглядеть следующим образом:<mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/images_recipe.png"/>
          </imageobject>
        </mediaobject></para>
      <para>Теперь рассмотрим <link linkend="abstractEditor">контроллер экрана редактирования</link>.<programlisting language="java" lang="">public class EmployeeEdit extends AbstractEditor&lt;Employee&gt; {

    private Log log = LogFactory.getLog(EmployeeEdit.class);

    @Inject
    private DataSupplier dataSupplier;
    @Inject
    private FileStorageService fileStorageService;
    @Inject
    private FileUploadingAPI fileUploading;
    @Inject
    private ExportDisplay exportDisplay;

    @Inject
    private Embedded embeddedImage;
    @Inject
    private FileUploadField uploadField;
    @Inject
    private Button downloadImageBtn;
    @Inject
    private Button clearImageBtn;
    @Inject
    private Datasource&lt;Employee&gt; employeeDs;

    private static final int IMG_HEIGHT = 190;
    private static final int IMG_WIDTH = 220;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        uploadField.addListener(new FileUploadField.ListenerAdapter() {
            @Override
            public void uploadSucceeded(Event event) {
                FileDescriptor fd = uploadField.getFileDescriptor();
                try {
                    fileUploading.putFileIntoStorage(uploadField.getFileId(), fd);
                } catch (FileStorageException e) {
                    throw new RuntimeException(e);
                }
                getItem().setImageFile(dataSupplier.commit(fd, null));
                displayImage();
            }

            @Override
            public void uploadFailed(Event event) {
                showNotification(&quot;Upload failed&quot;, NotificationType.HUMANIZED);
            }
        });

        employeeDs.addListener(new DsListenerAdapter&lt;Employee&gt;() {
            @Override
            public void valueChanged(Employee source, String property, 
                                     @Nullable Object prevValue, @Nullable Object value) {
                if (&quot;imageFile&quot;.equals(property)) {
                    updateImageButtons(value != null);
                }
            }
        });
    }

    @Override
    protected void postInit() {
        displayImage();
        updateImageButtons(getItem().getImageFile() != null);
    }

    public void onDownloadImageBtnClick(Component source) {
        if (getItem().getImageFile() != null)
            exportDisplay.show(getItem().getImageFile(), ExportFormat.OCTET_STREAM);
    }

    public void onClearImageBtnClick(Component source) {
        getItem().setImageFile(null);
        displayImage();
    }

    private void updateImageButtons(boolean enable) {
        downloadImageBtn.setEnabled(enable);
        clearImageBtn.setEnabled(enable);
    }

    private void displayImage() {
        byte[] bytes = null;
        if (getItem().getImageFile() != null) {
            try {
                bytes = fileStorageService.loadFile(getItem().getImageFile());
            } catch (FileStorageException e) {
                log.error(&quot;Unable to load image file&quot;, e);
                showNotification(&quot;Unable to load image file&quot;, NotificationType.HUMANIZED);
            }
        }
        if (bytes != null) {
            embeddedImage.setSource(getItem().getImageFile().getName(), new ByteArrayInputStream(bytes));
            embeddedImage.setType(Embedded.Type.IMAGE);
            BufferedImage image;
            try {
                image = ImageIO.read(new ByteArrayInputStream(bytes));
                int width = image.getWidth();
                int height = image.getHeight();

                if (((double) height / (double) width) &gt; ((double) IMG_HEIGHT / (double) IMG_WIDTH)) {
                    embeddedImage.setHeight(String.valueOf(IMG_HEIGHT));
                    embeddedImage.setWidth(String.valueOf(width * IMG_HEIGHT / height));
                } else {
                    embeddedImage.setWidth(String.valueOf(IMG_WIDTH));
                    embeddedImage.setHeight(String.valueOf(height * IMG_WIDTH / width));
                }
            } catch (IOException e) {
                log.error(&quot;Unable to resize image&quot;, e);
            }
            // refresh image
            embeddedImage.setVisible(false);
            embeddedImage.setVisible(true);
        } else {
            embeddedImage.setVisible(false);
        }
    }
}</programlisting></para>
      <itemizedlist>
        <listitem>
          <para>В методе <code>init()</code> сначала инициализируется компонент <code>uploadField</code>, предназначенный для загрузки новой фотографии. В случае успешной загрузки из компонента получается экземпляр нового <code>FileDescriptor</code>, и соответствующий файл отправляется из временного хранилища в постоянное вызовом <code>FileUploadingAPI.putFileIntoStorage()</code>. После этого <code>FileDescriptor</code> сохраняется в БД вызовом <link linkend="dataSupplier">DataSupplier.commit()</link>, и сохраненный  экземпляр устанавливается в атрибуте <code>imageFile</code> редактируемой сущности <code>Employee</code>. Затем вызывается метод <code>displayImage()</code> контроллера для отображения загруженной фотографии.</para>
          <para>Далее в методе <code>init()</code> источнику данных, содержащему редактируемый экземпляр <code>Employee</code>, добавляется слушатель для запрещения или разрешения кнопок выгрузки и очистки файла в зависимости от того, загружен файл или нет.</para>
        </listitem>
        <listitem>
          <para>Метод <code>postInit()</code> вызывает отображение файла и обновляет состояние кнопок в зависимости от наличия загруженного файла.</para>
        </listitem>
        <listitem>
          <para>Метод <code>onDownloadImageBtnClick()</code> вызывается при нажатии кнопки <code>downloadImageBtn</code> и выполняет выгрузку файла с помощью интерфейса <link linkend="file_download">ExportDisplay</link>.</para>
        </listitem>
        <listitem>
          <para>Метод <code>onClearImageBtnClick()</code> вызывается при нажатии кнопки <code>clearImageBtn</code> и очищает атрибут <code>imageFile</code> сущности <code>Employee</code>. Удаления файла из хранилища не производится.</para>
        </listitem>
        <listitem>
          <para>Метод <code>displayImage()</code> выгружает файл из хранилища в байтовый массив, устанавливает содержимое компонента <code>embeddedImage</code>, и перерасчитывает его размеры для сохранения пропорций изображения.</para>
          <para>Следует иметь в виду, что выгрузка файлов из хранилища в байтовый массив приемлема только для небольших файлов. Если размер файла непредсказуем, следует использовать только выгрузку через <link linkend="file_download">ExportDisplay</link>, при которой файл передается через потоки ввода-вывода и нигде не оказывается в памяти целиком.</para>
        </listitem>
      </itemizedlist>
    </section>
    <section id="own_component_samples">
      <title>Создание собственных визуальных компонентов</title>
      <para>В данном разделе рассматриваются примеры создания и использования собственных визуальных компонентов.</para>
      <section id="vaadin_addon_sample">
        <title>Пример использования стороннего компонента Vaadin </title>
        <para>Способ подключения сторонних компонентов Vaadin описан в <xref linkend="vaadin_addon"/>.</para>
        <para>Рассмотрим пример использования компонента <application>Stepper</application>, доступного по адресу <ulink url="http://vaadin.com/addon/stepper">http://vaadin.com/addon/stepper</ulink>. Данный компонент позволяет пошагово изменять значение текстового поля с помощью клавиатуры, колесика мыши и встроенных кнопок вверх/вниз.</para>
        <itemizedlist>
          <listitem>
            <para>Предположим, что в проекте имеется сущность <code>Customer</code> со строковым  атрибутом name. В модуле <structname>web</structname> создан экран редактирования <filename>customer-edit.xml</filename> со следующей компоновкой:<programlisting language="xml">&lt;layout expand=&quot;windowActions&quot;
        spacing=&quot;true&quot;&gt;
    &lt;fieldGroup id=&quot;fieldGroup&quot;
                datasource=&quot;customerDs&quot;&gt;
        &lt;column width=&quot;250px&quot;&gt;
            &lt;field id=&quot;name&quot;/&gt;
        &lt;/column&gt;
    &lt;/fieldGroup&gt;
    &lt;iframe id=&quot;windowActions&quot;
            screen=&quot;editWindowActions&quot;/&gt;
&lt;/layout&gt;</programlisting></para>
            <para>Нам необходимо добавить атрибут <code>score</code> типа <code>Integer</code>, и обеспечить его пошаговое редактирование в данном экране.</para>
          </listitem>
          <listitem>
            <para>В CUBA Studio добавляем атрибут <code>score</code> сущности <code>Customer</code>:<programlisting language="java">@Column(name = &quot;SCORE&quot;)
protected Integer score;

public void setScore(Integer score) {
    this.score = score;
}
public Integer getScore() {
    return score;
}</programlisting></para>
            <para>Генерируем скрипты обновления БД и запускаем обновление.</para>
          </listitem>
          <listitem>
            <para>Выполняем команду <guibutton>Create web toolkit module</guibutton>  секции <guilabel>Project properties</guilabel> навигатора Studio.</para>
          </listitem>
          <listitem>
            <para>В <link linkend="build.gradle">build.gradle</link> проекта добавляем зависимость модуля <structname>web</structname> от add-on, содержащего компонент:<programlisting>configure(webModule) {
    ...
    dependencies {
        ...
        compile(&quot;org.vaadin.addons:stepper:2.1.2&quot;)
    }</programlisting></para>
          </listitem>
          <listitem>
            <para>Пересоздаем проектные файлы IDE: меню <guimenu>Create or update IDEA project files</guimenu>.</para>
          </listitem>
          <listitem>
            <para>В файл <filename>AppWidgetSet.gwt.xml</filename> модуля <structname>web-toolkit</structname> проекта подключаем набор виджетов add-on после набора виджетов платформы:<programlisting language="xml">&lt;module&gt;
    &lt;inherits name=&quot;com.haulmont.cuba.web.toolkit.ui.WidgetSet&quot; /&gt;
    
    &lt;inherits name=&quot;org.vaadin.risto.stepper.widgetset.StepperWidgetset&quot; /&gt;

    &lt;set-property name=&quot;user.agent&quot; value=&quot;safari&quot; /&gt;</programlisting></para>
            <para>Для более быстрой сборки виджетов на время разработки можно установить свойство <code>user.agent</code>. В данном примере набор виджетов будет собираться только для браузеров, основанных на WebKit: Chrome, Safari, и т.д.</para>
          </listitem>
          <listitem>
            <para>В XML-дескрипторе экрана редактирования <filename>customer-edit.xml</filename> добавляем кастомное поле <code>score</code> в компонент <link linkend="gui_FieldGroup">fieldGroup</link>:<programlisting language="xml">&lt;fieldGroup id=&quot;fieldGroup&quot;
            datasource=&quot;customerDs&quot;&gt;
    &lt;column width=&quot;250px&quot;&gt;
        &lt;field id=&quot;name&quot;/&gt;
        &lt;field id=&quot;score&quot; custom=&quot;true&quot; caption=&quot;Score&quot;/&gt;
    &lt;/column&gt;
&lt;/fieldGroup&gt;</programlisting></para>
          </listitem>
          <listitem>
            <para>В контроллере экрана редактирования <code>CustomerEdit</code> добавляем следующий код:<programlisting language="java">public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

    @Inject
    private ComponentsFactory componentsFactory;
    @Inject
    private FieldGroup fieldGroup;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        fieldGroup.addCustomField(&quot;score&quot;, new FieldGroup.CustomFieldGenerator() {
            @Override
            public Component generateField(final Datasource datasource, final String propertyId) {
                Component box = componentsFactory.createComponent(BoxLayout.VBOX);
                com.vaadin.ui.Layout layout = WebComponentsHelper.unwrap(box);
                layout.addComponent(stepper);
                stepper.setSizeFull();

                stepper.addValueChangeListener(new Property.ValueChangeListener() {
                    @Override
                    public void valueChange(Property.ValueChangeEvent event) {
                        datasource.getItem().setValue(propertyId, event.getProperty().getValue());
                    }
                });

                return box;
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}</programlisting></para>
            <para>Здесь в поле <code>stepper</code> создается экземпляр компонента, подключенного из add-on. В методе <code>init()</code> производится инициализация кастомного поля <code>score</code>. Через <code>ComponentsFactory</code> создается экземпляр <link linkend="gui_BoxLayout">BoxLayout</link>, затем из него с помощью <link linkend="webComponentsHelper">WebComponentsHelper</link> извлекается ссылка на Vaadin-контейнер, и в этот контейнер добавляется наш новый компонент. <code>BoxLayout</code> возвращается для отображения в кастомном поле.</para>
            <para>Для связи компонента с данными во-первых, в методе <code>postInit()</code> ему устанавливается текущее значение из  редактируемого <code>Customer</code>, а во-вторых, добавляется слушатель на изменение значения, который обновляет соответствующий атрибут сущности при изменении значения пользователем. </para>
          </listitem>
          <listitem>
            <para>Новый  компонент можно использовать и вне <code>FieldGroup</code> в произвольном месте экрана. Для этого в XML-дескрипторе объявим контейнер:<programlisting language="xml">&lt;hbox id=&quot;scoreBox&quot;
      spacing=&quot;true&quot;&gt;
    &lt;label value=&quot;Score&quot;/&gt;
&lt;/hbox&gt;</programlisting></para>
            <para>В контроллере инжектируем контейнер, извлекаем ссылку на Vaadin-контейнер и добавляем в него компонент:<programlisting language="java">public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

    @Inject
    private BoxLayout scoreBox;

    private IntStepper stepper = new IntStepper();

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        com.vaadin.ui.Layout box = WebComponentsHelper.unwrap(scoreBox);
        box.addComponent(stepper);

        stepper.addValueChangeListener(new Property.ValueChangeListener() {
            @Override
            public void valueChange(Property.ValueChangeEvent event) {
                getItem().setValue(&quot;score&quot;, event.getProperty().getValue());
            }
        });
    }

    @Override
    protected void postInit() {
        stepper.setValue(getItem().getScore());
    }
}</programlisting></para>
            <para>Связь с данными выполняется здесь аналогично примеру с <code>FieldGroup</code>.</para>
          </listitem>
          <listitem>
            <para>Для адаптации внешнего вида компонента создадим в проекте расширение темы. Для этого в  <application>Studio</application> выполним команду <guibutton>Create theme extension</guibutton> секции <guilabel>Project properties</guilabel> навигатора. Затем откроем файл <filename>themes/havana/havana-ext.scss</filename> модуля <structname>web</structname>, и добавим в него следующий код:<programlisting language="css">@import &quot;../havana/havana&quot;; 
 
@mixin havana-ext { 
  @include havana; 
 
  /* Basic styles for stepper */
  .v-stepper { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    border: 0; 
 
    /* Use theme fonts */
    font-family: $theme_fonts; 
  } 
 
  /* Basic styles for inner text box */
  .v-stepper input[type=&quot;text&quot;] { 
    /* Use box-sizing: border-box; for all browsers */
    @include box-defaults; 
 
    height: 25px; 
    padding: 1px; 
    outline: 0; 
    margin: 0; 
 
    /* Use border color from theme */
    border: 1px solid $theme_fieldBorderColor; 
  } 
 
  /* Focused styles */
  .v-stepper.v-stepper input[type=&quot;text&quot;]:focus { 
    /* Use focused border color from theme */
    border-color: $theme_fieldFocusedBorderColor; 
    /* hide default focus outline */
    outline: 0; 
  } 
 
  /* Readonly styles */
  .v-readonly.v-stepper input[type=&quot;text&quot;], 
  .v-readonly.v-stepper input[type=&quot;text&quot;]:focus { 
    /* Use readonly border color from theme */
    border-color: $theme_fieldReadonlyBorderColor; 
  } 
}</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="own_gui_component_sample">
        <title>Пример интеграции компонента Vaadin в Generic UI</title>
        <para>В <xref linkend="own_gui_component"/> были рассмотрены принципы интеграции &quot;нативных&quot; компонентов в универсальный UI для того, чтобы их можно было объявлять в XML-дескрипторах экранов  и связывать с данными.</para>
        <para>В <link linkend="vaadin_addon_sample">предыдущем разделе</link> мы подключили в проект сторонний компонент <application>Stepper</application>. Рассмотрим процесс интеграции в универсальный UI класса <code>IntStepper</code>, реализующего пошаговое изменение числового значения типа <code>int</code>.<itemizedlist>
            <listitem>
              <para>Интерфейс компонента в модуле <structname>gui</structname>:<programlisting language="java">package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Field;

public interface IntStepper extends Field {

    String NAME = &quot;intStepper&quot;;

    boolean isManualInputAllowed();
    void setManualInputAllowed(boolean value);

    boolean isMouseWheelEnabled();
    void setMouseWheelEnabled(boolean value);

    int getStepAmount();
    void setStepAmount(int amount);

    int getMaxValue();
    void setMaxValue(int maxValue);

    int getMinValue();
    void setMinValue(int minValue);
}</programlisting></para>
              <para>В качестве базового для нашего компонента выбран интерфейс <code>Field</code>. Это позволяет осуществить связь с данными (data binding),   то есть отображать и редактировать значение некоторого атрибута сущности. </para>
            </listitem>
            <listitem>
              <para>Реализация компонента в модуле <structname>web</structname>:<programlisting language="java">package com.company.myproject.web.components;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.web.gui.components.WebAbstractField;

public class WebIntStepper 
        extends WebAbstractField&lt;org.vaadin.risto.stepper.IntStepper&gt; 
        implements IntStepper {

    public WebIntStepper() {
        component = new org.vaadin.risto.stepper.IntStepper();
    }

    @Override
    public boolean isManualInputAllowed() {
        return component.isManualInputAllowed();
    }
    @Override
    public void setManualInputAllowed(boolean value) {
        component.setManualInputAllowed(value);
    }

    @Override
    public boolean isMouseWheelEnabled() {
        return component.isMouseWheelEnabled();
    }
    @Override
    public void setMouseWheelEnabled(boolean value) {
        component.setMouseWheelEnabled(value);
    }

    @Override
    public int getStepAmount() {
        return component.getStepAmount();
    }
    @Override
    public void setStepAmount(int amount) {
        component.setStepAmount(amount);
    }

    @Override
    public int getMaxValue() {
        return component.getMaxValue();
    }
    @Override
    public void setMaxValue(int maxValue) {
        component.setMaxValue(maxValue);
    }

    @Override
    public int getMinValue() {
        return component.getMinValue();
    }
    @Override
    public void setMinValue(int minValue) {
        component.setMinValue(minValue);
    }
}</programlisting></para>
              <para>В квчестве базового класса выбран <code>WebAbstractField</code>, который реализует логику интерфейса <code>Field</code> по связыванию с <link linkend="datasources">источником данных</link> и другие его методы.</para>
            </listitem>
            <listitem>
              <para>XML-загрузчик компонента в модуле <structname>gui</structname>:<programlisting language="java">package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.IntStepper;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import com.haulmont.cuba.gui.xml.layout.loaders.AbstractFieldLoader;
import org.dom4j.Element;

public class IntStepperLoader extends AbstractFieldLoader {

    public IntStepperLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
        super(context, config, factory);
    }

    @Override
    public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
        IntStepper component = (IntStepper) super.loadComponent(factory, element, parent);

        String manualInput = element.attributeValue(&quot;manualInput&quot;);
        if (manualInput != null) {
            component.setManualInputAllowed(Boolean.valueOf(manualInput));
        }
        String mouseWheel = element.attributeValue(&quot;mouseWheel&quot;);
        if (mouseWheel != null) {
            component.setMouseWheelEnabled(Boolean.valueOf(mouseWheel));
        }
        String stepAmount = element.attributeValue(&quot;stepAmount&quot;);
        if (stepAmount != null) {
            component.setStepAmount(Integer.valueOf(stepAmount));
        }
        String maxValue = element.attributeValue(&quot;maxValue&quot;);
        if (maxValue != null) {
            component.setMaxValue(Integer.valueOf(maxValue));
        }
        String minValue = element.attributeValue(&quot;minValue&quot;);
        if (minValue != null) {
            component.setMinValue(Integer.valueOf(minValue));
        }
        return component;
    }
}</programlisting></para>
              <para>Логика загрузки базовых свойств компонента <code>Field</code> сосредоточена в классе <code>AbstractFieldLoader</code>. Нам достаточно загрузить только специфические свойства <code>IntStepper</code>.</para>
            </listitem>
            <listitem>
              <para>Палитра компонентов проекта в модуле <structname>web</structname>:<programlisting language="java">package com.company.myproject.web;

import com.company.myproject.gui.components.IntStepper;
import com.company.myproject.gui.loaders.IntStepperLoader;
import com.company.myproject.web.components.WebIntStepper;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

    @Override
    public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
        Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; loaders = new HashMap&lt;&gt;();
        loaders.put(IntStepper.NAME, IntStepperLoader.class);
        return loaders;
    }

    @Override
    public Map&lt;String, Class&lt;? extends Component&gt;&gt; getComponents() {
        Map&lt;String, Class&lt;? extends Component&gt;&gt; components = new HashMap&lt;&gt;();
        components.put(IntStepper.NAME, WebIntStepper.class);
        return components;
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Регистрация палитры компонентов в классе <code>App</code> модуля <structname>web</structname>:<programlisting language="java">package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

    static {
        WebUIPaletteManager.registerPalettes(new AppComponentPalette());
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>XSD компонентов проекта в модуле <structname>gui</structname>:<programlisting language="xml">&lt;xs:schema targetNamespace=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
           xmlns:xs=&quot;http://www.w3.org/2001/XMLSchema&quot;
           xmlns=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
           elementFormDefault=&quot;qualified&quot;
           attributeFormDefault=&quot;unqualified&quot;&gt;

    &lt;xs:element name=&quot;intStepper&quot;&gt;
        &lt;xs:complexType&gt;
            &lt;xs:attribute name=&quot;id&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;caption&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;width&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;height&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;datasource&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;property&quot; type=&quot;xs:string&quot;/&gt;
            &lt;xs:attribute name=&quot;manualInput&quot; type=&quot;xs:boolean&quot;/&gt;
            &lt;xs:attribute name=&quot;mouseWheel&quot; type=&quot;xs:boolean&quot;/&gt;
            &lt;xs:attribute name=&quot;stepAmount&quot; type=&quot;xs:int&quot;/&gt;
            &lt;xs:attribute name=&quot;maxValue&quot; type=&quot;xs:int&quot;/&gt;
            &lt;xs:attribute name=&quot;minValue&quot; type=&quot;xs:int&quot;/&gt;
        &lt;/xs:complexType&gt;
    &lt;/xs:element&gt;

&lt;/xs:schema&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Использование компонента в экране внутри произвольного контейнера:<programlisting language="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;
&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.2/window.xsd&quot;
        xmlns:app=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
        caption=&quot;msg://editCaption&quot;
        class=&quot;com.company.myproject.web.customer.CustomerEdit&quot;
        datasource=&quot;customerDs&quot;
        focusComponent=&quot;fieldGroup&quot;
        messagesPack=&quot;com.company.myproject.web.customer&quot;&gt;
    &lt;dsContext&gt;
        &lt;datasource id=&quot;customerDs&quot;
                    class=&quot;com.company.myproject.entity.Customer&quot;
                    view=&quot;_local&quot;/&gt;
    &lt;/dsContext&gt;
    &lt;layout expand=&quot;windowActions&quot;
            spacing=&quot;true&quot;&gt;
        &lt;app:intStepper id=&quot;stepper&quot; datasource=&quot;customerDs&quot; property=&quot;score&quot; caption=&quot;Score&quot;
                        minValue=&quot;1&quot; maxValue=&quot;20&quot;/&gt;
        &lt;iframe id=&quot;windowActions&quot;
                screen=&quot;editWindowActions&quot;/&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
              <para>В данном примере компонент <code>intStepper</code> подсоединен к атрибуту <code>score</code> сущности <code>Customer</code>, экземпляр которой находится в источнике данных <code>customerDs</code>.</para>
            </listitem>
            <listitem>
              <para>Использование компонента в кастомном поле <link linkend="gui_FieldGroup">FieldGroup</link>:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;customerDs&quot;
                class=&quot;com.company.myproject.entity.Customer&quot;
                view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout expand=&quot;windowActions&quot;
        spacing=&quot;true&quot;&gt;
    &lt;fieldGroup id=&quot;fieldGroup&quot;
                datasource=&quot;customerDs&quot;&gt;
        &lt;column width=&quot;250px&quot;&gt;
            &lt;field id=&quot;name&quot;/&gt;
            &lt;field id=&quot;score&quot; custom=&quot;true&quot; caption=&quot;Score&quot;/&gt;
        &lt;/column&gt;
    &lt;/fieldGroup&gt;
...</programlisting><programlisting language="java">@Inject
private ComponentsFactory componentsFactory;
@Inject
private FieldGroup fieldGroup;

@Override
public void init(Map&lt;String, Object&gt; params) {
    fieldGroup.addCustomField(&quot;score&quot;, new FieldGroup.CustomFieldGenerator() {
        @Override
        public Component generateField(final Datasource datasource, final String propertyId) {
            IntStepper stepper = componentsFactory.createComponent(IntStepper.NAME);
            stepper.setDatasource(datasource, propertyId);
            stepper.setWidth(&quot;100%&quot;);
            return stepper;
        }
    });
}</programlisting></para>
            </listitem>
          </itemizedlist> </para>
      </section>
    </section>
  </section>
</chapter>
