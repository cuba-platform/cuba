<?xml version='1.0' encoding='UTF-8'?>
<!-- This document was created with Syntext Serna Free. --><!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY provided SYSTEM "source/section_gui/themes/provided.txt">]>
<chapter id="chapter_framework" lang="ru">
  <title>Устройство платформы</title>
  <para>Данная глава содержит подробное описание архитектуры, компонентов и механизмов платформы.</para>
  <section id="architecture">
    <title>Архитектура</title>
    <para>В данной главе рассмотрена архитектура CUBA-приложений в различных разрезах: по уровням, блокам, модулям, и по используемым базовым проектам.</para>
    <section id="app_tiers">
      <title>Уровни и блоки приложения</title>
      <para>Платформа позволяет строить приложения по классической трехуровневой схеме:  клиентский уровень, средний слой, база данных. <firstterm>Уровень</firstterm> отражает степень &quot;удаленности&quot;  от хранимых данных. </para>
      <para>В дальнейшем речь пойдет в основном о среднем слое и клиентах, поэтому для краткости выражение &quot;все уровни&quot; означает два этих уровня.</para>
      <para>На каждом уровне возможно создание одного или нескольких <firstterm>блоков</firstterm> (units) приложения. Блок представляет собой обособленную исполняемую программу, взаимодействующую с другими блоками приложения. Средства платформы CUBA позволяют создавать блоки в виде веб-приложений и десктопных приложений. Разработка блоков для мобильных платформ на данный момент остается за рамками  CUBA, однако такие блоки, созданные другими средствами, могут быть интегрированы со стандартными блоками приложения. </para>
      <figure>
        <title>Уровни и блоки приложения</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/AppTiers.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <variablelist>
        <varlistentry>
          <term>Middleware</term>
          <listitem>
            <para>Средний слой, содержащий основную бизнес-логику приложения и выполняющий обращения к базе данных. Представляет собой отдельное веб-приложение под управлением стандартного контейнера <glossterm linkend="javaee_web_profile">Java EE Web Profile</glossterm>. См. <xref linkend="middleware"/></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Web Client</term>
          <listitem>
            <para>Основной блок клиентского уровня. Содержит  интерфейс, предназначенный, как правило, для внутренних пользователей организации. Представляет собой отдельное веб-приложение под управлением стандартного контейнера <application>Java EE Web Profile</application>. Реализация <link linkend="gui_framework">пользовательского интерфейса</link> основана на фреймворке <application>Vaadin</application>. См. <xref linkend="gui_framework"/></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Desktop Client</term>
          <listitem>
            <para>Дополнительный блок клиентского уровня. Содержит  интерфейс, предназначенный, как правило, для внутренних пользователей организации. Представляет собой десктопное Java-приложение, реализация пользовательского интерфейса основана на фреймворке <application>Java Swing</application>. См. <xref linkend="gui_framework"/></para>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Web Portal</term>
          <listitem>
            <para>Дополнительный блок клиентского уровня. Содержит интерфейс для внешних пользователей и средства интеграции с мобильными устройствами и сторонними приложениями. Представляет собой отдельное веб-приложение под управлением стандартного контейнера <application>Java EE Web Profile</application>. Реализация пользовательского интерфейса основана на фреймворке <application>Spring MVC</application>. См. <xref linkend="portal"/></para>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>Обязательным блоком любого приложения является средний слой - <structname>Middleware</structname>. Для реализации пользовательского интерфейса, как правило, используется один или несколько клиентских блоков, например, <structname>Web Client</structname> и <structname>Web Portal</structname>. </para>
      <para>Вышеперечисленные блоки являются стандартными, однако в сложном приложении для разделения функциональности можно без труда создать произвольное количество как клиентских блоков, так и блоков среднего слоя.</para>
      <para>Все клиентские блоки  взаимодействуют со средним слоем одинаковым образом посредством протокола <application>HTTP</application>, что позволяет размещать средний слой произвольным образом, в том числе за сетевым экраном. Следует отметить, что при развертывании в простейшем случае среднего слоя и веб-клиента на одном сервере между ними организуется локальное взаимодействие в обход сетевого стека для снижения накладных расходов.</para>
    </section>
    <section id="app_modules">
      <title>Модули приложения</title>
      <para>Модуль – наименьшая структурная единица CUBA-приложения. Представляет собой один модуль проекта приложения и соответствующий ему JAR файл с исполняемым кодом.</para>
      <para>Стандартные модули: <itemizedlist>
          <listitem>
            <para><structname>global</structname> – включает в себя классы сущностей, интерфейсы сервисов и другие общие для всех уровней классы. Используется во всех <link linkend="app_tiers">блоках приложения</link>.</para>
          </listitem>
          <listitem>
            <para><structname>core</structname> – реализация сервисов и всех остальных компонентов среднего слоя. Используется только на <structname>Middleware</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>gui</structname> – общие компоненты <link linkend="gui_framework">универсального пользовательского интерфейса</link>. Используется в <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>web</structname> – реализация универсального пользовательского интерфейса на <application>Vaadin</application>, а также другие специфичные для веб-клиента классы. Используется в блоке <structname>Web Client</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>desktop</structname> – опциональный модуль – реализация универсального пользовательского интерфейса на <application>Java Swing</application>, а также другие специфичные для десктоп-клиента классы. Используется в блоке <structname>Desktop Client</structname>.</para>
          </listitem>
          <listitem>
            <para><structname>portal</structname> – опциональный модуль – реализация веб-портала на <application>Spring MVC</application>.</para>
          </listitem>
        </itemizedlist>  </para>
      <figure>
        <title>Модули приложения</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/AppModules.png"/>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
    <section id="base_projects">
      <title>Базовые проекты</title>
      <para>Функциональность платформы разделена на несколько так называемых <firstterm>базовых проектов</firstterm>: <itemizedlist>
          <listitem>
            <para><structname>cuba</structname> – основной базовый проект, содержит всю функциональность, описанную в данном руководстве, плюс подсистему безопасности (управление пользователями и их доступом к данным)</para>
          </listitem>
          <listitem>
            <para><structname>reports</structname> – подсистема генерации отчетов</para>
          </listitem>
          <listitem>
            <para><structname>workflow</structname> – подсистема управления потоками работ со встроенным визуальным редактором бизнес-процессов</para>
          </listitem>
          <listitem>
            <para><structname>fts</structname> – подсистема полнотекстового поиска</para>
          </listitem>
          <listitem>
            <para><structname>charts</structname> – подсистема вывода диаграмм</para>
          </listitem>
          <listitem>
            <para><structname>ccpayments</structname> – подсистема работы с кредитными картами</para>
          </listitem>
          <listitem>
            <para><structname>bpmn</structname> – механизм исполнения бизнес-процессов по стандарту <application>BPMN 2.0</application></para>
          </listitem>
        </itemizedlist></para>
      <para>Создаваемое на основе платформы приложение может включать в себя функциональность базовых проектов путем объявления зависимостей от их <glossterm linkend="artifact"> артефактов</glossterm>. Зависимость от артефактов <structname>cuba</structname> является обязательной. Опциональные базовые проекты в свою очередь также зависят от <structname>cuba</structname>, и в принципе могут содержать зависимости между собой.</para>
      <figure>
        <title>Зависимости между проектами</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/BaseProjects.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Сплошными линиями изображены обязательные зависимости, пунктирными − опциональные.</para>
    </section>
    <section>
      <title>Состав приложения</title>
      <para>Вышеописанные архитектурные принципы напрямую отражаются на составе собранного приложения. Рассмотрим его на примере простого приложения  <application>sales</application>, которое имеет 2 блока – <structname>Middleware</structname> и <structname>Web Client</structname>; и включает в себя функциональность базовых проектов <structname>cuba</structname> и <structname>reports</structname>.</para>
      <figure>
        <title>Состав простого приложения</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/SampleAppArtifacts.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>На рисунке изображено содержимое некоторых каталогов сервера <application>Tomcat</application> с развернутым в нем приложением <application>sales</application>. </para>
      <para><link linkend="app_tiers">Блок</link><structname> Middleware</structname> реализован веб-приложением <filename>app-core</filename>, блок <structname>Web Client</structname> – веб-приложением <filename>app</filename>. Исполняемый код веб-приложений содержится в каталогах <filename>WEB-INF/lib</filename> в наборе JAR-файлов. Каждый JAR представляет собой результат сборки (<glossterm linkend="artifact">артефакт</glossterm>) одного из <link linkend="app_modules">модулей</link> приложения или <link linkend="base_projects">базового проекта</link>.</para>
      <para>Например, состав JAR-файлов веб-приложения среднего слоя <filename>app-core</filename> определяется тем, что блок <structname>Middleware</structname> состоит из модулей <structname>global</structname> и <structname>core</structname>, и приложение использует базовые проекты <structname>cuba</structname> и <structname>reports</structname> (в данном случае версии 4.0.0). </para>
    </section>
  </section>
  <section id="common_components">
    <title>Общие компоненты</title>
    <para>В данной главе рассмотрены компоненты платформы, общие для всех <link linkend="app_tiers">уровней</link> приложения.</para>
    <section id="data_model">
      <title>Модель данных</title>
      <para>Предметная область моделируется в приложении с помощью взаимосвязанных классов Java, называемых классами сущностей или просто сущностями. </para>
      <para>Сущности подразделяются на две категории:<itemizedlist>
          <listitem>
            <para>персистентные – экземпляры таких сущностей хранятся в таблицах базы данных</para>
          </listitem>
          <listitem>
            <para>неперсистентные – экземпляры существуют только в оперативной памяти</para>
          </listitem>
        </itemizedlist></para>
      <para>Сущности характеризуются своими атрибутами. Атрибут соответствует полю класса и паре методов доступа (get / set) к полю. Чтобы атрибут был  неизменяемым (read only), достаточно не создавать метод set. </para>
      <para>Персистентные сущности могут включать в себя атрибуты, не хранящиеся в БД. В случае неперсистентного атрибута можно не создавать поле класса, ограничившись методами доступа.</para>
      <para>Класс сущности должен удовлетворять следующим требованиям: <itemizedlist>
          <listitem>
            <para>наследоваться от одного из базовых классов, предоставляемых платформой (см. ниже)</para>
          </listitem>
          <listitem>
            <para>иметь набор полей и методов доступа, соответствующих атрибутам сущностей</para>
          </listitem>
          <listitem>
            <para>класс и его поля (или методы доступа при отсутствии для атрибута соответствующего поля)  должны быть определенным образом <link linkend="entity_annotations">аннотированы</link> для работы <glossterm linkend="jpa">JPA</glossterm> (в случае персистентной сущности) и <link linkend="metadata_framework">фреймворка метаданных</link> </para>
          </listitem>
          <listitem>
            <para>для поддержки возможного <link linkend="extension">расширения</link> сущностей поля класса необходимо объявлять с модификатором <code>protected</code>, а не <code>private</code></para>
          </listitem>
        </itemizedlist></para>
      <para>Поддерживаются следующие типы атрибутов сущностей:<itemizedlist>
          <listitem>
            <para><code>java.lang.String</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Boolean</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Integer</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Long</code></para>
          </listitem>
          <listitem>
            <para><code>java.lang.Double</code></para>
          </listitem>
          <listitem>
            <para><code>java.math.BigDecimal</code></para>
          </listitem>
          <listitem>
            <para><code>java.util.Date</code></para>
          </listitem>
          <listitem>
            <para><code>java.sql.Date</code></para>
          </listitem>
          <listitem>
            <para><code>java.sql.Time</code></para>
          </listitem>
          <listitem>
            <para><code>java.util.UUID</code></para>
          </listitem>
          <listitem>
            <para><code>byte[]</code></para>
          </listitem>
          <listitem>
            <para><code>enum</code></para>
          </listitem>
          <listitem>
            <para>сущность</para>
          </listitem>
        </itemizedlist></para>
      <para>Базовые классы сущностей (см. ниже) переопределяют <code>equals()</code> и <code>hashCode()</code> таким образом, что экземпляры сущностей сравниваются по их глобальным уникальным идентификаторам (UUID). То есть экземпляры считаются равными, если равны их идентификаторы. Глобальный уникальный идентификатор присваивается сразу после создания экземпляра в памяти, поэтому новые экземпляры также можно сравнивать и помещать в коллекции.</para>
      <section id="base_entity_classes">
        <title>Базовые классы сущностей</title>
        <para>Рассмотрим базовые классы и интерфейсы сущностей более подробно.</para>
        <figure id="entity_base_classes">
          <title>Базовые классы сущностей</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/EntityClasses.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <itemizedlist>
          <listitem>
            <para><code>Instance</code> – декларирует базовые методы работы с объектами предметной области: <itemizedlist>
                <listitem>
                  <para>Получение глобального уникального идентификатора (UUID) сущности.</para>
                </listitem>
                <listitem>
                  <para>Получение ссылки на мета-класс объекта.</para>
                </listitem>
                <listitem>
                  <para>Генерация имени экземпляра.</para>
                </listitem>
                <listitem>
                  <para>Чтение/установка значений атрибутов по имени.</para>
                </listitem>
                <listitem>
                  <para>Добавление слушателей, получающих уведомления об изменениях атрибутов.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para><code>Entity</code> – дополняет <code>Instance</code> понятием идентификатора сущности (который не обязательно равен UUID), причем <code>Entity</code> не определяет тип идентификатора, оставляя эту возможность наследникам.</para>
          </listitem>
          <listitem>
            <para><code>AbstractInstance</code> – реализует логику работы со слушателями изменения атрибутов.</para>
            <warning>
              <para><code>AbstractInstance</code> хранит слушателей в коллекции <code>WeakReference</code>, т.е. при отсутствии внешних ссылок на добавленного слушателя, он будет немедленно уничтожен сборщиком мусора. Как правило, слушателями изменения атрибутов являются <link linkend="gui_vcl">визуальные компоненты</link> и <link linkend="datasources">источники данных</link> UI, на которые всегда имеются ссылки из других объектов, поэтому проблема исчезновения слушателей не возникает. Однако если слушатель создается прикладным кодом и на него никто не ссылается естественным образом, необходимо кроме добавления в <code>Instance</code> сохранить  его в некотором поле объекта.</para>
            </warning>
          </listitem>
          <listitem>
            <para><code>AbstractNotPersistentEntity</code> – базовый класс неперсистентных сущностей с идентификаторами типа <code>UUID</code>.</para>
          </listitem>
          <listitem>
            <para><code>BaseEntity</code> – базовый интерфейс всех персистентных сущностей, декларирует методы получения информации о том, кто и когда создал экземпляр сущности в базе данных.</para>
          </listitem>
          <listitem>
            <para><code>BaseGenericIdEntity</code> - реализует <code>BaseEntity</code> и добавляет аннотации для поддержки <glossterm linkend="jpa">JPA</glossterm>,  не специфицируя при этом тип идентификатора (то есть первичного ключа) сущности.</para>
          </listitem>
          <listitem>
            <para><code>BaseUuidEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая атрибут-идентификатор с именем <code>id</code>  типа <code>UUID</code>.</para>
          </listitem>
          <listitem>
            <para><code>BaseLongIdEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая атрибут-идентификатор с именем <code>id</code>  типа <code>Long</code>.</para>
          </listitem>
          <listitem>
            <para><code>BaseIntegerIdEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая атрибут-идентификатор с именем <code>id</code>  типа <code>Integer</code>.</para>
          </listitem>
          <listitem>
            <para><code>BaseStringIdEntity</code> - расширяет <code>BaseGenericIdEntity</code>, задавая только  тип идентификатора - <code>String</code>. В конкретном классе сущности, унаследованной от <code>BaseStringIdEntity</code>, необходимо задать атрибут-идентификатор типа <code>String</code> и добавить ему JPA-аннотацию <code>@Id</code>.</para>
          </listitem>
          <listitem>
            <para><code>Versioned</code> – интерфейс сущностей, поддерживающих <glossterm linkend="optimistic_locking">оптимистичную блокировку</glossterm></para>
          </listitem>
          <listitem>
            <para><code>Updatable</code> – интерфейс сущностей, для которых требуется сохранять информацию о том, кто и когда изменял экземпляр в последний раз</para>
          </listitem>
          <listitem>
            <para><code>SoftDelete</code> – интерфейс сущностей, поддерживающих <link linkend="soft_deletion">мягкое удаление</link></para>
          </listitem>
          <listitem>
            <para><code>StandardEntity</code> – наиболее часто используемый базовый класс персистентных сущностей, имеющий идентификатор типа <code>UUID</code> и реализующий интерфейсы <code>Versioned</code>, <code>Updatable</code>, <code>SoftDelete</code>.</para>
          </listitem>
        </itemizedlist>
        <para>При создании классов сущностей рекомендуется выбирать базовый класс по следующим правилам:<itemizedlist>
            <listitem>
              <para>Если сущность не хранится в БД, наследуйте ее от <code>AbstractNotPersistentEntity</code>.</para>
            </listitem>
            <listitem>
              <para>Если сущность встраиваемая - наследуйте ее от <code>EmbeddableEntity</code>.</para>
            </listitem>
            <listitem>
              <para>Если сущность только создается в БД, никогда не изменяется, и мягкое удаление не требуется - наследуйте ее от <code>BaseUuidEntity</code>.</para>
            </listitem>
            <listitem>
              <para>Если сущность ведет себя стандартным образом: изменяется в БД, требует оптимистичной блокировки и мягкого удаления   − наследуйте ее от <code>StandardEntity</code>.</para>
            </listitem>
            <listitem>
              <para>В противном случае наследуйте сущность от <code>BaseUuidEntity</code> и реализуйте в классе тот набор интерфейсов <code>Versioned</code>, <code>Updatable</code>, <code>SoftDelete</code>, который требуется.</para>
            </listitem>
            <listitem>
              <para>Иногда для некоторых сущностей желательно использовать целочисленные или строковые первичные ключи. В этом случае вместо <code>BaseUuidEntity</code> унаследуйте класс сущности от <code>BaseLongIdEntity</code>, <code>BaseIntegerIdEntity</code>, или <code>BaseStringIdEntity</code>.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="entity_annotations">
        <title>Аннотации сущностей</title>
        <para>В данном разделе описаны все поддерживаемые платформой аннотации классов и атрибутов сущностей. </para>
        <para>Аннотации пакета <code>javax.persistence</code> обеспечивают работу <glossterm linkend="jpa">JPA</glossterm>, аннотации пакетов <code>com.haulmont.*</code> предназначены для управления <link linkend="metadata_framework">метаданными</link> и другими механизмами платформы. </para>
        <para>Если для аннотации указано только простое имя класса, подразумевается что это класс платформы, расположенный в одном  из пакетов <code>com.haulmont.*</code></para>
        <section id="entity_class_annotations">
          <title>Аннотации класса</title>
          <variablelist>
            <varlistentry id="entity_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Entity.html">@javax.persistence.Entity</ulink>
                </code>
              </term>
              <listitem>
                <para>Объявляет класс сущностью модели данных. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя сущности, обязательно должно начинаться с префикса, отделенного знаком <literal>$</literal>. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен. </para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@Entity(name = &quot;sales$Customer&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/MappedSuperclass.html">@javax.persistence.MappedSuperclass</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет, что данный класс является предком некоторых сущностей, и его атрибуты должны быть использованы в составе сущностей-наследников. Такой класс не сопоставляется никакой отдельной таблице БД.</para>
              </listitem>
            </varlistentry>
            <varlistentry id="table_annotation">
              <term>
                <code>@<ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Table.html">javax.persistence.Table</ulink></code>
              </term>
              <listitem>
                <para>Определяет таблицу базы данных для данной сущности. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя таблицы</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@Table(name = &quot;SALES_CUSTOMER&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="embeddable_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Embeddable.html">@javax.persistence.Embeddable</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет встраиваемую сущность, экземпляры которой хранятся вместе с владеющей сущностью в той же таблице. </para>
                <para>Для задания имени сущности требуется применение аннотации <link linkend="metaclass_annotation">
                    <code>@MetaClass</code>
                  </link>.</para>
              </listitem>
            </varlistentry>
            <varlistentry id="inheritance_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Inheritance.html">@javax.persistence.Inheritance</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет стратегию наследования для иерархии классов сущностей. Данная аннотация должна быть помещена на корневом классе иерархии. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>strategy</code> - стратегия, по умолчанию <code>SINGLE_TABLE</code></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@<ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorColumn.html">javax.persistence.DiscriminatorColumn</ulink></code>
              </term>
              <listitem>
                <para>Используется для определения колонки БД, отвечающей за различение типов сущностей в случае стратегий наследования <code>SINGLE_TABLE</code> и <code>JOINED</code>. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки-дискриминатора</para>
                    </listitem>
                    <listitem>
                      <para><code>discriminatorType</code> - тип данных колонки-дискриминатора</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@DiscriminatorColumn(name = &quot;TYPE&quot;, discriminatorType = DiscriminatorType.INTEGER)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/DiscriminatorValue.html">@javax.persistence.DiscriminatorValue</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет значение колонки-дискриминатора для данной сущности. Эта аннотация должна быть помещена на конкретном классе сущности. </para>
                <para>Пример:<programlisting language="java">@DiscriminatorValue(&quot;0&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/PrimaryKeyJoinColumn.html">@javax.persistence.PrimaryKeyJoinColumn</ulink>
                </code>
              </term>
              <listitem>
                <para>Используется в случае стратегии наследования <code>JOINED</code> для указания колонки внешнего ключа данной сущности, ссылающегося на первичный ключ сущности-предка.  </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки внешнего ключа данной сущности</para>
                    </listitem>
                    <listitem>
                      <para><code>referencedColumnName</code> - имя колонки первичного ключа сущности предка</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@PrimaryKeyJoinColumn(name = &quot;CARD_ID&quot;, referencedColumnName = &quot;ID&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="namePattern">
              <term>
                <code>@NamePattern</code>
              </term>
              <listitem>
                <para>Определяет способ получения имени экземпляра, возвращаемого методом <code>Instance.getInstanceName()</code>.</para>
                <para>Значением аннотации должна быть строка вида <literal>{0}|{1}</literal>, где <itemizedlist>
                    <listitem>
                      <para><literal>{0}</literal> - строка форматирования по правилам  <code>String.format()</code>, или имя метода данного объекта с префиксом <literal>#</literal>. Метод должен возвращать <code>String</code> и не иметь параметров.</para>
                    </listitem>
                    <listitem>
                      <para><literal>{1}</literal> - разделенный запятыми список имен полей класса, соответствующий формату <literal>{0}</literal>. В случае использования в <literal>{0}</literal> метода список полей все равно необходим, так как по нему формируется <link linkend="views">представление</link> <literal>_minimal</literal>.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Примеры:<programlisting language="java">@NamePattern(&quot;%s|name&quot;)</programlisting><programlisting language="java">@NamePattern(&quot;#getCaption|login,name&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="listeners_annotation">
              <term>
                <code>@Listeners</code>
              </term>
              <listitem>
                <para>Определяет список слушателей, предназначенных для реакции на события жизненного цикла экземпляров сущности на <link linkend="app_tiers">уровне</link><structname> Middleware</structname>. </para>
                <para>Значением аннотации должна быть строка или массив строк с именами классов слушателей - см. <xref linkend="entity_listeners"/></para>
                <para>Строки используются здесь вместо ссылок на классы потому, что классы слушателей находятся только на уровне <structname>Middleware</structname> и не доступны клиентскому коду, в то время как классы самих сущностей используются на всех уровнях.</para>
                <para>Примеры:<programlisting language="java">@Listeners(&quot;com.haulmont.cuba.security.listener.UserEntityListener&quot;)</programlisting><programlisting language="java">@Listeners({&quot;com.abc.sales.entity.FooListener&quot;,&quot;com.abc.sales.entity.BarListener&quot;})</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="metaclass_annotation">
              <term>
                <code>@MetaClass</code>
              </term>
              <listitem>
                <para>Используется для объявления неперсистентной или <link linkend="embeddable_annotation">встраиваемой</link> сущности (т.е. когда аннотация <code>@javax.persistence.Entity</code> не применима)  </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя сущности, обязательно должно начинаться с префикса, отделенного знаком <literal>$</literal>. Желательно использовать в качестве префикса короткое имя проекта для формирования отдельного пространства имен.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@MetaClass(name = &quot;sys$LockInfo&quot;)</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@SystemLevel</code>
              </term>
              <listitem>
                <para>Указывает, что данная сущность является системной и не должна быть доступна для выбора пользователем в различных списках сущностей, например, как тип параметра универсального фильтра или тип <link linkend="runtime_properties">динамического атрибута</link>.  </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@EnableRestore</code>
              </term>
              <listitem>
                <para>Указывает, что экземпляры данной сущности доступны для восстановления после <link linkend="soft_deletion">мягкого удаления</link> в специальном экране <literal>core$Entity.restore</literal>. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@TrackEditScreenHistory</code>
              </term>
              <listitem>
                <para>Указывает, что для данной сущности будет запоминаться история открытия экранов редактирования (<literal>{имя_сущности}.edit</literal>) с возможностью отображения в специальном экране <literal>sec$ScreenHistory.browse</literal>.  </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@Extends</code>
              </term>
              <listitem>
                <para>Указывает, что  данная сущность является расширением и должна повсеместно использоваться вместо базовой. См. <xref linkend="extension"/>  </para>
              </listitem>
            </varlistentry>
            <varlistentry id="postConstruct_entity_annotation">
              <term>
                <code>@PostConstruct</code>
              </term>
              <listitem>
                <para>Данная аннотация может быть указана для метода класса. Такой метод будет вызван сразу после создания экземпляра сущности через <link linkend="metadata">Metadata.create()</link>. Это удобно, если для инициализации экземпляра сущности требуется вызов каких-либо <link linkend="managed_beans">бинов</link>. Пример см. в <xref linkend="init_values_in_class"/>.</para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section id="entity_attr_annotations">
          <title>Аннотации атрибутов</title>
          <para>Аннотации атрибутов устанавливаются на соответствующие поля класса, за одним исключением: если требуется объявить неизменяемый (read only) неперсистентный атрибут <literal>foo</literal>, то достаточно создать метод доступа <code>getFoo()</code> и поместить на этот метод аннотацию <code>@MetaProperty</code>.</para>
          <variablelist>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Transient.html">@javax.persistence.Transient</ulink>
                </code>
              </term>
              <listitem>
                <para>Указывает, что данное поле не хранится в БД, т.е. является неперсистентным. </para>
                <para>Поля поддерживаемых <glossterm linkend="jpa">JPA</glossterm> типов (см. <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html">http://docs.oracle.com/javaee/5/api/javax/persistence/Basic.html</ulink>) <emphasis>по умолчанию являются персистентными</emphasis>, поэтому аннотация <code>@Transient</code> обязательна для объявления неперсистентного атрибута такого типа. </para>
                <para>Для включения <code>@Transient</code> атрибута в метаданные, необходимо также указать аннотацию <code>
                    <link linkend="metaProperty_annotation">@MetaProperty</link>
                  </code>. </para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>@org.apache.openjpa.persistence.Persistent</code>
              </term>
              <listitem>
                <para>Указывает, что данное поле хранится в БД, т.е. является персистентным.</para>
                <para>Данная аннотация требуется только для нестандартного для <glossterm linkend="jpa">JPA</glossterm> типа поля, платформа на данный момент поддерживает  один такой тип - <code>java.util.UUID</code>. Таким образом, <code>@Persistent</code> требуется только в одном случае - при объявлении персистентного поля типа <code>UUID</code>.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Column.html">@javax.persistence.Column</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет колонку БД, в которой будут храниться значения данного атрибута. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки</para>
                    </listitem>
                    <listitem>
                      <para><code>length</code> - (необязательный параметр, по умолчанию <literal>255</literal>) - длина колонки. Используется также при формировании <link linkend="metadata_framework">метаданных</link> и, в конечном счете, может ограничивать максимальную длину вводимого текста в визуальных компонентах, работающих с данным атрибутом. Для отмены ограничения по длине атрибуту необходимо добавить аннотацию <link linkend="lob_annotation">@Lob</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>nullable</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>nullable = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие значения поля при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Id.html">@javax.persistence.Id</ulink>
                </code>
              </term>
              <listitem>
                <para>Указывает, что  данный атрибут является первичным ключом сущности. Обычно эта аннотация присутствует на поле базового класса, такого как <link linkend="entity_base_classes">BaseUuidEntity</link>. Использовать эту аннотацию в конкретном классе сущности необходимо только при наследовании от базового класса <code>BaseStringIdEntity</code> (то есть при создании сущности со строковым первичным ключом).</para>
              </listitem>
            </varlistentry>
            <varlistentry id="manyToOne">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToOne.html">@javax.persistence.ManyToOne</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-ссылку на сущность с типом ассоциации много-к-одному. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>fetch</code> - (по умолчанию <code>EAGER</code>) параметр, определяющий, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>optional</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>optional = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Например, несколько экземпляров <code>Order</code> (заказов) ссылаются на один экземпляр <code>Customer</code> (покупателя), в этом случае класс <code>Order</code> должен содержать следующее объявление:<programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
protected Customer customer;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OneToMany.html">@javax.persistence.OneToMany</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации один-ко-многим. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию </para>
                    </listitem>
                    <listitem>
                      <para><code>targetEntity</code> - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием <application>Java generics</application>. </para>
                    </listitem>
                    <listitem>
                      <para><code>fetch</code> - (необязательный параметр, по умолчанию <code>LAZY</code>) - определяет, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>cascade</code> - (необязательный параметр, по умолчанию <code>{}</code>) - каскадирование операций определяет, какие операции над сущностью должны быть применены к ассоциированным сущностям. Каскадирование на данном уровне не рекомендуется использовать.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Например, несколько экземпляров <code>Item</code> (пунктов заказа) ссылаются на один экземпляр <code>Order</code> (заказ) с помощью <code>@ManyToOne</code> поля <code>Item.order</code>, в этом случае класс <code>Order</code> может содержать коллекцию экземпляров <code>Item</code>:<programlisting language="java">@OneToMany(mappedBy = &quot;order&quot;)
protected Set&lt;Item&gt; items;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OneToOne.html">@javax.persistence.OneToOne</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-ссылку на сущность с типом ассоциации один-к-одному. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>fetch</code> - (по умолчанию <code>EAGER</code>) параметр, определяющий, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать ассоциированную сущность. Данный параметр всегда должен быть установлен в значение <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию. Требуется устанавливать только на ведомой стороне ассоциации. </para>
                    </listitem>
                    <listitem>
                      <para><code>optional</code> - (необязательный параметр, по умолчанию <code>true</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>optional = false</code> <glossterm linkend="jpa">JPA</glossterm> контролирует наличие ссылки при сохранении, кроме того, визуальные компоненты, работающих с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример ведущей стороны ассоциации, класс <code>Driver</code>:<programlisting language="java">@OneToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CALLSIGN_ID&quot;)
protected DriverCallsign callsign;</programlisting></para>
                <para>Пример ведомой стороны ассоциации, класс <code>DriverCallsign</code>:<programlisting language="java">@OneToOne(fetch = FetchType.LAZY, mappedBy = &quot;callsign&quot;)
protected Driver driver;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/ManyToMany.html">@javax.persistence.ManyToMany</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут-коллекцию ссылок на сущность с типом ассоциации много-ко-многим.</para>
                <para>Ассоциация много-ко-многим всегда имеет ведущую сторону и может иметь обратную сторону - ведомую. На ведущей стороне указывается дополнительная аннотация <code>@JoinTable</code>, на ведомой стороне - параметр <code>mappedBy</code>.</para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>mappedBy</code> - поле связанной сущности, определяющее ассоциацию с ведущей стороны. Необходимо указывать только на ведомой стороне.</para>
                    </listitem>
                    <listitem>
                      <para><code>targetEntity</code> - тип связанной сущности. Необязательный параметр, если коллекция объявлена с использованием <application>Java generics</application>. </para>
                    </listitem>
                    <listitem>
                      <para><code>fetch</code> - (необязательный параметр, по умолчанию <code>LAZY</code>) - определяет, будет ли JPA <glossterm linkend="eager_fetching">жадно</glossterm> загружать коллекцию связанных сущностей. Необходимо всегда оставлять значение по умолчанию <code>LAZY</code>, так как в CUBA-приложении политика загрузки связей определяется динамически на основе механизма <link linkend="views">представлений</link>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/JoinColumn.html">@javax.persistence.JoinColumn</ulink>
                </code>
              </term>
              <listitem>
                <para>Используется для указания колонки БД, определяющей ассоциацию между сущностями.  </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя колонки</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
protected Customer customer;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/JoinTable.html">@javax.persistence.JoinTable</ulink>
                </code>
              </term>
              <listitem>
                <para>Используется для указания таблицы связи на ведущей стороне <code>@ManyToMany</code> ассоциации. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>name</code> - имя таблицы связи</para>
                    </listitem>
                    <listitem>
                      <para><code>joinColumns</code> - элемент <code>@JoinColumn</code>, определяющий колонку таблицы связей, соответствующую первичному ключу ведущей стороны ассоциации (т.е. содержащей аннотацию <code>@JoinTable</code>)</para>
                    </listitem>
                    <listitem>
                      <para><code>inverseJoinColumns</code> - элемент <code>@JoinColumn</code>, определяющий колонку таблицы связей, соответствующую первичному ключу ведомой стороны ассоциации</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример атрибута <code>customers</code> класса <code>Group</code>, являющегося ведущей стороной ассоциации:<programlisting language="java">@ManyToMany
@JoinTable(name = &quot;SALES_CUSTOMER_GROUP_LINK&quot;,
    joinColumns = @JoinColumn(name = &quot;GROUP_ID&quot;),
    inverseJoinColumns = @JoinColumn(name = &quot;CUSTOMER_ID&quot;))
protected Set&lt;Customer&gt; customers;</programlisting></para>
                <para>Пример атрибута <code>groups</code> класса <code>Customer</code>, являющегося ведомой стороной этой же ассоциации:<programlisting language="java">@ManyToMany(mappedBy = &quot;customers&quot;)
protected Set&lt;Group&gt; groups;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/OrderBy.html">@javax.persistence.OrderBy</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет порядок элементов в атрибуте-коллекции на момент извлечения из базы данных. Данную аннотацию необходимо задавать для упорядоченных коллекций, таких как <code>List</code> или <code>LinkedHashSet</code> для получения предсказуемого порядка следования элементов.</para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>value</code> - строка, определяющая порядок, в формате:<programlisting>orderby_list::= orderby_item [,orderby_item]*
orderby_item::= property_or_field_name [ASC | DESC]</programlisting></para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@OneToMany(mappedBy = &quot;user&quot;)
@OrderBy(&quot;createTs&quot;)
protected List&lt;UserRole&gt; userRoles;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Embedded.html">@javax.persistence.Embedded</ulink>
                </code>
              </term>
              <listitem>
                <para>Определяет атрибут типа встраиваемой сущности, в свою очередь аннотированной <code>@Embeddable</code>. </para>
                <para>Пример:<programlisting language="java">@Embedded
protected Address address;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Temporal.html">@javax.persistence.Temporal</ulink>
                </code>
              </term>
              <listitem>
                <para>Для атрибута типа <code>java.util.Date</code> уточняет тип хранимого значения: дата, время или дата+время. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>value</code> - тип хранимого значения: <code>DATE</code>, <code>TIME</code>, <code> TIMESTAMP</code></para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример:<programlisting language="java">@Column(name = &quot;START_DATE&quot;)
@Temporal(TemporalType.DATE)
protected Date startDate;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Version.html">@javax.persistence.Version</ulink>
                </code>
              </term>
              <listitem>
                <para>Указывает, что данное поле хранит версию для поддержки <glossterm linkend="optimistic_locking">оптимистичной блокировки</glossterm> сущностей. </para>
                <para>Применение такого поля необходимо при реализации классом сущности интерфейса <code>Versioned</code> (базовый класс <code>StandardEntity</code> уже содержит такое поле).</para>
                <para>Пример:<programlisting language="java">@Version
@Column(name = &quot;VERSION&quot;)
private Integer version;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="lob_annotation">
              <term>
                <code>
                  <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Lob.html">@javax.persistence.Lob</ulink>
                </code>
              </term>
              <listitem>
                <para>Указывает, что данный атрибут не имеет ограничений длины. Применяется совместно с аннотацией <code>@Column</code>. Если <code>@Lob</code>  указан, то длина, заданная в <code>@Column</code> явно или по умолчанию, игнорируется. </para>
                <para>Пример:<programlisting language="java">@Column(name = &quot;DESCRIPTION&quot;)
@Lob
private String description;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="metaProperty_annotation">
              <term>
                <code>@MetaProperty</code>
              </term>
              <listitem>
                <para>Указывает, что данный атрибут должен быть включен в <link linkend="metadata_framework">метаданные</link>. Данная аннотация может быть установлена как на поле класса, так и на метод доступа, в случае отсутствия соответствующего атрибуту поля.</para>
                <para>Данная аннотация не обязательна для полей, снабженных следующими аннотациями пакета <code>javax.persistence</code>: <code>@Column</code>, <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>, <code>@Embedded</code>. Такие поля отражаются в метаданных автоматически. Поэтому <code>@MetaProperty</code> в основном применяется для определения неперсистентных атрибутов сущностей. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>mandatory</code> - (необязательный параметр, по умолчанию <code>false</code>) - может ли атрибут содержать  <code>null</code>. При указании <code>mandatory = true</code> визуальные компоненты, работающие с данным атрибутом, могут сигнализировать пользователю о необходимости ввода значения.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример использования для поля:<programlisting language="java">@Transient
@MetaProperty
protected String token;</programlisting></para>
                <para>Пример использования для метода:<programlisting language="java">@MetaProperty
public String getLocValue() {
    if (!StringUtils.isBlank(messagesPack)) {
        return AppBeans.get(Messsages.class).getMessage(messagesPack, value);
    } else {
        return value;
    }
}</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="onDelete_annotation">
              <term>
                <code>@OnDelete</code>
              </term>
              <listitem>
                <para>Определяет политику обработки связи в случае мягкого удаления сущности, содержащей данный атрибут. См. <xref linkend="soft_deletion"/></para>
                <para>Пример:<programlisting language="java">@OneToMany(mappedBy = &quot;group&quot;)
@OnDelete(DeletePolicy.CASCADE)
private Set&lt;Constraint&gt; constraints;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="onDeleteInverse_annotation">
              <term>
                <code>@OnDeleteInverse</code>
              </term>
              <listitem>
                <para>Определяет политику обработки связи в случае мягкого удаления сущности с обратной стороны ассоциации. См. <xref linkend="soft_deletion"/> </para>
                <para>Пример:<programlisting language="java">@ManyToOne
@JoinColumn(name = &quot;DRIVER_ID&quot;)
@OnDeleteInverse(DeletePolicy.DENY)
private Driver driver;</programlisting></para>
              </listitem>
            </varlistentry>
            <varlistentry id="composition_annotation">
              <term>
                <code>@Composition</code>
              </term>
              <listitem>
                <para>Указывает на то, что связь является композицией - более тесным вариантом ассоциации. Это означает, что связанная сущность имеет смысл только как часть владеющей сущности, т.е. создается и удаляется вместе с ней. </para>
                <para>Например, список пунктов в заказе (класс <code>Order</code> содержит коллекцию экземпляров <code>Item</code>):<programlisting language="java">@OneToMany(mappedBy = &quot;order&quot;)
@Composition
protected List&lt;Item&gt; items;</programlisting></para>
                <para>Указание для связи аннотации <code>@Composition</code> позволяет организовать в <link linkend="screen_edit">экранах редактирования</link> специальный режим коммита источников данных, при котором изменения экземпляров детализирующей сущности сохраняются в базе данных только при коммите основной сущности. Подробнее см. <xref linkend="composition_recipe"/>.</para>
              </listitem>
            </varlistentry>
            <varlistentry id="localizedValue_annotation">
              <term>
                <code>@LocalizedValue</code>
              </term>
              <listitem>
                <para>Служит для описания способа получения локализованного значения некоторого изменяющегося атрибута, которое возвращает метод <code><link linkend="messageTools">MessageTools</link>.getLocValue()</code>. </para>
                <para>Параметры:<itemizedlist>
                    <listitem>
                      <para><code>messagePack</code> - явное указание пакета, из которого будет взято локализованное сообщение, например, <code>com.haulmont.cuba.core.entity</code></para>
                    </listitem>
                    <listitem>
                      <para><code>messagePackExpr</code> - выражение в терминах пути к атрибуту, хранящему имя пакета, из которого будет взято локализованное сообщение, например <code>proc.messagesPack</code>. Путь начинается с атрибута текущей сущности. </para>
                    </listitem>
                  </itemizedlist></para>
                <para>Пример аннотации, означающей, что локализованное значение атрибута <code>state</code> будет взято из пакета, имя которого хранится в атрибуте <code>messagesPack</code> связанной сущности <code>proc</code>:<programlisting language="java">@Column(name = &quot;STATE&quot;)
@LocalizedValue(messagePackExpr = &quot;proc.messagesPack&quot;)
protected String state;

@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;PROC_ID&quot;)
protected Proc proc;</programlisting></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
      </section>
      <section id="enum_attributes">
        <title>Атрибуты типа enum</title>
        <para>В стандартном варианте использования <glossterm linkend="jpa">JPA</glossterm> для атрибутов типа <code>enum</code> в базе данных хранится целое число, получаемое методом <code>ordinal()</code> этого перечисления. Такой подход может привести к следующим проблемам при эксплуатации и развитии системы:<itemizedlist>
            <listitem>
              <para>при появлении в БД значения, не равного ни одному <code>ordinal</code> значению перечисления, экземпляр сущности нельзя загрузить вообще;</para>
            </listitem>
            <listitem>
              <para>невозможно ввести новое значение между имеющимися, что актуально при использовании сортировки по значению перечисления (order by).</para>
            </listitem>
          </itemizedlist></para>
        <para>Чтобы решить эти проблемы, в подходе <productname>CUBA</productname> предлагается отвязать значение, хранимое в БД, от <code>ordinal</code> перечисления. Для этого необходимо поле класса сущности объявлять с типом, хранимым в БД (<code>Integer</code> или <code>String</code>), а методы доступа (getter / setter) создавать для типа самого перечисления.</para>
        <para>Например:<programlisting language="java">@Entity(name = &quot;sales$Customer&quot;)
@Table(name = &quot;SALES_CUSTOMER&quot;)
public class Customer extends StandardEntity {

    @Column(name = &quot;GRADE&quot;)
    protected Integer grade;

    public CustomerGrade getGrade() {
        return grade == null ? null : CustomerGrade.fromId(grade);
    }

    public void setGrade(CustomerGrade grade) {
        this.grade = grade == null ? null : grade.getId();
    }
...
}  </programlisting></para>
        <para>При этом сам класс перечисления может выглядеть следующим образом:<programlisting language="java">public enum CustomerGrade implements EnumClass&lt;Integer&gt; {

    PREMIUM(10),
    HIGH(20),
    MEDIUM(30);

    private Integer id;

    CustomerGrade(Integer id) {
        this.id = id;
    }

    @Override
    public Integer getId() {
        return id;
    }

    public static CustomerGrade fromId(Integer id) {
        for (CustomerGrade grade : CustomerGrade.values()) {
            if (grade.getId().equals(id))
                return grade;
        }
        return null;
    }
}</programlisting></para>
        <para>Для правильного отражения в <link linkend="metadata_framework">метаданных</link> класс перечисления, используемый в качестве типа атрибута сущности, должен реализовывать интерфейс <code>EnumClass</code>.</para>
        <para>Как видно из примеров, для атрибута <code>grade</code> в БД хранится значение типа <code>Integer</code>, задаваемое полем <code>id</code> перечисления <code>CustomerGrade</code>, а конкретно <literal>10</literal>, <literal>20</literal> или <literal>30</literal>. В то же время прикладной код и метаданные работают с самим типом <code>CustomerGrade</code> через методы доступа, которые и осуществляют конвертацию.</para>
        <para>При наличии в поле БД значения, не соответствующего ни одному значению перечисления, метод <code>getGrade()</code> просто вернет <code>null</code>. Для ввода нового значения, например, <code>HIGHER</code>, между <code>HIGH</code> и <code>PREMIUM</code>, достаточно добавить это значение в перечисление с идентификатором <literal>15</literal>, при этом сортировка по полю <code>Customer.grade</code> останется верной.</para>
        <para>Значениям перечисления могут быть сопоставлены <link linkend="enum_localization">локализованные названия</link> для отображения в пользовательском интерфейсе приложения.</para>
      </section>
      <section id="soft_deletion">
        <title>Мягкое удаление</title>
        <para>Платформа CUBA поддерживает режим &quot;мягкого удаления&quot; данных - когда вместо удаления записей из базы данных они только помечаются определенным образом и становятся недоступными для обычного использования. В дальнейшем такие записи можно либо совсем удалить из БД с помощью отдельной регламентной процедуры, либо восстановить.</para>
        <para>Механизм мягкого удаления является &quot;прозрачным&quot; для прикладного программиста - достаточно убедиться, что класс сущности реализует интерфейс <code>SoftDelete</code>, и платформа сама нужным образом будет  модифицировать запросы и операции с данными.</para>
        <para>Режим мягкого удаления имеет следующие преимущества:<itemizedlist>
            <listitem>
              <para>значительно снижается риск потери данных вследствие неверных действий пользователей</para>
            </listitem>
            <listitem>
              <para>позволяет быстро сделать некоторые  записи недоступными, даже если на них имеются ссылки. </para>
              <para>Возьмем для примера  модель данных Заказы - Покупатели. Допустим, на некоторого покупателя оформлено несколько заказов, однако нам нужно сделать его недоступным для  дальнейшей работы. Традиционным &quot;жестким&quot; удалением сделать это невозможно, так как для удаления покупателя нам нужно либо удалить все его заказы, либо обнулить в этих заказах ссылки на него (т.е. потерять информацию). При мягком удалении покупателя он становится недоступным для поиска и изменения, однако при просмотре заказов пользователь видит на экране название покупателя, так как при загрузке связей признак удаления намеренно игнорируется.</para>
              <para>Описанное поведение является стандартным, но может быть модифицировано с помощью <link linkend="delete_policy">политики обработки связей</link> при удалении.</para>
            </listitem>
          </itemizedlist></para>
        <para>Отрицательной стороной мягкого удаления является увеличение объема базы данных и потенциальная необходимость дополнительных процедур ее очистки.</para>
        <section>
          <title>Использование</title>
          <para>Для того чтобы экземпляры сущности удалялись мягко, класс сущности должен реализовывать интерфейс <code>SoftDelete</code>,  а соответствующая таблица БД должна содержать колонки: <itemizedlist>
              <listitem>
                <para><database>DELETE_TS</database> - когда удалена запись</para>
              </listitem>
              <listitem>
                <para><database>DELETED_BY</database> - логин пользователя, который удалил запись</para>
              </listitem>
            </itemizedlist></para>
          <para>Поведение системы по умолчанию - сущности, реализующие <code>SoftDelete</code>, удаляются мягко, удаленные сущности не возвращаются запросами и поиском по идентификатору. При необходимости такое поведение можно динамически отключить следующими способами:<itemizedlist>
              <listitem>
                <para>для текущего экземпляра <link linkend="entityManager">EntityManager</link> - вызовом <code>setSoftDeletion(false)</code></para>
              </listitem>
              <listitem>
                <para>при запросе данных через <code>
                    <link linkend="dataService">DataService</link>
                  </code> или <code>
                    <link linkend="dataService">DataWorker</link>
                  </code> - вызовом у передаваемого объекта <code>LoadContext</code> метода <code>setSoftDeletion(false)</code></para>
              </listitem>
              <listitem>
                <para>на уровне <link linkend="datasources">источников данных</link> - используя метод <code>CollectionDatasource.setSoftDeletion(false)</code> или атрибут <literal>softDeletion=&quot;false&quot;</literal> элемента <sgmltag>collectionDatasource</sgmltag> в <link linkend="screen_xml">XML-дескрипторе</link> экрана.</para>
              </listitem>
            </itemizedlist></para>
          <para>В режиме мягкого удаления платформа автоматически отфильтровывает  удаленные экземпляры при загрузке по идентификатору и по <glossterm linkend="jpql">JPQL-запросу</glossterm>, а также удаленные элементы связанных сущностей в атрибутах-коллекциях. Однако связанные сущности в единичных атрибутах загружаются независимо от того, удален связанный экземпляр или нет.</para>
        </section>
        <section id="delete_policy">
          <title>Политика обработки связей</title>
          <para>Платформа предоставляет средство обработки связей при удалении сущностей, во многом аналогичное правилам <database>ON DELETE</database> внешних ключей в базе данных. Это средство работает на <link linkend="app_tiers">уровне</link><structname> Middleware</structname> и использует аннотации <link linkend="onDelete_annotation">@OnDelete</link>, <link linkend="onDeleteInverse_annotation">@OnDeleteInverse</link> атрибутов сущности.</para>
          <para>Аннотация <code>@OnDelete</code> обрабатывается при удалении той сущности, в которой она встретилась, а не той, на которую указывает аннотированный атрибут (в этом отличие от каскадных удалений на уровне БД).
</para>
          <para>
Аннотация <code>@OnDeleteInverse</code> обрабатывается при удалении той сущности, на которую указывает аннотированный атрибут, (т.е. аналогично каскадному удалению на уровне внешних ключей в БД). Эта аннотация полезна при отсутствии в удаляемом объекте атрибута, который нужно проверять при удалении. При этом, как правило, в проверяемом объекте существует ссылка на удаляемый, на этот атрибут и устанавливается аннотация <code>@OnDeleteInverse</code>. </para>
          <para>Значением аннотации может быть: <itemizedlist>
              <listitem>
                <para><code>DeletePolicy.DENY</code> - запретить удаление сущности, если аннотированный атрибут не <code>null</code> или не пустая коллекция </para>
              </listitem>
              <listitem>
                <para><code>DeletePolicy.CASCADE</code> - каскадно удалить аннотированный атрибут </para>
              </listitem>
              <listitem>
                <para><code>DeletePolicy.UNLINK</code> - разорвать связь с аннотированным атрибутом. Разрыв связи имеет смысл указывать только на ведущей стороне ассоциации - той, которая в  классе сущности аннотирована <code>@JoinColumn</code>. </para>
              </listitem>
            </itemizedlist></para>
          <para>Примеры: <orderedlist>
              <listitem>
                <para>Запрет удаления при наличии ссылки: при попытке удаления экземпляра <code>Customer</code>, на который ссылается хотя бы один <code>Order</code>, будет выброшено исключение <code>DeletePolicyException</code>.</para>
                <para><filename>Order.java</filename><programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;CUSTOMER_ID&quot;)
@OnDeleteInverse(DeletePolicy.DENY)
protected Customer customer;</programlisting></para>
                <para><filename>Customer.java</filename><programlisting language="java">@OneToMany(mappedBy = &quot;customer&quot;)
protected List&lt;Order&gt; orders;</programlisting></para>
              </listitem>
              <listitem>
                <para>Каскадное удаление элементов коллекции: при удалении экземпляра <code>Role</code> все экземпляры <code>Permission</code> также будут удалены.</para>
                <para><filename>Role.java</filename><programlisting language="java">@OneToMany(mappedBy = &quot;role&quot;)
@OnDelete(DeletePolicy.CASCADE)
protected Set&lt;Permission&gt; permissions;</programlisting></para>
                <para><filename>Permission.java</filename><programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;ROLE_ID&quot;)
protected Role role;</programlisting></para>
              </listitem>
              <listitem>
                <para>Разрыв связи с элементами коллекции: удаление экземпляра <code>Role</code> приведет к установке в <code>null</code> ссылок со стороны всех входивших в коллекцию экземпляров <code>Permission</code>.</para>
                <para><filename>Role.java</filename><programlisting language="java">@OneToMany(mappedBy = &quot;role&quot;)
protected Set&lt;Permission&gt; permissions;</programlisting></para>
                <para><filename>Permission.java</filename><programlisting language="java">@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = &quot;ROLE_ID&quot;)
@OnDeleteInverse(DeletePolicy.UNLINK)
protected Role role;</programlisting></para>
              </listitem>
            </orderedlist></para>
          <para>Особенности реализации:<orderedlist>
              <listitem>
                <para>Нужно быть  осторожным при использовании <code>@OnDeleteInverse</code> с политиками <code>CASCADE</code> и <code>UNLINK</code>, так как при этом происходит извлечение из БД на сервер приложения всех экземпляров ссылающихся объектов, изменение и затем сохранение. </para>
                <para>Например, в случае ассоциации <code>Customer</code> - <code>Job</code> и большого количества работ для одного заказчика, если поставить на атрибут <code>Job.customer</code> политику <code>@OnDeleteInverse(CASCADE)</code>, то при удалении экземпляра заказчика будет предпринята попытка извлечь и изменить все его работы. Это может привести  к перегрузке сервера приложения и  БД.</para>
                <para>С другой стороны, использование <code>@OnDeleteInverse(DENY)</code> безопасно, так как при этом производится только подсчет количества ссылающихся объектов, и если оно больше <literal>0</literal>, выбрасывается исключение. Поэтому <code>@OnDeleteInverse(DENY)</code> для атрибута <code>Job.customer</code> вполне допустимо. </para>
              </listitem>
              <listitem>
                <para>Политика обработки связей реализуется   с помощью <link linkend="entity_listeners">Entity Listeners</link>, то есть при сохранении данных в БД  на <link linkend="app_tiers">уровне</link> <structname>Middleware</structname>.</para>
              </listitem>
            </orderedlist> </para>
        </section>
        <section>
          <title>Ограничение уникальности на уровне БД</title>
          <para>В режиме мягкого удаления для ограничения уникальности некоторого значения необходимо обеспечить существование единственной неудаленной записи с этим значением, и произвольного количества удаленных записей с этим же значением.</para>
          <para>Реализуется данная логика путем, специфичным для используемого сервера базы данных:<itemizedlist>
              <listitem>
                <para>Если сервер БД поддерживает частичные (partial) индексы (например, <application>PostgreSQL</application>), то ограничение уникальности можно создать следующим образом:<programlisting>create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC) where DELETE_TS is null</programlisting></para>
              </listitem>
              <listitem>
                <para>Если сервер БД не поддерживает частичные индексы (например, <application>Microsoft SQL Server 2005</application>), то в уникальный индекс можно включить поле <database>DELETE_TS</database>:<programlisting>create unique index IDX_SEC_USER_UNIQ_LOGIN on SEC_USER (LOGIN_LC, DELETE_TS)</programlisting></para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
    </section>
    <section id="metadata_framework">
      <title>Metadata Framework</title>
      <para>Для эффективной работы с <link linkend="data_model">моделью данных</link> в CUBA-приложениях используется фреймворк метаданных, который:</para>
      <itemizedlist>
        <listitem>
          <para>предоставляет удобный интерфейс для получения информации о <glossterm linkend="entity">сущностях</glossterm>, их атрибутах и отношениях между сущностями; а также для навигации по ссылкам</para>
        </listitem>
        <listitem>
          <para>служит специализированной и более удобной в использовании альтернативой <application>Java Reflection API</application></para>
        </listitem>
        <listitem>
          <para>регламентирует допустимые типы данных и отношений между сущностями</para>
        </listitem>
        <listitem>
          <para>позволяет создавать универсальные механизмы работы с данными</para>
        </listitem>
      </itemizedlist>
      <section>
        <title>Интерфейсы метаданных</title>
        <para>Рассмотрим основные интерфейсы метаданных.</para>
        <figure>
          <title>Интерфейсы фреймворка метаданных</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/MetadataFramework.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <variablelist>
          <varlistentry>
            <term>
              <code>Session</code>
            </term>
            <listitem>
              <para>Точка входа в фреймворк метаданных. Позволяет получать экземпляры <code>MetaClass</code> по имени и по соответствующему классу Java. Обратите внимание на различие методов <code>getClass()</code> и <code>getClassNN()</code> - первые могут возвращать <code>null</code>, вторые нет (NonNull).</para>
              <para>Объект <code>Session</code> может быть получен через интерфейс инфраструктуры <code>
                  <link linkend="metadata">Metadata</link>
                </code>.</para>
              <para>Пример:<programlisting language="java">@Inject
protected Metadata metadata;
...
Session session = metadata.getSession();
MetaClass metaClass1 = session.getClassNN(&quot;sec$User&quot;);
MetaClass metaClass2 = session.getClassNN(User.class);
assert metaClass1 == metaClass2;</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>MetaModel</code>
            </term>
            <listitem>
              <para>Редко используемый интерфейс, служит для группировки мета-классов. </para>
              <para>Группировка осуществляется по  имени корневого Java пакета  проекта, указываемого в файле <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="metaClass">
            <term>
              <code>MetaClass</code>
            </term>
            <listitem>
              <para>Интерфейс метаданных класса сущности. <code>MetaClass</code> всегда ассоциирован с классом Java, которого он представляет.</para>
              <para>Основные методы:</para>
              <itemizedlist>
                <listitem>
                  <para><code>getName()</code> – имя сущности, по соглашению первой частью имени до знака <code>$</code> является код пространства имен, например, <code>sales$Customer</code></para>
                </listitem>
                <listitem>
                  <para><code>getProperties()</code> – список мета-свойств (<code>MetaProperty</code>)</para>
                </listitem>
                <listitem>
                  <para><code>getProperty()</code>, <code>getPropertyNN()</code> - получение мета-свойства по имени. Первый метод в случае отсутствия атрибута с указанным именем возвращает <code>null</code>, второй выбрасывает исключение.</para>
                  <para>Пример:<programlisting language="java">MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupProperty = userClass.getPropertyNN(&quot;group&quot;);</programlisting></para>
                </listitem>
                <listitem>
                  <para><code>getPropertyPath()</code> - позволяет перемещаться по ссылкам. Данный метод принимает строковый параметр - путь из имен атрибутов, разделенных точкой. Возвращаемый объект <code>MetaPropertyPath</code> позволяет обратиться к искомому (последнему в пути) атрибуту вызовом <code>getMetaProperty()</code>. </para>
                  <para>Пример:<programlisting language="java">MetaClass userClass = session.getClassNN(User.class);
MetaProperty groupNameProp = userClass.getPropertyPath(&quot;group.name&quot;).getMetaProperty();
assert groupNameProp.getDomain().getName().equals(&quot;sec$Group&quot;);</programlisting></para>
                </listitem>
                <listitem>
                  <para><code>getJavaClass()</code> – класс сущности, которому соответствует данный <code>MetaClass</code></para>
                </listitem>
                <listitem>
                  <para><code>getAnnotations()</code> – коллекция <link linkend="meta_annotations">мета-аннотаций</link> </para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="metaProperty">
            <term>
              <code>MetaProperty</code>
            </term>
            <listitem>
              <para>Интерфейс метаданных атрибута сущности. </para>
              <para>Основные методы:</para>
              <itemizedlist>
                <listitem>
                  <para><code>getName()</code> – имя свойства, соответствует имени атрибута сущности</para>
                </listitem>
                <listitem>
                  <para><code>getDomain()</code> – мета-класс, которому принадлежит данное свойство</para>
                </listitem>
                <listitem id="metaProperty.getType">
                  <para><code>getType() </code>– тип свойства:<itemizedlist>
                      <listitem>
                        <para>простой тип: <code>DATATYPE</code></para>
                      </listitem>
                      <listitem>
                        <para>перечисление: <code>ENUM</code></para>
                      </listitem>
                      <listitem>
                        <para>ссылочный тип двух видов:</para>
                        <itemizedlist>
                          <listitem id="associationType">
                            <para><code>ASSOCIATION</code> − простая ссылка на другую сущность. Например, отношение заказа и покупателя − ассоциация.</para>
                          </listitem>
                          <listitem>
                            <para><code>COMPOSITION</code> − ссылка на сущность, которая не имеет самостоятельного значения без владеющей сущности. <code>COMPOSITION</code> можно считать &quot;более тесным&quot; отношением, чем <code>ASSOCIATION</code>. Например, отношение заказа и пункта этого заказа − <code>COMPOSITION</code>, т.к. пункт не может существовать без заказа, которому он принадлежит.</para>
                          </listitem>
                        </itemizedlist>
                        <para>Вид ссылочного атрибута <code>ASSOCIATION</code> или <code>COMPOSITION</code> влияет на режим редактирования сущности: в первом случае сохранение связанной сущности в базу данных происходит независимо, а во втором − связанная сущность сохраняется в БД только вместе с владеющей сущностью.</para>
                      </listitem>
                    </itemizedlist></para>
                </listitem>
                <listitem>
                  <para><code>getRange()</code> –  интерфейс <code>Range</code>, детально описывающий тип данного атрибута</para>
                </listitem>
                <listitem>
                  <para><code>isMandatory()</code> – признак обязательности атрибута. Используется, например, визуальными компонентами для сигнализации пользователю о необходимости ввода значения.</para>
                </listitem>
                <listitem>
                  <para><code>isReadOnly()</code> – признак неизменности атрибута</para>
                </listitem>
                <listitem>
                  <para><code>getInverse()</code> – для ссылочного атрибута возвращает мета-свойство с обратной стороны ассоциации, если таковое имеется</para>
                </listitem>
                <listitem>
                  <para><code>getAnnotatedElement()</code> – поле (<code>java.lang.reflect.Field</code>) или метод (<code>java.lang.reflect.Method</code>), соответствующие данному атрибуту сущности</para>
                </listitem>
                <listitem>
                  <para><code>getJavaType()</code> – класс Java данного атрибута сущности. Это либо тип поля класса, либо тип возвращаемого значения метода.</para>
                </listitem>
                <listitem>
                  <para><code>getDeclaringClass()</code> – класс Java, содержащий данный атрибут</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>Range</code>
            </term>
            <listitem>
              <para>Интерфейс, детально описывающий тип атрибута сущности.</para>
              <para>Основные методы:</para>
              <itemizedlist>
                <listitem>
                  <para><code>isDatatype()</code> – возвращает <code>true</code> для атрибута простого  <link linkend="metaProperty.getType">типа</link></para>
                </listitem>
                <listitem>
                  <para><code>asDatatype()</code> - возвращает <link linkend="datatype">
                      <code>Datatype</code>
                    </link> для атрибута простого <link linkend="metaProperty.getType">типа</link></para>
                </listitem>
                <listitem>
                  <para><code>isEnum()</code> – возвращает <code>true</code> для атрибута <link linkend="metaProperty.getType">типа</link> перечисления</para>
                </listitem>
                <listitem>
                  <para><code>asEnumeration()</code> - возвращает <link linkend="datatype">
                      <code>Enumeration</code>
                    </link> для атрибута  <link linkend="metaProperty.getType">типа</link> перечисления</para>
                </listitem>
                <listitem>
                  <para><code>isClass()</code> – возвращает <code>true</code> для ссылочного атрибута <link linkend="metaProperty.getType"> типа</link>  <code>ASSOCIATION</code> или <code>COMPOSITION</code></para>
                </listitem>
                <listitem>
                  <para><code>asClass()</code> - возвращает <link linkend="metaClass">мета-класс</link> ассоциированной сущности для ссылочного атрибута</para>
                </listitem>
                <listitem>
                  <para><code>isOrdered()</code> – возвращает <code>true</code>  если атрибут представляет собой упорядоченную коллекцию (например, <code>List</code>)</para>
                </listitem>
                <listitem>
                  <para><code>getCardinality()</code> – вид отношения для ссылочного атрибута: <code>ONE_TO_ONE</code>, <code>MANY_TO_ONE</code>, <code>ONE_TO_MANY</code>, <code>MANY_TO_MANY</code></para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
      <section id="metadata_building">
        <title>Формирование метаданных</title>
        <para>Основной источник формирования структуры метаданных - <link linkend="entity_annotations">аннотированные</link> классы сущностей. </para>
        <para>Класс сущности отражается в метаданных в следующих случаях: <itemizedlist>
            <listitem>
              <para>Класс персистентной сущности аннотирован <code>@Entity</code>, <code>@Embeddable</code>, <code>@MappedSuperclass</code> и расположен в пределах корневого пакета, указанного в <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename>.</para>
            </listitem>
            <listitem>
              <para>Класс неперсистентной сущности аннотирован <code>@MetaClass</code> и расположен в пределах корневого пакета, указанного в <filename>metadata.xml</filename>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Все сущности внутри одного корневого пакета помещаются в один экземпляр <code>MetaModel</code>, которому присваивается имя этого пакета. Между сущностями внутри одной <code>MetaModel</code> можно устанавливать произвольные связи, между разными - в порядке объявления файлов <filename>metadata.xml</filename> в свойстве <property>
            <link linkend="cuba.metadataConfig">cuba.metadataConfig</link>
          </property>. </para>
        <para>Атрибут сущности отражается в метаданных, если: <itemizedlist>
            <listitem>
              <para>поле класса аннотировано <code>@Column</code>, <code>@OneToOne</code>, <code>@OneToMany</code>, <code>@ManyToOne</code>, <code>@ManyToMany</code>, <code>@Embedded</code></para>
            </listitem>
            <listitem>
              <para>поле класса или метод доступа на чтение (getter) аннотирован <code>@MetaProperty</code></para>
            </listitem>
          </itemizedlist></para>
        <para>Параметры мета-класса и мета-свойств формируются на основе параметров перечисленных <link linkend="entity_annotations">аннотаций</link>, а также типов полей и методов класса. Кроме того, если у атрибута отсутствует метод доступа на запись (setter), атрибут становится неизменяемым (read only). </para>
      </section>
      <section id="datatype">
        <title>Datatype</title>
        <para>Интерфейс <code>Datatype</code> описывает тип данных, допустимый для  атрибута сущности, не являющегося ассоциацией. Каждый экземпляр реализации <code>Datatype</code> соответствует одному классу Java, для работы с которым он предназначен.</para>
        <para>Все экземпляры зарегистрированы в репозитории - классе <code>Datatypes</code>, который выполняет загрузку и инициализацию классов реализации <code>Datatype</code> следующим образом:<itemizedlist>
            <listitem>
              <para>в корне <literal>CLASSPATH</literal> ищется файл <filename>
                  <link linkend="datatypes.xml">datatypes.xml</link>
                </filename>, и если он найден, репозиторий <code>Datatypes</code> инициализируется из него</para>
            </listitem>
            <listitem>
              <para>в противном случае инициализация <code>Datatypes</code> производится из файла <filename>/com/haulmont/chile/core/datatypes/<link linkend="datatypes.xml">datatypes.xml</link></filename></para>
            </listitem>
          </itemizedlist></para>
        <para>Экземпляр <code>Datatype</code> может быть получен двумя способами:<itemizedlist>
            <listitem>
              <para>для атрибута сущности из соответствующего ему  мета-свойства типа <code>
                  <link linkend="metaProperty.getType">DATATYPE</link>
                </code>, вызовом <code>getRange().asDatatype()</code></para>
            </listitem>
            <listitem>
              <para>статическим методом <code>Datatypes.get()</code>, передавая в него имя реализации <code>Datatype</code> или класс Java, для которого он создан.</para>
            </listitem>
          </itemizedlist></para>
        <para><code>Datatype</code> сопоставляется атрибуту сущности на старте системы по следующим правилам:<itemizedlist>
            <listitem>
              <para>Если для поля или метода задана аннотация <code>@MetaProperty</code> с непустым значением <code>datatype</code>, то атрибуту сопоставляется экземпляр <code>Datatype</code> с данным именем. </para>
              <para>Например, при следующем объявлении атрибута сущности он получит нестандартный тип <code>GeoCoordinateDatatype</code> (см. пример ниже):<programlisting language="java">@MetaProperty(datatype = GeoCoordinateDatatype.NAME)
@Column(name = &quot;LATITUDE&quot;)
private Double latitude;</programlisting></para>
            </listitem>
            <listitem>
              <para>как правило, явное указание отсутствует, и атрибуту сопоставляется экземпляр <code>Datatype</code>, возвращаемый репозиторием <code>Datatypes.get(Class)</code>, при передаче в него типа поля или метода.</para>
              <para>Например, в данном случае атрибут latitude получит стандартный тип DoubleDatatype, зарегистрированный в базовом <filename>/com/haulmont/chile/core/datatypes/datatypes.xml</filename>:<programlisting language="java">@Column(name = &quot;LATITUDE&quot;)
private Double latitude;</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Основные методы интерфейса <code>Datatype</code>:<itemizedlist>
            <listitem>
              <para><code>getName()</code> - возвращает уникальное имя данной реализации</para>
            </listitem>
            <listitem>
              <para><code>format()</code> - преобразовывает переданное значение в строку</para>
            </listitem>
            <listitem>
              <para><code>parse()</code> - преобразовывает строку в значение нужного типа </para>
            </listitem>
          </itemizedlist></para>
        <para><code>Datatype</code> определяет два набора методов для форматирования/парсинга: с учетом локали и без учета локали. Преобразование с учетом локали используется повсеместно в пользовательском интерфейсе, преобразование без учета локали используется в системных механизмах, например, для сериализации в <link linkend="rest_api">REST API</link>. </para>
        <para>Форматы для преобразований без учета локали задаются в вышеупомянутом файле <filename>
            <link linkend="datatypes.xml">datatypes.xml</link>
          </filename>.</para>
        <para>Форматы для преобразований с учетом локали задаются в <link linkend="main_message_pack">главном пакете локализованных сообщений</link>, в  строках со следующими ключами:<itemizedlist>
            <listitem>
              <para><literal>numberDecimalSeparator</literal> - задает символ разделителя целой и дробной части для числовых типов</para>
            </listitem>
            <listitem>
              <para><literal>numberGroupingSeparator</literal> - задает символ разделителя групп разрядов  для числовых типов</para>
            </listitem>
            <listitem>
              <para><literal>integerFormat</literal> - формат для  типов <code>Integer</code> и <code>Long</code></para>
            </listitem>
            <listitem>
              <para><literal>doubleFormat</literal> - формат для типа <code>Double</code></para>
            </listitem>
            <listitem>
              <para><literal>decimalFormat</literal> - формат для типа <code>BigDecimal</code></para>
            </listitem>
            <listitem>
              <para><literal>dateTimeFormat</literal> - формат для типа <code>java.util.Date</code></para>
            </listitem>
            <listitem>
              <para><literal>dateFormat</literal> - формат для типа <code>java.sql.Date</code></para>
            </listitem>
            <listitem>
              <para><literal>timeFormat</literal> - формат для типа <code>java.sql.Time</code></para>
            </listitem>
            <listitem>
              <para><literal>trueString</literal> - строка, соответствующая <code>Boolean.TRUE</code></para>
            </listitem>
            <listitem>
              <para><literal>falseString</literal> - строка, соответствующая <code>Boolean.FALSE</code></para>
            </listitem>
          </itemizedlist>Все перечисленные форматы по умолчанию заданы в главном пакете локализованных сообщений <link linkend="base_projects">базового проекта</link> <structname>cuba</structname>, и могут быть переопределены в аналогичных файлах проекта приложения.</para>
        <section>
          <title>Пример форматирования даты в UI</title>
          <para>Рассмотрим отображение атрибута <code>Order.date</code> в таблице браузера заказов.</para>
          <para>order-browse.xml<programlisting language="xml">&lt;table id=&quot;ordersTable&quot;&gt;
    ...
    &lt;columns&gt;
        &lt;column id=&quot;date&quot;/&gt;
        ...</programlisting></para>
          <para>Атрибут <code>date</code>  в классе <code>Order</code> определен с типом &quot;дата&quot;:<programlisting language="java">@Column(name = &quot;DATE&quot;, nullable = false)
@Temporal(TemporalType.DATE)
private Date date;</programlisting></para>
          <para>Если текущий пользователь зарегистрирован c русской локалью, то из <link linkend="main_message_pack">главного пакета</link> локализованных сообщений клиентского <link linkend="app_tiers">уровня</link>, из файла <filename>messages_ru.properties</filename> извлекается строка:<programlisting>dateFormat=dd.MM.yyyy</programlisting></para>
          <para>Результат: дата &quot;6 августа 2012 года&quot; конвертируется в строку &quot;06.08.2012&quot; для отображения в ячейке таблицы.</para>
        </section>
        <section>
          <title>Примеры форматирования дат и чисел в коде приложения</title>
          <itemizedlist>
            <listitem>
              <para>Пример форматирования даты<programlisting language="java">@Inject
protected UserSessionSource userSessionSource;
...
Date date = ...;
String dateStr = Datatypes.get(Date.class).format(date, userSessionSource.getLocale());</programlisting></para>
            </listitem>
            <listitem>
              <para>Пример форматирования числового значения с повышенной точностью  (5 знаков после запятой) в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname></para>
              <para><filename>/com/sample/sales/web/messages_ru.properties</filename><programlisting>coordinateFormat = #,##0.00000</programlisting></para>
              <para><filename>SomeClass.java</filename><programlisting language="java">@Inject
protected Messages messages;
@Inject
protected UserSessionSource userSessionSource;
...
String coordinateFormat = messages.getMainMessage(&quot;coordinateFormat&quot;);
FormatStrings formatStrings = Datatypes.getFormatStrings(userSessionSource.getLocale());
NumberFormat format = new DecimalFormat(coordinateFormat, formatStrings.getFormatSymbols());

String formattedValue = format.format(value);</programlisting></para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Пример специализированного Datatype</title>
          <para>Рассмотрим реализацию нестандартного типа GeoCoordinateDatatype, предназначенного для атрибутов, хранящих географические координаты.</para>
          <para>Создаем класс в модуле <structname>global</structname>:<programlisting language="java">public class GeoCoordinateDatatype extends DoubleDatatype {

    public static final String NAME = &quot;geocoordinate&quot;;
    
    // формат общий для всех локалей, отличаться могут только символы десятичной точки 
    public static final String FORMAT = &quot;#0.000000&quot;;

    public GeoCoordinateDatatype(Element element) {
        super(element);
    }

    @Override
    public String getName() {
        return NAME;
    }

    @Override
    public String format(Double value, Locale locale) {
        if (value == null)
            return &quot;&quot;;
        FormatStrings formatStrings = Datatypes.getFormatStrings(locale);
        if (formatStrings == null)
            return format(value); // FormatStrings для локали не определены, форматируем по данным datatypes.xml

        NumberFormat format = new DecimalFormat(FORMAT, formatStrings.getFormatSymbols());
        return format.format(value);
    }

    @Override
    public Double parse(String value, Locale locale) throws ParseException {
        if (StringUtils.isBlank(value))
            return null;
        FormatStrings formatStrings = Datatypes.getFormatStrings(locale);
        if (formatStrings == null)
            return parse(value); // FormatStrings для локали не определены, парсим по данным datatypes.xml

        NumberFormat format = new DecimalFormat(FORMAT, formatStrings.getFormatSymbols());
        return parse(value, format).doubleValue();
    }
}</programlisting></para>
          <para>Создаем файл <filename>datatypes.xml</filename> в корне каталога <filename>src</filename> модуля <structname>global</structname> проекта приложения и копируем в него все из файла <filename>/com/haulmont/chile/core/datatypes/datatypes.xml</filename>, расположенного в модуле <structname>global</structname> базового проекта <structname>cuba</structname>. Затем добавляем в него регистрацию нового типа:<programlisting language="xml">&lt;datatypes&gt;

    &lt;datatype class=&quot;com.sample.sales.entity.GeoCoordinateDatatype&quot;
              format=&quot;#0.000000&quot; decimalSeparator=&quot;.&quot; groupingSeparator=&quot;&quot;/&gt;
...</programlisting></para>
          <para>Указываем новый тип данных для требуемых атрибутов:<programlisting language="java">@MetaProperty(datatype = GeoCoordinateDatatype.NAME)
@Column(name = &quot;LATITUDE&quot;)
private Double latitude;</programlisting></para>
          <para>После выполнения перечисленных действий атрибут <code>latitude</code> везде в приложении будет отображаться в нужном формате.</para>
        </section>
      </section>
      <section id="meta_annotations">
        <title>Мета-аннотации</title>
        <para>Мета-аннотации сущностей - набор пар ключ/значение, содержащих дополнительную информацию о сущностях.</para>
        <para>Обращение к мета-аннотациям  производится с помощью метода <link linkend="metaClass">мета-класса</link> <code>getAnnotations()</code>.</para>
        <para>Источниками мета-аннотаций сущности являются:<itemizedlist>
            <listitem>
              <para><link linkend="entity_annotations">Аннотации</link>  <code>@OnDelete</code>, <code>@OnDeleteInverse</code>, <code>@Extends</code>. При этом в мета-аннотациях создаются служебные объекты связей между сущностями. </para>
            </listitem>
            <listitem>
              <para><link linkend="entity_annotations">Аннотации</link> <code>@NamePattern</code>, <code>@SystemLevel</code>, <code>@EnableRestore</code>, <code>@TrackEditScreenHistory</code>. При этом создаются  мета-аннотации с ключами, соответствующими полному имени класса Java аннотации. </para>
            </listitem>
            <listitem>
              <para>Опционально: в прикладном проекте могут быть определены свои аннотации для сущностей, и в <link linkend="extension">переопределенном</link> методе <code>MetadataImpl.initMetaAnnotations()</code> отображены в соответствующие мета-аннотации. </para>
            </listitem>
            <listitem>
              <para>Опционально: в файлах <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename> также могут быть определены мета-аннотации сущностей. Если мета-аннотация в XML имеет то же имя, что и мета-аннотация, созданная по Java аннотации класса сущности, первая переопределит значение второй. </para>
              <para>Пример определения мета-аннотаций в <filename>
                  <link linkend="metadata.xml">metadata.xml</link>
                </filename>:<programlisting language="xml">&lt;annotations&gt;
    &lt;entity class=&quot;com.haulmont.cuba.security.entity.User&quot;&gt;
        &lt;annotation name=&quot;com.haulmont.cuba.core.entity.annotation.TrackEditScreenHistory&quot; value=&quot;false&quot;/&gt;
        &lt;annotation name=&quot;com.haulmont.cuba.core.entity.annotation.EnableRestore&quot; value=&quot;true&quot;/&gt;
    &lt;/entity&gt;
&lt;/annotations&gt;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="views">
      <title>Представления</title>
      <para>При извлечении сущностей из базы данных обычно встает вопрос - как обеспечить загрузку связанных сущностей на нужную глубину? </para>
      <para>Например,  для браузера Заказов нужно отобразить дату и сумму заказа совместно с названием Покупателя, т.е. загрузить связанный экземпляр Покупателя. А для экрана редактирования Заказа необходимо загрузить еще и коллекцию Пунктов заказа, причем каждый Пункт заказа должен содержать связанный экземпляр Товара для отображения его наименования. </para>
      <para><link linkend="lazy_loading">Загрузка по требованию</link> в большинстве случаев не может помочь, так как обработка данных, как правило, происходит не в транзакции, в которой загружаются сущности, а, например, на клиентском <link linkend="app_tiers">уровне</link> в пользовательском интерфейсе. В то же время задание <glossterm linkend="eager_fetching">жадной загрузки</glossterm> в <link linkend="entity_annotations">аннотациях сущностей</link> недопустимо, так как приводит к постоянному извлечению всего графа связанных сущностей, который может быть очень большим.</para>
      <para>Другой похожей проблемой является ограничение набора <glossterm linkend="local_attribute">локальных</glossterm> атрибутов сущностей загружаемого графа: например, некоторая сущность имеет 50 атрибутов, в том числе BLOB, а в экране отображается только 10 атрибутов. Зачем загружать из БД, затем сериализовать и передавать клиенту 40 атрибутов, которые ему в данный момент не нужны?</para>
      <para>Механизм <firstterm>представлений</firstterm> (views)  решает эти проблемы, обеспечивая извлечение из базы данных и передачу клиенту графов сущностей, ограниченных в глубину и по атрибутам. <firstterm>Представление</firstterm> является описателем графа объектов, который требуется в некотором экране UI или другом процессе обработки данных.</para>
      <para>Обработка представлений производится следующим образом:<itemizedlist>
          <listitem>
            <para>Все связи в модели данных объявляются с признаком <link linkend="lazy_loading">загрузки по требованию</link> (<code>fetch = FetchType.LAZY</code>, см. <xref linkend="entity_annotations"/>).</para>
          </listitem>
          <listitem>
            <para>В процессе загрузки данных через <link linkend="dataService">DataService</link> клиентский код помимо <glossterm linkend="jpql">JPQL</glossterm> запроса указывает нужное  представление.</para>
          </listitem>
          <listitem>
            <para>На основе представления формируется так называемый <firstterm>Fetch Plan</firstterm> - особенность лежащего в основе <link linkend="orm">слоя ORM</link> фреймворка <application>Apache OpenJPA</application>. Fetch Plan влияет на формирование SQL запроса к базе данных: как на список возвращаемых полей, так и на соединения с другими таблицами, содержащими связанные сущности.</para>
          </listitem>
          <listitem>
            <para>В представлении некоторые ссылочные атрибуты могут быть объявлены как <code>lazy</code> (см. ниже). Lazy-атрибуты не включаются в Fetch Plan, а загружаются отдельными SQL запросами (иногда это полезно  для упрощения основного SQL запроса). Для этого механизм обработки представлений просто обращается к соответствующим методам чтения атрибутов.</para>
          </listitem>
          <listitem>
            <para>В результате на момент завершения <link linkend="transactions">транзакции</link>, загружающей данные, в памяти <structname>Middleware</structname> содержится граф объектов, заданный  JPQL запросом и представлением.</para>
          </listitem>
        </itemizedlist></para>
      <figure>
        <title>Классы представления</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/View.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Представление определяется экземпляром класса <code>View</code>, в котором:<itemizedlist>
          <listitem>
            <para><code>entityClass</code> - класс сущности, для  которого определено представление. Другими словами, &quot;корень&quot; дерева загружаемых сущностей.</para>
          </listitem>
          <listitem>
            <para><code>name</code> - имя представления. Должно быть либо <code>null</code>, либо уникальным в пределах данной сущности.</para>
          </listitem>
          <listitem>
            <para><code>properties</code> - коллекция экземпляров класса ViewProperty, соответствующих загружаемым атрибутам сущности.</para>
          </listitem>
          <listitem>
            <para><code>includeSystemProperties</code> - признак включения системных атрибутов (входящих в состав <link linkend="entity_base_classes">базовых интерфейсов</link> персистентных сущностей <code>BaseEntity</code> и  <code>Updatable</code>). Системные атрибуты не перечисляются в <code>properties</code>  явно, а учитываются механизмом обработки представлений в зависимости от того, какие интерфейсы реализует данная сущность.</para>
          </listitem>
        </itemizedlist></para>
      <para>Класс <code>ViewProperty</code> имеет следующие свойства:<itemizedlist>
          <listitem>
            <para><code>name</code> - имя атрибута сущности</para>
          </listitem>
          <listitem>
            <para><code>view</code> - для ссылочных атрибутов задает представление, с которым необходимо загружать связанную сущность</para>
          </listitem>
          <listitem>
            <para><code>lazy</code> - для ссылочных атрибутов признак того, что данный атрибут нужно не  включать в Fetch Plan, а загружать отдельным SQL запросом, инициированным обращением к атрибуту. Следует иметь в виду, что при использовании <code>
                <link linkend="dataService">DataService</link>
              </code> и <link linkend="datasources">источников данных</link> атрибут в любом случае будет загружен, данный признак влияет только на способ загрузки. Если же представление с <code>lazy</code> атрибутами используется на уровне ORM, то после загрузки экземпляров их обязательно нужно передать в метод <code><link linkend="entityManager">EntityManager</link>.fetch()</code> до окончания транзакции, иначе <code>lazy</code> атрибуты загружены не будут.</para>
          </listitem>
        </itemizedlist></para>
      <warning>
        <para>Независимо от набора атрибутов, определенного в представлении, всегда загружаются следующие атрибуты:<itemizedlist>
            <listitem>
              <para><code>id</code> - идентификатор сущности</para>
            </listitem>
            <listitem>
              <para><code>version</code> - для оптимистично блокируемых сущностей, реализующих <code>Versioned</code></para>
            </listitem>
            <listitem>
              <para><code>deleteTs</code>, <code>deletedBy</code> - для сущностей, реализующих <code>
                  <link linkend="soft_deletion">SoftDelete</link>
                </code></para>
            </listitem>
          </itemizedlist></para>
      </warning>
      <para>Незагруженные атрибуты имеют значение <code>null</code>. По умолчанию попытка установки значения незагруженного атрибута (вызов setter) для <link linkend="entity_states">Detached</link> сущности вызывает исключение. Это поведение можно изменить с помощью свойства приложения <property>
          <link linkend="cuba.allowSetNotLoadedAttributes">cuba.allowSetNotLoadedAttributes</link>
        </property>. Если данное свойство установлено в <code>true</code>, то вызов setter не приведет к исключению, но значение все равно сохранено не будет.</para>
      <para>Следует иметь в виду, что незагруженные ссылочные атрибуты Detached сущности, соответствующие внешним ключам (т.е. ManyToOne, OneToOne), можно установить в новое ненулевое значение в любом случае, и изменения будут сохранены при последующем <code>merge()</code>.</para>
      <section id="view_creation">
        <title>Создание представлений</title>
        <para>Представление может быть создано двумя путями:<itemizedlist>
            <listitem>
              <para><emphasis role="bold">программно</emphasis> - созданием экземпляра <code>View</code>, например:<programlisting language="java">View view = new View(Order.class)
        .addProperty(&quot;date&quot;)
        .addProperty(&quot;amount&quot;)
        .addProperty(&quot;customer&quot;, new View(Customer.class)
            .addProperty(&quot;name&quot;)
        );</programlisting></para>
              <para>Как правило, таким способом создаются представления, используемые только в каком-то одном месте бизнес-логики.</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">декларативно</emphasis> - путем создания описателя на XML и его развертывания в репозитории представлений <code>ViewRepository</code>. При развертывании на основе XML-описателя создаются и кэшируются экземпляры <code>View</code>. В дальнейшем в любом месте кода приложения требуемое представление можно получить вызовом репозитория с указанием класса сущности и имени представления.</para>
            </listitem>
          </itemizedlist></para>
        <para>Рассмотрим подробнее декларативный способ создания и работы с представлениями.</para>
        <para><code>ViewRepository</code> является бином <application>Spring</application>, доступным для всех блоков приложения. Ссылка на <code>ViewRepository</code> может быть также получена через интерфейс инфраструктуры <code>
            <link linkend="metadata">Metadata</link>
          </code>. Для получения экземпляра <code>View</code>, содержащегося в репозитории, используются методы <code>getView()</code>. Для развертывания XML-описателей представлений в репозитории используются методы  <code>deployViews()</code> базовой реализации <code>AbstractViewRepository</code>.</para>
        <para>В репозитории для каждой сущности по умолчанию доступны два  представления с именами <filename>_local</filename> и <filename>_minimal</filename>:<itemizedlist>
            <listitem>
              <para><filename>_local</filename> включает в себя все <glossterm linkend="local_attribute">локальные</glossterm> атрибуты сущности</para>
            </listitem>
            <listitem>
              <para><filename>_minimal</filename> включает в себя атрибуты, входящие в имя экземпляра сущности, и задаваемые аннотацией <code>
                  <link linkend="namePattern">@NamePattern</link>
                </code>. Если аннотация <code>@NamePattern</code>  для сущности не указана, данное представление не включает никаких атрибутов.</para>
            </listitem>
          </itemizedlist></para>
        <para>Подробная структура XML-описателей изложена в <xref linkend="views.xml"/></para>
        <para>Пример описателя представления для сущности Заказ, которое должно обеспечить загрузку всех локальных атрибутов, ассоциированного Покупателя и коллекции Пунктов заказа:<programlisting language="xml">&lt;view class=&quot;com.sample.sales.entity.Order&quot;
      name=&quot;orderWithCustomer&quot;
      extends=&quot;_local&quot;&gt;
    &lt;property name=&quot;customer&quot; view=&quot;_minimal&quot;/&gt;
    &lt;property name=&quot;items&quot; view=&quot;itemsInOrder&quot;/&gt;
&lt;/view&gt;</programlisting></para>
        <para>Рекомендуемый способ группировки и развертывания описателей представлений:<itemizedlist>
            <listitem>
              <para>В <link linkend="app_modules">модуле</link> <structname>global</structname>  в корне <filename>src</filename>  создать файл <filename>views.xml</filename> и поместить в него все описатели представлений, которые должны быть доступны глобально, т.е. на всех <link linkend="app_tiers">уровнях приложения</link>.</para>
            </listitem>
            <listitem>
              <para>Зарегистрировать данный файл в свойстве <property>
                  <link linkend="cuba.viewsConfig">cuba.viewsConfig</link>
                </property> блока <structname>Middleware</structname> и используемых клиентских блоков, т.е. в файле <filename>app.properties</filename> модуля <structname>core</structname>, в файле <filename>web-app.properties</filename> модуля <structname>web</structname> и так далее. Это обеспечит автоматическое развертывание представлений на старте приложения в репозитории <structname>Middleware</structname> и клиентских блоков (см. метод <code>AbstractViewRepository.init()</code>).</para>
            </listitem>
            <listitem>
              <para>Если существуют представления, которые необходимы только какому-то одному клиентскому блоку приложения, то можно определить их в аналогичном файле данного блока, например, <filename>web-views.xml</filename>, и добавить этот файл в свойство <code>cuba.viewsConfig</code> этого блока, т.е. в данном случае в  файл <filename>web-app.properties</filename>. </para>
            </listitem>
          </itemizedlist></para>
        <para>Если на момент развертывания некоторого представления в репозитории уже есть представление для этого же класса сущности и с таким же именем, то новое будет проигнорировано. Для того чтобы представление заменило имеющееся в репозитории и гарантированно было развернуто, в XML-описателе должен быть явно указан атрибут <literal>overwrite = &quot;true&quot;</literal>.</para>
        <tip>
          <para>Рекомендуется давать представлениям &quot;описательные&quot; имена. Например, не &quot;browse&quot;, а &quot;customerBrowse&quot;. Это упрощает поиск XML-описателей представлений по имени в процессе разработки приложения.</para>
        </tip>
      </section>
    </section>
    <section id="managed_beans">
      <title>Управляемые бины</title>
      <para><firstterm>Управляемые бины (Managed Beans)</firstterm> − это программные компоненты, предназначенные для реализации бизнес-логики приложения. Термин &quot;управляемые&quot; в данном случае означает, что созданием экземпляров и установкой связей между такими компонентами управляет <glossterm linkend="container">контейнер</glossterm>, который является основной частью фреймворка <application>Spring</application>.</para>
      <warning>
        <para>Managed Bean представляет собой <firstterm>singleton</firstterm>, то есть в некотором блоке приложения существует только один экземпляр данного класса. Поэтому, если бин содержит изменяемые данные в полях (другими словами, имеет состояние), то обращение к таким данным необходимо синхронизировать.</para>
      </warning>
      <section>
        <title>Создание бина</title>
        <para>Для создания  управляемого бина достаточно добавить классу  Java аннотацию  <literal>@javax.annotation.ManagedBean</literal>. Например:<programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorker {
    public static final String NAME = &quot;sales_OrderWorker&quot;;

    public void calculateTotals(Order order) {
    }
}</programlisting></para>
        <para>Рекомендуется присваивать бину уникальное имя вида <literal>{имя_проекта}_{имя_класса}</literal>, и определять его в константе <code>NAME</code>. </para>
        <para>Класс управляемого бина должен находиться внутри дерева пакетов с корнем, заданным в элементе <literal>context:component-scan</literal> файла <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename>. В нашем случае файл <filename>spring.xml</filename> содержит элемент:<programlisting language="xml">&lt;context:component-scan base-package=&quot;com.sample.sales&quot;/&gt;</programlisting>что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета <code>com.sample.sales</code>.</para>
        <para>Если нужно обеспечить возможность подмены реализации,  рекомендуется  выделять бизнес-интерфейс бина, например, следующим образом:</para>
        <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderWorker {
    String NAME = &quot;sales_OrderWorker&quot;;

    void calculateTotals(Order order);
}</programlisting>
        <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;
import javax.annotation.ManagedBean;

@ManagedBean(OrderWorker.NAME)
public class OrderWorkerBean implements OrderWorker {
    @Override
    public void calculateTotals(Order order) {
    }
}</programlisting>
        <para>Управляемые бины можно создавать на любом <link linkend="app_tiers">уровне</link>, так как контейнер <application>Spring Framework</application> используется во всех стандартных блоках приложения.</para>
      </section>
      <section>
        <title>Использование бина</title>
        <para>Ссылку на бин можно получить с помощью инжекции или класса <code>AppBeans</code>. В качестве примера использования бина рассмотрим реализацию <link linkend="services">сервиса</link> <code>OrderService</code>, делегирующего выполнение бину <code>OrderWorker</code>:<programlisting language="java">package com.sample.sales.core;

import com.haulmont.cuba.core.Persistence;
import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import javax.inject.Inject;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {
    
    @Inject
    protected Persistence persistence;
    
    @Inject
    protected OrderWorker orderWorker;
    
    @Transactional
    @Override
    public BigDecimal calculateTotals(Order order) {
        Order entity = persistence.getEntityManager().merge(order);
        orderWorker.calculateTotals(entity);
    }
}</programlisting></para>
        <para>В данном примере сервис стартует <link linkend="transactions">транзакцию</link>, вносит полученный с клиентского уровня экземпляр сущности в <link linkend="entityManager">персистентный контекст</link>, и передает управление бину <code>OrderWorker</code>, который и содержит основную бизнес-логику. </para>
      </section>
    </section>
    <section id="jmx_beans">
      <title>JMX-бины</title>
      <para>Иногда требуется  предоставить администратору системы возможность просматривать и изменять  состояние некоторого <link linkend="managed_beans">управляемого бина</link> во время выполнения. В этом случае рекомендуется создать  JMX-бин - программный компонент, имеющий <glossterm linkend="jmx">JMX</glossterm>-интерфейс. Такой бин, как правило, делегирует вызовы управляемому бину, содержащему кэш, конфигурационные данные или статистику, к которым нужно обеспечить доступ через JMX.</para>
      <figure>
        <title/>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/JMXBeans.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Как видно из диаграммы, JMX-бин состоит из интерфейса и класса реализации. Класс должен представлять собой <link linkend="managed_beans">управляемый бин</link>, то есть иметь аннотацию <code>@ManagedBean</code> и уникальное имя. Интерфейс JMX-бина специальным образом регистрируется в <link linkend="spring.xml">spring.xml</link> для создания в текущей JVM собственно JMX-интерфейса.</para>
      <para>Вызовы всех методов интерфейса JMX-бина перехватываются с помощью <application>Spring AOP</application> классом−<glossterm linkend="interceptor">интерцептором</glossterm> <methodname>MBeanInterceptor</methodname>, который обеспечивает установку правильного <code>ClassLoader</code> в контексте потока выполнения, и журналирование необработанных исключений.</para>
      <warning>
        <para>Интерфейс JMX-бина обязательно должен иметь имя вида <literal>{имя_класса}MBean</literal>.</para>
      </warning>
      <para>С JMX-интерфейсом можно работать из  внешних инструментов, таких как <code>jconsole</code> или <code>jvisualvm</code>. Кроме того, в состав блока Web Client платформы входит <link linkend="jmx_console">JMX консоль</link>, предоставляющая базовые средства просмотра состояния и вызова методов JMX-бинов.</para>
      <section>
        <title>Создание JMX-бина</title>
        <para>Рассмотрим процесс создания JMX-бина на примере.</para>
        <itemizedlist>
          <listitem>
            <para>Интерфейс JMX-бина:<programlisting language="java">package com.sample.sales.core;

import org.springframework.jmx.export.annotation.*;

@ManagedResource(description = &quot;Performs operations on Orders&quot;)
public interface OrdersMBean {

    @ManagedOperation(description = &quot;Recalculates an order amount&quot;)
    @ManagedOperationParameters({@ManagedOperationParameter(name = &quot;orderId&quot;, description = &quot;&quot;)})
    String calculateTotals(String orderId);
}</programlisting></para>
            <para>Интерфейс и его методы могут содержать аннотации для задания описания JMX-бина и его операций. Это описание будет отображаться во всех инструментах, работающих с данным JMX-интерфейсом, тем самым помогая администратору системы.</para>
            <para>Так как инструменты JMX поддерживают ограниченный набор типов данных,  параметры и результат метода желательно задавать типа <code>String</code>, и при необходимости выполнять конвертацию внутри метода.</para>
          </listitem>
          <listitem>
            <para>Класс JMX-бина:<programlisting language="java">package com.sample.sales.core;

import com.haulmont.cuba.core.*;
import com.haulmont.cuba.core.app.*;
import com.sample.sales.entity.Order;
import org.apache.commons.lang.exception.ExceptionUtils;
import javax.annotation.ManagedBean;
import javax.inject.Inject;
import java.util.UUID;

@ManagedBean(&quot;sales_OrdersMBean&quot;)
public class Orders implements OrdersMBean {

    @Inject
    protected OrderWorker orderWorker;

    @Inject
    protected Persistence persistence;

    @Authenticated
    @Override
    public String calculateTotals(final String orderId) {
        try {
            persistence.createTransaction().execute(new Transaction.Runnable() {
                @Override
                public void run(EntityManager em) {
                    Order entity = em.find(Order.class, UUID.fromString(orderId));
                    orderWorker.calculateTotals(entity);
                }
            });
            return &quot;Done&quot;;
        } catch (Throwable e) {
            return ExceptionUtils.getStackTrace(e);
        }
    }
}</programlisting></para>
            <para>Аннотация <code>@ManagedBean</code> определяет, что данный класс является управляемым бином с именем <literal>sales_OrdersMBean</literal>. Имя указано напрямую в аннотации, а не в константе, так как доступ к JMX-бину из кода Java не требуется.</para>
            <para>Рассмотрим реализацию метода <code>calculateTotals()</code>.<itemizedlist>
                <listitem>
                  <para>Метод имеет аннотацию <code>@Authenticated</code>, т.е. при входе в метод и при отсутствии в потоке выполнения <link linkend="userSession">пользовательской сессии</link> выполняется <link linkend="system_authentication">системная аутентификация</link>.</para>
                </listitem>
                <listitem>
                  <para>Тело метода обернуто в блок <code>try/catch</code>, так что метод в случае успешного выполнения возвращает строку &quot;Done&quot;, а в случае ошибки - stacktrace исключения в виде строки. </para>
                  <para>Следует иметь в виду, что в данном случае все исключения обрабатываются, а значит, не попадают в <code>MBeanInterceptor</code> и не выводятся в журнал автоматически. Поэтому при необходимости логгировать исключения здесь нужно добавить вызов логгера в секции <code>catch</code>.</para>
                </listitem>
                <listitem>
                  <para>Логика метода заключается в том, что он стартует транзакцию, загружает экземпляр сущности <code> Order</code> по  идентификатору, и передает управление бину <code>OrderWorker</code> для обработки.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Регистрация JMX-бина в <filename>spring.xml</filename>:</para>
            <programlisting language="xml">&lt;bean id=&quot;sales_MBeanExporter&quot; lazy-init=&quot;false&quot; 
      class=&quot;com.haulmont.cuba.core.sys.jmx.MBeanExporter&quot;&gt;
    &lt;property name=&quot;beans&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;${cuba.webContextName}.sales:type=Orders&quot;
                   value-ref=&quot;sales_OrdersMBean&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
          </listitem>
        </itemizedlist>
        <para>Все JMX-бины проекта объявляются в одном экземпляре <code>MBeanExporter</code>  в элементах <literal>map/entry</literal> свойства <code>beans</code>. Ключом элемента здесь является JMX ObjectName, значением - имя бина, заданное
в аннотации <code>@ManagedBean</code>. ObjectName начинается с имени веб-приложения, так как в одном экземпляре <application>Tomcat</application> (т.е. в одной JVM) может быть развернуто несколько веб-приложений, экспортирующих одинаковые JMX-интерфейсы.</para>
      </section>
      <section>
        <title>JMX-бины платформы</title>
        <para>В данном разделе описаны некоторые имеющиеся в платформе JMX-бины.</para>
        <section id="cachingFacadeMBean">
          <title>CachingFacadeMBean</title>
          <para><code>CachingFacadeMBean</code> предоставляет методы очистки различных кэшей в блоках <structname>Middleware</structname> и  <structname>Web Client</structname>.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=CachingFacade</literal> и <literal>app.cuba:type=CachingFacade</literal></para>
        </section>
        <section id="configStorageMBean">
          <title>ConfigStorageMBean</title>
          <para><code>ConfigStorageMBean</code> позволяет просматривать и задавать значения <link linkend="app_properties">свойствам приложения</link> в блоках <structname>Middleware</structname>, <structname>Web Client</structname> и <structname>Web Portal</structname>.</para>
          <para>Данный интерфейс имеет отдельные наборы методов для работы  с параметрами конфигурации и развертывания (<code>*AppProperties</code>) и с параметрами времени выполнения (<code>*DbProperties</code>), что обусловлено различием механизмов хранения этих категорий свойств.</para>
          <warning>
            <para>Существуют следующие ограничения в использовании интерфейса <code>ConfigStorageMBean</code>:<itemizedlist>
                <listitem>
                  <para>Отображаются только явно установленные в месте хранения свойства. Если значение свойства не задано, то в случае обращения к нему из кода программы через <link linkend="config_interfaces">конфигурационный интерфейс</link>, возвращается значение по умолчанию. Однако через <code>ConfigStorageMBean</code> значение по умолчанию не может быть получено. </para>
                </listitem>
                <listitem>
                  <para>Измененные значения для свойств, хранящихся в файлах, не сохраняются, и действуют только до рестарта данного блока.</para>
                </listitem>
              </itemizedlist></para>
          </warning>
          <para>JMX ObjectName: <literal>app-core.cuba:type=ConfigStorage</literal>, <literal>app.cuba:type=ConfigStorage</literal>, <literal>app-portal.cuba:type=ConfigStorage</literal></para>
        </section>
        <section>
          <title>EmailerMBean</title>
          <para><code>EmailerMBean</code> позволяет просмотреть текущие значения параметров <link linkend="email_sending">отсылки email</link>, а также отправить тестовое сообщение.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=Emailer</literal></para>
        </section>
        <section id="persistenceManagerMBean">
          <title>PersistenceManagerMBean</title>
          <para><code>PersistenceManagerMBean</code> предоставляет следующие возможности:<itemizedlist>
              <listitem>
                <para>управление механизмом <link linkend="entity_statistics">статистики сущностей</link></para>
              </listitem>
              <listitem>
                <para>отображение новых скриптов обновления БД методом <code>findUpdateDatabaseScripts()</code> и запуск обновления методом <code>updateDatabase()</code></para>
              </listitem>
              <listitem>
                <para>запуск произвольных JPQL запросов в контексте <structname>Middleware</structname> методами <code>jpqlLoadList()</code>, <code>jpqlExecuteUpdate()</code></para>
              </listitem>
            </itemizedlist></para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=PersistenceManager</literal></para>
        </section>
        <section id="scriptingManagerMBean">
          <title>ScriptingManagerMBean</title>
          <para><code>ScriptingManagerMBean</code> является JMX-фасадом для интерфейса инфраструктуры <code>
              <link linkend="scripting">Scripting</link>
            </code>.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=ScriptingManager</literal></para>
          <para>JMX атрибуты:<itemizedlist>
              <listitem>
                <para><code>RootPath</code> - абсолютный путь к <link linkend="conf_dir">конфигурационному каталогу</link> <link linkend="app_tiers">блока приложения</link>, в котором запущен данный бин</para>
              </listitem>
            </itemizedlist></para>
          <para>JMX операции:<itemizedlist>
              <listitem>
                <para><code>runGroovyScript()</code> - выполнить скрипт Groovy в контексте <structname>Middleware</structname> и вернуть результат. В скрипт передаются следующие переменные:<itemizedlist>
                    <listitem>
                      <para><code>persistence</code> типа <code>
                          <link linkend="persistence">Persistence</link>
                        </code> </para>
                    </listitem>
                    <listitem>
                      <para><code>metadata</code> типа <code>
                          <link linkend="metadata">Metadata</link>
                        </code></para>
                    </listitem>
                    <listitem>
                      <para><code>configuration</code> типа <code>
                          <link linkend="configuration">Configuration</link>
                        </code></para>
                    </listitem>
                  </itemizedlist></para>
                <para>Для отображения в JMX-интерфейсе результат должен быть типа <code>String</code>. В остальном аналогичен методу <code>Scripting.<link linkend="scripting.runGroovyScript">runGroovyScript()</link></code>. </para>
                <para>Пример скрипта, создающего набор тестовых пользователей:<programlisting language="java">import com.haulmont.cuba.core.*
import com.haulmont.cuba.core.global.*
import com.haulmont.cuba.security.entity.*

PasswordEncryption passwordEncryption = AppBeans.get(PasswordEncryption.class)

Transaction tx = persistence.createTransaction()
try {
    EntityManager em = persistence.getEntityManager()
    Group group = em.getReference(Group.class, UUID.fromString(&apos;0fa2b1a5-1d68-4d69-9fbd-dff348347f93&apos;))
    for (i in (1..250)) {
        User user = new User()
        user.setGroup(group)
        user.setLogin(&quot;user_${i.toString().padLeft(3, &apos;0&apos;)}&quot;)
        user.setName(user.login)
        user.setPassword(passwordEncryption.getPasswordHash(user.id, &apos;1&apos;));
        em.persist(user)
    }
    tx.commit()
} finally {
    tx.end()
}</programlisting></para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="serverInfoMBean">
          <title>ServerInfoMBean</title>
          <para><code>ServerInfoMBean</code> предоставляет общую информацию о данном блоке <structname>Middleware</structname>: номер и дату сборки, <link linkend="serverId">идентификатор сервера</link>.</para>
          <para>JMX ObjectName: <literal>app-core.cuba:type=ServerInfo</literal></para>
        </section>
      </section>
    </section>
    <section id="infrastructure_interfaces">
      <title>Интерфейсы инфраструктуры</title>
      <para>Интерфейсы инфраструктуры обеспечивают доступ к часто используемой функциональности платформы. Большинство из этих интерфейсов расположены в <link linkend="app_modules">модуле</link> <structname>global</structname> и могут быть использованы как на среднем слое, так и в <link linkend="app_tiers">блоках</link> клиентского уровня, но некоторые (например, <code>
          <link linkend="persistence">Persistence</link>
        </code>) доступны только коду среднего слоя.</para>
      <para>Интерфейсы инфраструктуры реализуются бинами <application>Spring Framework</application>, поэтому они могут быть инжектированы в любые другие управляемые компоненты (<link linkend="managed_beans">Managed Beans</link>, <link linkend="services">сервисы среднего слоя</link>, <link linkend="screen_controller">контроллеры</link> экранов универсального пользовательского интерфейса.</para>
      <para>Кроме того, как и любые другие бины, интерфейсы инфраструктуры могут быть получены с помощью статических методов класса <code>AppBeans</code>, и использоваться в неуправляемых компонентах (<glossterm linkend="pojo">POJO</glossterm>, вспомогательных классах и пр.).</para>
      <section id="configuration">
        <title>Configuration</title>
        <para>Позволяет получать ссылки на <link linkend="config_interfaces">конфигурационные интерфейсы</link> там, где невозможна их инжекция.</para>
        <para>Пример:<programlisting language="java">String tempDir = AppBeans.get(Configuration.class).getConfig(GlobalConfig.class).getTempDir();</programlisting></para>
      </section>
      <section id="messages">
        <title>Messages</title>
        <para>Интерфейс <code>Messages</code> обеспечивает получение <link linkend="localization">локализованных строк сообщений</link>.</para>
        <para>Рассмотрим методы интерфейса подробнее.</para>
        <itemizedlist>
          <listitem>
            <para><code>getMessage()</code> - возвращает локализованное сообщение по ключу, имени пакета сообщений и требуемой локали. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя. </para>
            <para>Примеры:<programlisting language="java">@Inject
protected Messages messages;
...
String message1 = messages.getMessage(getClass(), &quot;someMessage&quot;);
String message2 = messages.getMessage(&quot;com.abc.sales.web.customer&quot;, &quot;someMessage&quot;);
String message3 = messages.getMessage(RoleType.STANDARD);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>formatMessage()</code> - находит локализованное сообщение по ключу, имени пакета сообщений и требуемой локали, и использует его для форматирования переданных параметров. Формат задается по правилам метода <code>String.format()</code>. Существует несколько модификаций данного метода в зависимости от набора параметров. Если локаль не указана в параметре метода, используется локаль текущего пользователя.</para>
            <para>Пример:<programlisting language="java">String formattedValue = messages.formatMessage(getClass(), &quot;someFormat&quot;, someValue);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getMainMessage()</code> - возвращает локализованное сообщение из <link linkend="main_message_pack">главного пакета</link> данного <link linkend="app_tiers">блока</link> приложения.</para>
            <para>Пример:<programlisting language="java">protected Messages messages = AppBeans.get(Messages.class);
...
messages.getMainMessage(&quot;actions.Ok&quot;);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getMainMessagePack()</code> - возвращает имя <link linkend="main_message_pack">главного пакета</link> сообщений данного блока приложения.</para>
            <para>Пример:<programlisting language="java">String formattedValue = messages.formatMessage(messages.getMainMessagePack(), &quot;someFormat&quot;, someValue);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>MessageTools</code>  (см. ниже).</para>
          </listitem>
        </itemizedlist>
        <section id="messageTools">
          <title>MessageTools</title>
          <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с <link linkend="localization">локализованными сообщениями</link>. Интерфейс <code>MessageTools</code> можно получить либо методом <code>Messages.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>. </para>
          <para>Методы <code>MessageTools</code>:<itemizedlist>
              <listitem id="messageTools.loadString">
                <para><code>loadString()</code> - возвращает локализованное сообщение, заданное ссылкой вида <literal>msg://{messagePack}/{key}</literal>.</para>
                <para>Составные части ссылки:<itemizedlist>
                    <listitem>
                      <para><literal>msg://</literal> - обязательный префикс.</para>
                    </listitem>
                    <listitem>
                      <para><literal>{messagePack}</literal> - необязательное имя пакета сообщения. Если не указано, предполагается, что имя пакета передается в <code>loadString()</code> отдельным параметром.</para>
                    </listitem>
                    <listitem>
                      <para><literal>{key}</literal> - ключ сообщения в пакете.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Примеры ссылок на сообщения:<programlisting>msg://someMessage
msg://com.abc.sales.web.customer/someMessage</programlisting></para>
              </listitem>
              <listitem>
                <para><code>getEntityCaption()</code> - возвращает локализованное название сущности.</para>
              </listitem>
              <listitem>
                <para><code>getPropertyCaption()</code> - возвращает локализованное название атрибута сущности.</para>
              </listitem>
              <listitem>
                <para><code>hasPropertyCaption()</code> - определяет, задано ли для атрибута сущности локализованное название. </para>
              </listitem>
              <listitem>
                <para><code>getLocValue()</code> - возвращает локализованное значение атрибута сущности, основываясь на определении аннотации <code>
                    <link linkend="localizedValue_annotation">@LocalizedValue</link>
                  </code>.</para>
              </listitem>
              <listitem>
                <para><code>getMessageRef()</code> - формирует для <link linkend="metaProperty">мета-свойства</link> <link linkend="messageTools.loadString">ссылку на сообщение</link>, по которой  можно получить локализованное название атрибута сущности.</para>
              </listitem>
              <listitem>
                <para><code>getDefaultLocale()</code> - возвращает локаль приложения по умолчанию, то есть указанную первой в списке свойства <link linkend="cuba.availableLocales">
                    <property>cuba.availableLocales</property>
                  </link>.</para>
              </listitem>
              <listitem>
                <para><code>useLocaleLanguageOnly()</code> - возвращает <code>true</code>, если в списке поддерживаемых приложением локалей, заданном свойством <link linkend="cuba.availableLocales">
                    <property>cuba.availableLocales</property>
                  </link>, для всех локалей определен  только язык, а <code>country</code> и <code>variant</code> не указаны. Этим методом пользуются механизмы платформы, которым необходимо найти наиболее подходящую локаль из списка поддерживаемых на основе локали, полученной  из внешних источников, таких как операционная система или HTTP запрос.</para>
              </listitem>
              <listitem>
                <para><code>trimLocale()</code> - удаляет из переданной локали все кроме языка, если метод <code>useLocaleLanguageOnly()</code> возвращает <code>true</code>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>MessageTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting language="java">MyMessageTools tools = messages.getTools();
tools.foo();</programlisting><programlisting language="java">((MyMessageTools) messages.getTools()).foo();</programlisting> </para>
        </section>
      </section>
      <section id="metadata">
        <title>Metadata</title>
        <para>Интерфейс <code>Metadata</code> обеспечивает доступ к сессии <link linkend="metadata_framework">метаданных</link> и репозиторию <link linkend="views">представлений</link>.</para>
        <para>Методы интерфейса:<itemizedlist>
            <listitem>
              <para><code>getSession()</code> - возвращает экземпляр сессии <link linkend="metadata_framework">метаданных</link> </para>
            </listitem>
            <listitem>
              <para><code>getViewRepository()</code> - возвращает экземпляр репозитория <link linkend="views">представлений</link></para>
            </listitem>
            <listitem>
              <para><code>getExtendedEntities()</code> - возвращает экземпляр <code>ExtendedEntities</code>, предназначенный для работы с расширенными сущностями. Подробнее см. <xref linkend="entity_extension"/></para>
            </listitem>
            <listitem>
              <para><code>create()</code> - создать экземпляр сущности, учитывая возможность расширения. Подробнее см. <xref linkend="entity_extension"/> </para>
            </listitem>
            <listitem>
              <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>MetadataTools</code>  (см. ниже).</para>
            </listitem>
          </itemizedlist></para>
        <section>
          <title>MetadataTools</title>
          <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с метаданными. Интерфейс <code>MetadataTools</code> можно получить либо методом <code>Metadata.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>.</para>
          <para>Методы <code>MetadataTools</code>:<itemizedlist>
              <listitem>
                <para><code>getAllPersistentMetaClasses()</code> - возвращает коллекцию <link linkend="metaClass">мета-классов</link> персистентных сущностей</para>
              </listitem>
              <listitem>
                <para><code>getAllEmbeddableMetaClasses()</code> - возвращает коллекцию <link linkend="metaClass">мета-классов</link> встраиваемых сущностей</para>
              </listitem>
              <listitem>
                <para><code>getAllEnums()</code> - возвращает коллекцию классов перечислений, используемых в качестве типов атрибутов сущностей</para>
              </listitem>
              <listitem>
                <para><code>format()</code> - форматирует переданное значение в соответствии с типом данных заданного <link linkend="metaProperty">мета-свойства</link></para>
              </listitem>
              <listitem>
                <para><code>isSystem()</code> - определяет, является ли переданное <link linkend="metaProperty">мета-свойство</link> системным, т.е. заданным в одном из <link linkend="entity_base_classes">базовых интерфейсов сущностей</link></para>
              </listitem>
              <listitem>
                <para><code>isPersistent()</code> - определяет, является ли переданное мета-свойство персистентным, т.е. хранимым в БД</para>
              </listitem>
              <listitem>
                <para><code>isTransient()</code> - определяет, является ли переданное мета-свойство или произвольный атрибут неперсистентным</para>
              </listitem>
              <listitem>
                <para><code>isEmbedded()</code> - определяет, является ли переданное мета-свойство встроенным объектом</para>
              </listitem>
              <listitem>
                <para><code>isAnnotationPresent()</code> - определяет наличие указанной аннотации на классе или его предках</para>
              </listitem>
              <listitem>
                <para><code>getNamePatternProperties()</code> - возвращает коллекцию мета-свойств атрибутов, входящих в  имя экземпляра, возвращаемого методом <code>Instance.getInstanceName()</code>. См. <code>
                    <link linkend="namePattern">@NamePattern</link>
                  </code>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>MetadataTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting language="java">MyMetadataTools tools = metadata.getTools();
tools.foo();</programlisting><programlisting language="java">((MyMetadataTools) metadata.getTools()).foo();</programlisting></para>
        </section>
      </section>
      <section id="resources">
        <title>Resources</title>
        <para>Обеспечивает загрузку ресурсов по следующим правилам:<orderedlist>
            <listitem>
              <para>если указанное местонахождение представляет собой URL, ресурс загружается из этого URL;</para>
            </listitem>
            <listitem>
              <para>если указанное местонахождение начинается с префикса <literal>classpath:</literal>, ресурс загружается из classpath;</para>
            </listitem>
            <listitem>
              <para>если не URL и не начинается с <literal>classpath:</literal>, то:<orderedlist>
                  <listitem>
                    <para>в <link linkend="conf_dir">каталоге конфигурации</link> приложения ищется файл, используя указанное местонахождение как относительный путь. Если файл найден, ресурс загружается из него;</para>
                  </listitem>
                  <listitem>
                    <para>если ресурс не найден на предыдущих этапах, он загружается из classpath.</para>
                  </listitem>
                </orderedlist></para>
            </listitem>
          </orderedlist></para>
        <para>На практике явное указание URL или префикса <code>classpath:</code> используется редко, т.е. обычно ресурсы загружаются либо из <link linkend="conf_dir">конфигурационного каталога</link>, либо из classpath. Ресурс в конфигурационном каталоге замещает одноименный ресурс в classpath.</para>
        <para>Методы <code>Resources</code>:<itemizedlist>
            <listitem>
              <para><code>getResourceAsStream()</code> - возвращает <code>InputStream</code> для указанного ресурса, либо <code>null</code>, если ресурс не найден. Поток должен быть закрыт после использования, например:<programlisting language="java">@Inject
protected Resources resources;
...
InputStream stream = null;
try {
    stream = resources.getResourceAsStream(resourceLocation);
    ...
} finally {
    IOUtils.closeQuietly(stream);
}</programlisting></para>
              <para>Возможно использование &quot;try with resources&quot;:<programlisting language="java">try (InputStream stream = resources.getResourceAsStream(resourceLocation)) {
    ...
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getResourceAsString()</code> - возвращает указанный ресурс в виде строки, либо <code>null</code>, если ресурс не найден</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="scripting">
        <title>Scripting</title>
        <para>Интерфейс <code>Scripting</code> позволяет динамически (т.е. во время работы приложения) компилировать и загружать классы Java и Groovy, а также выполнять скрипты и выражения на Groovy.</para>
        <para>Методы <code>Scripting</code>:<itemizedlist>
            <listitem>
              <para><code>evaluateGroovy()</code> - выполняет выражение на Groovy и возвращает его результат. </para>
              <para>Свойство приложения <property>
                  <link linkend="cuba.groovyEvaluatorImport">cuba.groovyEvaluatorImport</link>
                </property> позволяет определить общий набор импортируемых классов, подставляемых в каждое выполняемое выражение. По умолчанию все стандартные блоки приложения импортируют класс <code>
                  <link linkend="persistenceHelper">PersistenceHelper</link>
                </code>.</para>
              <para>Скомпилированные выражения кэшируются, что значительно ускоряет повторное выполнение.</para>
              <para>Пример:<programlisting language="java">@Inject
protected Scripting scripting;
...
Integer intResult = scripting.evaluateGroovy(&quot;2 + 2&quot;, new Binding());

Binding binding = new Binding();
binding.setVariable(&quot;instance&quot;, new User());
Boolean boolResult = scripting.evaluateGroovy(&quot;return PersistenceHelper.isNew(instance)&quot;, binding);</programlisting></para>
            </listitem>
            <listitem id="scripting.runGroovyScript">
              <para><code>runGroovyScript()</code> - выполняет скрипт Groovy и возвращает его результат.</para>
              <para>Скрипт должен быть расположен либо в <link linkend="conf_dir">конфигурационном каталоге</link> приложения, либо в classpath (текущая реализация <code>Scripting</code> поддерживает ресурсы classpath только внутри JAR-файлов). Скрипт в конфигурационном каталоге замещает одноименный скрипт в classpath.</para>
              <para>Путь к скрипту указывается с разделителями <literal>/</literal>, в начале пути символ <literal>/</literal> не требуется.</para>
              <para>Пример:<programlisting language="java">@Inject
protected Scripting scripting;
...
Binding binding = new Binding();
binding.setVariable(&quot;itemId&quot;, itemId);
BigDecimal amount = scripting.runGroovyScript(&quot;com/abc/sales/CalculatePrice.groovy&quot;, binding);</programlisting></para>
            </listitem>
            <listitem>
              <para><code>loadClass()</code> - загружает Java или Groovy класс, используя следующую последовательность действий:<orderedlist>
                  <listitem>
                    <para>Если класс уже загружен, возвращает его.</para>
                  </listitem>
                  <listitem>
                    <para>Ищет исходный текст Groovy (файл <filename>*.groovy</filename>) в каталоге конфигурации. Если найден, компилирует его, загружает  и возвращает класс.</para>
                  </listitem>
                  <listitem>
                    <para>Ищет исходный текст Java (файл <filename>*.java</filename>) в каталоге конфигурации. Если найден, компилирует его, загружает и возвращает класс.</para>
                  </listitem>
                  <listitem>
                    <para>Ищет скомпилированный класс в classpath, если найден - загружает и возвращает его.</para>
                  </listitem>
                  <listitem>
                    <para>Если ничего не найдено, возвращает <code>null</code>.</para>
                  </listitem>
                </orderedlist></para>
              <para>Файлы исходных текстов Java и Groovy  в каталоге конфигурации можно изменять во время работы приложения. При следующем вызове <code>loadClass()</code> соответствующий класс будет перекомпилирован и возвращен новый, однако существуют следующие ограничения:<itemizedlist>
                  <listitem>
                    <para>нельзя изменять тип исходного текста с Groovy на Java</para>
                  </listitem>
                  <listitem>
                    <para>если существовал исходный текст Groovy, и был однажды скомпилирован, то удаление файла исходного текста не приведет к загрузке другого класса из classpath - будет по-прежнему возвращаться класс, скомпилированный из  удаленного исходника.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="java">@Inject
protected Scripting scripting;
...
Class calculatorClass = scripting.loadClass(&quot;com.abc.sales.PriceCalculator&quot;);</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getClassLoader()</code> - возвращает <code>ClassLoader</code>, способный работать по правилам, описанным выше для метода <code>loadClass()</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Кэш скомпилированных классов можно очистить во время выполнения с помощью JMX-бина  <link linkend="cachingFacadeMBean">CachingFacadeMBean</link>.</para>
        <para>См. также <xref linkend="scriptingManagerMBean"/></para>
      </section>
      <section id="security">
        <title>Security</title>
        <para>Обеспечивает авторизацию - проверку прав пользователя на различные объекты системы. Перед вызовом соответствующих методов <link linkend="userSession">UserSession</link> выполняется поиск исходного мета-класса сущности, что является важным при наличии <link linkend="entity_extension">расширений</link>. Кроме методов, дублирующих методы <code>UserSession</code>, данный интерфейс имеет методы <code>isEntityAttrReadPermitted()</code> и <code>isEntityAttrUpdatePermitted()</code>, предназначенные для определения доступности пути к атрибуту с учетом доступности атрибутов и сущностей, входящих в этот путь.</para>
        <para>Подробнее см. <xref linkend="authentication"/></para>
      </section>
      <section id="timeSource">
        <title>TimeSource</title>
        <para>Обеспечивает получение текущего времени. Применение <code>new Date()</code> и т.п. в прикладном коде не рекомендуется.</para>
        <para>Примеры:<programlisting language="java">@Inject
protected TimeSource timeSource;
...
Date date = timeSource.currentTimestamp();</programlisting><programlisting language="java">long startTime = AppBeans.get(TimeSource.class).currentTimeMillis();</programlisting></para>
      </section>
      <section id="userSessionSource">
        <title>UserSessionSource</title>
        <para>Обеспечивает получение объекта сессии текущего пользователя. Подробнее см. <xref linkend="authentication"/></para>
      </section>
      <section>
        <title>UuidSource</title>
        <para>Обеспечивает получение значений <code>UUID</code>, в том числе для идентификаторов сущностей. Применение <code>UUID.randomUUID()</code> в прикладном коде не рекомендуется.</para>
        <para>Для вызова из статического контекста можно использовать класс <code>UuidProvider</code>, который имеет также дополнительный метод <code>fromString()</code>, работающий быстрее, чем стандартный метод <code>UUID.fromString()</code>.</para>
      </section>
    </section>
    <section id="appContext">
      <title>AppContext</title>
      <para><code>AppContext</code> - системный класс, в статических полях которого хранятся ссылки на некоторые общие для любого <link linkend="app_tiers">блока</link> приложения компоненты:<itemizedlist>
          <listitem>
            <para><code>ApplicationContext</code> фреймворка <application>Spring</application></para>
          </listitem>
          <listitem>
            <para>Набор <link linkend="app_properties">свойств приложения</link>, загруженных из файлов <filename>app.properties</filename></para>
          </listitem>
          <listitem>
            <para><code>ThreadLocal</code> переменная, хранящая экземпляры <code>SecurityContext</code></para>
          </listitem>
          <listitem>
            <para>Коллекция слушателей жизненного цикла приложения (<code>AppContext.Listener</code>)</para>
          </listitem>
        </itemizedlist></para>
      <para><code>AppContext</code> инициализируется на запуске приложения классами-загрузчиками, специфичными для типа <link linkend="app_tiers">блока</link> приложения:<itemizedlist>
          <listitem>
            <para>загрузчик <structname>Middleware</structname> - <code>AppContextLoader</code></para>
          </listitem>
          <listitem>
            <para>загрузчик <structname>Web Client</structname> - <code>WebAppContextLoader</code></para>
          </listitem>
          <listitem>
            <para>загрузчик <structname>Web Portal</structname> - <code>PortalAppContextLoader</code></para>
          </listitem>
          <listitem>
            <para>загрузчик <structname>Desktop Client</structname> - <code>DesktopAppContextLoader</code></para>
          </listitem>
        </itemizedlist></para>
      <para><code>AppContext</code> может быть использован в прикладном коде для решения следующих задач:<itemizedlist>
          <listitem>
            <para>Регистрации слушателей, срабатывающих после полной инициализации и перед закрытием приложения, например:<programlisting language="java">AppContext.addListener(new AppContext.Listener() {
    @Override
    public void applicationStarted() {
        System.out.println(&quot;Application is ready&quot;);
    }

    @Override
    public void applicationStopped() {
        System.out.println(&quot;Application is closing&quot;);
    }
});</programlisting></para>
            <para>В момент вызова <code>applicationStarted()</code>:<itemizedlist>
                <listitem>
                  <para>Полностью инициализированы все <link linkend="managed_beans">бины</link>, в том числе выполнены их методы <code>@PostConstruct</code>.</para>
                </listitem>
                <listitem>
                  <para>Можно использовать статические методы получения бинов <code>AppBeans.get()</code>.</para>
                </listitem>
                <listitem>
                  <para>Метод <code>AppContext.isStarted()</code> возвращает <code>true</code>.</para>
                </listitem>
                <listitem>
                  <para>В блоке Middleware: если свойство приложения <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link> включено, все скрипты обновления БД успешно выполнены.</para>
                </listitem>
              </itemizedlist></para>
            <para>В момент вызова <code>applicationStopped()</code>:<itemizedlist>
                <listitem>
                  <para>Все бины работоспособны и доступны через статические методы <code>AppBeans.get()</code>.</para>
                </listitem>
                <listitem>
                  <para>Метод <code>AppContext.isStarted()</code> возвращает <code>false</code>.</para>
                </listitem>
              </itemizedlist></para>
            <para>Практический пример использования <code>AppContext.Listener</code> см. в <xref linkend="app_start_recipe"/>.</para>
          </listitem>
          <listitem>
            <para>Проверки того, что данный <link linkend="app_tiers">блок</link> приложения полностью инициализирован и готов к выполнению. Такая проверка обычно необходима в методах бинов, автоматически запускаемых <link linkend="scheduled_tasks_spring">планировщиком</link> <application>Spring</application>.</para>
            <para>Пример:<programlisting language="java">if (!AppContext.isStarted())
    return;</programlisting></para>
          </listitem>
          <listitem>
            <para>Получения значений <link linkend="app_properties">свойств приложения</link>, хранимых в файлах <filename>app.properties</filename>, если они недоступны через <link linkend="config_interfaces">конфигурационные интерфейсы</link>.</para>
          </listitem>
          <listitem>
            <para>Передачи <code>SecurityContext</code> в новые потоки выполнения, см. <xref linkend="authentication"/>.</para>
          </listitem>
        </itemizedlist></para>
      <tip>
        <para>Для получения ссылок на <application>Spring</application>-бины используйте инжекцию или статические методы класса <code>AppBeans</code>.</para>
        <para>Использование <code>AppContext.getApplicationContext().getBean()</code> не рекомендуется.</para>
      </tip>
    </section>
    <section id="app_properties">
      <title>Свойства приложения</title>
      <para>Свойства приложения − именованные данные различных типов, определяющие всевозможные аспекты конфигурации и функционирования приложения.</para>
      <para>По назначению свойства приложения можно классифицировать следующим образом:</para>
      <itemizedlist>
        <listitem>
          <para><firstterm>Конфигурационные параметры</firstterm> - задают наборы конфигурационных файлов и некоторые параметры пользовательского интерфейса, т.е. определяют функциональность приложения. </para>
          <para>Например: <property>cuba.springContextConfig</property>, <property>cuba.web.useLightHeader</property>.</para>
        </listitem>
        <listitem>
          <para><firstterm>Параметры развертывания</firstterm> - различные URL для соединения <link linkend="app_tiers">блоков</link> приложения, тип используемой БД, настройки подсистемы безопасности и т.д. </para>
          <para>Например: <property>cuba.connectionUrlList</property>, <property>cuba.dbmsType</property>, <property>
              <link linkend="cuba.userSessionExpirationTimeoutSec">cuba.userSessionExpirationTimeoutSec</link>
            </property>.</para>
        </listitem>
        <listitem>
          <para><firstterm>Параметры времени выполнения</firstterm> - активность аудита, параметры отсылки email и т.д. </para>
          <para>Например: <property>cuba.security.EntityLog.enabled</property>, <property>cuba.email.smtpHost</property>.</para>
        </listitem>
      </itemizedlist>
      <para>Как правило, некоторое свойство принадлежит только одному или нескольким <link linkend="app_tiers">блокам</link> приложения. Например, <property>
          <link linkend="cuba.persistenceConfig">cuba.persistenceConfig</link>
        </property> имеет смысл только для <structname>Middleware</structname>, <property> cuba.web.useLightHeader</property> − только для <structname>Web Client</structname>, а <property>
          <link linkend="cuba.springContextConfig">cuba.springContextConfig</link>
        </property> − для всех блоков. </para>
      <para>Принадлежность к блоку означает, что если нужно задать значение некоторому свойству, это необходимо сделать <emphasis>во всех блоках</emphasis>, которым данное свойство принадлежит (и которые используются в приложении). </para>
      <para>Принадлежность можно выяснить следующими способами:<itemizedlist>
          <listitem>
            <para>Из документации: см. <xref linkend="app_properties_reference"/> </para>
          </listitem>
          <listitem>
            <para>Проследив использование свойства в коде приложения</para>
          </listitem>
          <listitem>
            <para>Если к свойству есть доступ через <link linkend="config_interfaces">конфигурационный интерфейс</link>, то по принадлежности интерфейса <link linkend="app_modules">модулю</link> проекта.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Доступ к свойствам</title>
        <para>Основной способ доступа к свойствам приложения из прикладного кода − использование механизма <link linkend="config_interfaces">конфигурационных интерфейсов</link>. Кроме того, все параметры конфигурации и развертывания доступны через методы класса <code>
            <link linkend="appContext">AppContext</link>
          </code>.</para>
        <para>Некоторые блоки приложения определяют JMX-интерфейсы для доступа к свойствам приложения. В частности, в блоках <structname>Middleware</structname>, <structname>Web Client</structname> и <structname>Web Portal</structname> имеется JMX-интерфейс <code>
            <link linkend="configStorageMBean">ConfigStorageMBean</link>
          </code>, позволяющий получить и задать значение любого свойства во время работы приложения. </para>
      </section>
      <section id="app_properties_files">
        <title>Хранение свойств в файлах</title>
        <para>Свойства, определяющие конфигурацию и параметры развертывания, задаются в специальных файлах свойств, имеющих имя вида <filename>*-app.properties</filename>. Каждый <link linkend="app_tiers">блок</link> приложения имеет набор таких файлов, включающий в себя файлы из <link linkend="base_projects">базовых проектов</link> платформы и файл текущего приложения. Набор файлов свойств  определяется следующим образом:</para>
        <itemizedlist>
          <listitem>
            <para>Для блоков, являющихся веб-приложениями (<structname>Middleware</structname>, <structname>Web Client</structname>, <structname>Web Portal</structname>) набор файлов свойств задается в <filename>web.xml</filename> в параметре <literal>appPropertiesConfig</literal>.</para>
          </listitem>
          <listitem>
            <para>Для блока <structname>Desktop Client</structname> основной способ задания набора файлов свойств − переопределение в приложении метода <methodname>getDefaultAppPropertiesConfig()</methodname> в классе-наследнике <code>com.haulmont.cuba.desktop.App</code>.</para>
          </listitem>
        </itemizedlist>
        <para>Например, набор файлов свойств блока <structname>Middleware</structname> проекта <application>sales</application> задается в файле  <filename>web/WEB-INF/web.xml</filename>  модуля <structname>core</structname>, и выглядит следующим образом:</para>
        <programlisting>classpath:cuba-app.properties
classpath:app.properties
file:${catalina.home}/conf/app-core/local.app.properties</programlisting>
        <para>Здесь префикс <literal>classpath:</literal> означает, что данный файл нужно искать в Java classpath, префикс <literal>file:</literal> − в файловой системе. Возможно использование системных свойств Java, в данном случае это <literal>catalina.home</literal> − путь к корню <application>Tomcat</application>.</para>
        <para>Порядок перечисления файлов важен, так как значения, указанные в каждом последующем файле заменяют значения одноименных свойств, заданные в предыдущих файлах. Этим достигается переопределение свойств платформы в конкретном приложении.</para>
        <para>Последний файл в приведенном наборе − <filename>local.app.properties</filename>. Он может использоваться для переопределения свойств приложения при развертывании. Если этого файла нет, он игнорируется. Если же во время инсталляции системы требуется переопределение некоторых параметров (как правило, различных URL), достаточно создать этот файл и поместить в него переопределяемые свойства. При последующих обновлениях системы такой файл с локальными настройками легко сохранить.</para>
        <para>Аналогом <filename>local.app.properties</filename> для <structname>Desktop Client</structname> служат аргументы командной строки запуска JVM. Загрузчик свойств данного блока воспринимает все аргументы, содержащие знак &quot;<literal>=</literal>&quot;, как пары ключ-значение, и заменяет ими соответствующие свойства приложения, заданные в файлах <filename>app.properties</filename>.</para>
        <tip>
          <para>Правила задания информации в файлах  <filename>*.properties</filename>:</para>
          <itemizedlist>
            <listitem>
              <para>Кодировка файла - <literal>UTF-8</literal></para>
            </listitem>
            <listitem>
              <para>Ключ может состоять из латинских букв, цифр, точек  и знаков подчеркивания</para>
            </listitem>
            <listitem>
              <para>Значение пишется после знака равно (<literal>=</literal>)</para>
            </listitem>
            <listitem>
              <para>Значение  не нужно брать в кавычки &quot; или &apos;</para>
            </listitem>
            <listitem>
              <para>Файловые пути записываются либо в UNIX виде (<filename>/opt/haulmont/</filename>), либо в Windows виде (<filename>c:\\haulmont\\</filename>)</para>
            </listitem>
            <listitem>
              <para>Возможно использование кодов <literal>\n \t \r</literal>. Символ <literal>\</literal>  является зарезервированным, для вставки в значение экранируется сам собой (<literal>\\</literal>).
Подробнее см.: <ulink url="http://docs.oracle.com/javase/tutorial/java/data/characters.html">http://docs.oracle.com/javase/tutorial/java/data/characters.html</ulink></para>
            </listitem>
            <listitem>
              <para>Для ввода значения в нескольких строках файла используйте символ <literal>\</literal> в конце строки, для того чтобы данное значение продолжалось на следующей строке.</para>
            </listitem>
          </itemizedlist>
        </tip>
      </section>
      <section>
        <title>Хранение свойств в базе данных</title>
        <para>Параметры времени выполнения хранятся в таблице <database>SYS_CONFIG</database> базы данных. </para>
        <para>Такие свойства имеют следующие особенности:<itemizedlist>
            <listitem>
              <para>так как значение свойства хранится в базе данных, оно задается в одном месте, независимо от того, в каких  блоках приложения оно используется</para>
            </listitem>
            <listitem>
              <para>значение может быть изменено и сохранено во время работы приложения, как через <link linkend="config_interfaces">конфигурационный интерфейс</link>, содержащий это свойство, так и через <link linkend="configStorageMBean">ConfigStorageMBean</link>.</para>
            </listitem>
            <listitem>
              <para>значение свойства может быть переопределено для конкретного блока приложения в его файле <filename>app.properties</filename>. Поиск значения всегда происходит в два этапа - сначала в <filename>app.properties</filename>, если не найдено - то в базе данных. Поэтому изменять значение нужно в обоих местах хранения.</para>
            </listitem>
          </itemizedlist></para>
        <para>Хранящиеся в БД свойства кэшируются на уровне <structname>Middleware</structname>. Очистить кэш можно с помощью JMX-интерфейсов <code>
            <link linkend="configStorageMBean">ConfigStorageMBean</link>
          </code> методом <code>clearCache()</code> или <code>
            <link linkend="cachingFacadeMBean">CachingFacadeMBean</link>
          </code> методом <code>clearConfigStorageCache()</code>.</para>
        <para>Следует иметь в виду, что на клиентском уровне чтение свойства, хранящегося в БД, приводит к запросу к <structname>Middleware</structname>, что менее эффективно, чем чтение локального свойства из <filename>app.properties</filename>. Для уменьшения количества таких запросов клиент кэширует все свойства, хранящиеся в БД, на время жизни экземпляра реализации конфигурационного интерфейса. Поэтому если, например, в некотором экране UI необходимо несколько раз обратиться к свойствам одного конфигурационного интерфейса, лучше получить ссылку на него при инициализации экрана, и сохранить в поле для последующих обращений к одному и тому же экземпляру. </para>
      </section>
      <section id="config_interfaces">
        <title>Конфигурационные интерфейсы</title>
        <para>Данный механизм позволяет работать  со свойствами приложения через методы Java-интерфейсов, что дает следующие преимущества:<itemizedlist>
            <listitem>
              <para>типизированность - прикладной код работает с нужными типами (String, Boolean, Integer и пр.), а не только со строками</para>
            </listitem>
            <listitem>
              <para>в прикладном коде вместо строковых идентификаторов свойств используются методы интерфейсов, имена которых подсказываются средой разработки</para>
            </listitem>
          </itemizedlist></para>
        <para>Пример получения значения таймаута транзакции в блоке <structname>Middleware</structname>:<programlisting language="java">@Inject
private ServerConfig serverConfig;

public void doSomething() {
    int timeout = serverConfig.getDefaultQueryTimeoutSec();
    ...
}</programlisting></para>
        <para>При невозможности инжекции можно получить ссылку на конфигурационный интерфейс через <link linkend="configuration">Configuration</link>:<programlisting language="java">int timeout = AppBeans.get(Configuration.class)
    .getConfig(ServerConfig.class)
    .getDefaultQueryTimeoutSec();</programlisting></para>
        <warning>
          <para>Конфигурационные интерфейсы не являются нормальными бинами Spring, не пытайтесь получить их через <code>AppBeans.get()</code> - только непосредственной  инжекцией самого интерфейса  или через <code>Configuration.getConfig()</code>.</para>
        </warning>
        <section>
          <title>Использование</title>
          <para>Для создания конфигурационного интерфейса необходимо:</para>
          <itemizedlist>
            <listitem>
              <para>Создать интерфейс, унаследованный от <code>com.haulmont.cuba.core.config.Config</code> (не путать с классом сущности <code>com.haulmont.cuba.core.entity.Config</code>)</para>
            </listitem>
            <listitem>
              <para>Добавить интерфейсу  аннотацию <code>@Source</code> для указания источника (способа хранения) параметров:<itemizedlist>
                  <listitem>
                    <para><code>SourceType.SYSTEM</code> - значение свойства будет взято из системных свойств данной JVM, т.е. методом <code> System.getProperty()</code></para>
                  </listitem>
                  <listitem>
                    <para><code>SourceType.APP</code> - значение свойства будет взято из файлов <filename>app.properties</filename></para>
                  </listitem>
                  <listitem>
                    <para><code>SourceType.DATABASE</code> - значение свойства будет взято из таблицы <database>SYS_CONFIG</database></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Создать методы доступа к свойству (getter / setter). Если значение свойства не предполагается изменять во время выполнения, метод доступа на запись не нужен. Возможный тип свойства рассмотрен ниже.</para>
            </listitem>
            <listitem>
              <para>Добавить методу доступа на чтение аннотацию <code>@Property</code>, определяющую имя свойства.</para>
            </listitem>
            <listitem>
              <para>Опционально аннотацию <code>@Source</code> можно задать для отдельного свойства в интерфейсе, если его источник отличается от заданного для всего интерфейса.</para>
            </listitem>
          </itemizedlist>
          <para>Например:<programlisting language="java">@Source(type = SourceType.DATABASE)
public interface SalesConfig extends Config {

    @Property(&quot;sales.companyName&quot;)
    String getCompanyName();
}</programlisting></para>
          <para>Создавать класс реализации конфигурационного интерфейса не нужно - при получении ссылки на интерфейс через <link linkend="configuration">Configuration</link> будет автоматически создан необходимый прокси-объект.</para>
        </section>
        <section id="config_interface_property_types">
          <title>Типы свойств</title>
          <para>Без дополнительных усилий поддерживаются следующие типы свойств: <itemizedlist>
              <listitem>
                <para><code>String</code>, простые типы либо их объектные обертки (<code>boolean</code>, <code>Boolean</code>, <code>int</code>, <code>Integer</code>, etc.).</para>
              </listitem>
              <listitem>
                <para>Перечисления (<code>enum</code>). Значение свойства сохраняется в файле или БД в виде имени значения перечисления.</para>
                <para>Если перечисление реализует интерфейс <code>EnumClass</code> и имеет статический метод <code>fromId()</code> для получения значения по идентификатору, с помощью аннотации <code>@EnumStore</code> можно задать хранение значения в виде  идентификатора. Например:<programlisting language="java">@Property(&quot;myapp.defaultCustomerGrade&quot;)
@DefaultInteger(10)
@EnumStore(EnumStoreMode.ID)
CustomerGrade getDefaultCustomerGrade();

@EnumStore(EnumStoreMode.ID)
void setDefaultCustomerGrade(CustomerGrade grade);</programlisting></para>
              </listitem>
              <listitem>
                <para>Классы персистентных <link linkend="data_model">сущностей</link>. При обращении к свойству типа сущности происходит загрузка из БД экземпляра, заданного значением свойства.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для поддержки произвольного типа необходимо реализовать классы <code>TypeStringify</code> и <code>TypeFactory</code> для преобразования значения в строку и из нее, и указать эти классы для свойства с помощью аннотаций <code>@Stringify</code> и <code>@Factory</code>.</para>
          <para>Рассмотрим этот процесс на примере типа <code>UUID</code>.</para>
          <itemizedlist>
            <listitem>
              <para>Создаем класс <code>com.haulmont.cuba.core.config.type.UuidTypeFactory</code> унаследованный от <code>com.haulmont.cuba.core.config.type.TypeFactory</code> и реализуем в нем метод:<programlisting language="java">public Object build(String string) {
    if (string == null)
        return null;
    return UUID.fromString(string);
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>TypeStringify</code> создавать не нужно, т.к. по умолчанию будет использован метод <code>toString()</code> − в данном случае он нам подходит.</para>
            </listitem>
            <listitem>
              <para>Аннотируем свойство в конфигурационном интерфейсе:<programlisting language="java">@Factory(factory = UuidTypeFactory.class)
UUID getUuidProp();
void setUuidProp(UUID value);</programlisting></para>
            </listitem>
          </itemizedlist>
          <para>В платформе определены реализации <code>TypeFactory</code> для следующих типов:<itemizedlist>
              <listitem>
                <para><code>UUID</code> - <code>UuidTypeFactory</code>, описано выше.</para>
              </listitem>
              <listitem>
                <para><code>java.util.Date</code> - <code>DateFactory</code>. Значение даты должно быть указано в формате <code>yyyy-MM-dd HH:mm:ss.SSS</code>, например:<programlisting>cuba.test.dateProp = 2013-12-12 00:00:00.000</programlisting></para>
              </listitem>
              <listitem>
                <para><code>List&lt;Integer&gt;</code> (список целых чисел) - <code>IntegerListTypeFactory</code>. Значение свойства должно быть указано в виде списка чисел, разделенных пробелами, например:<programlisting>cuba.test.integerListProp = 1 2 3</programlisting></para>
              </listitem>
              <listitem>
                <para><code>List&lt;String&gt;</code> (список строк) - <code>StringListTypeFactory</code>. Значение свойства должно быть указано в виде списка строк, разделенных символом &quot;|&quot;, например:<programlisting>cuba.test.stringListProp = aaa|bbb|ccc</programlisting></para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section>
          <title>Значения по умолчанию</title>
          <para>Для свойств конфигурационных интерфейсов могут быть заданы значения по умолчанию. Эти значения будут возвращаться вместо <code>null</code>, если данный параметр не задан в месте хранения - в БД или в <filename>app.properties</filename>.</para>
          <para>Значение по умолчанию может быть задано в виде строки с помощью аннотации <code>@Default</code>, либо в виде конкретного типа с помощью других аннотаций пакета <code>com.haulmont.cuba.core.config.defaults</code>:<programlisting language="java">@Property(&quot;cuba.email.adminAddress&quot;)
@Default(&quot;address@company.com&quot;)
String getAdminAddress();

@Property(&quot;cuba.email.delayCallCount&quot;)
@Default(&quot;2&quot;)
int getDelayCallCount();

@Property(&quot;cuba.email.defaultSendingAttemptsCount&quot;)
@DefaultInt(10)
int getDefaultSendingAttemptsCount();

@Property(&quot;cuba.test.dateProp&quot;)
@Default(&quot;2013-12-12 00:00:00.000&quot;)
@Factory(factory = DateFactory.class)
Date getDateProp();

@Property(&quot;cuba.test.integerList&quot;)
@Default(&quot;1 2 3&quot;)
@Factory(factory = IntegerListTypeFactory.class)
List&lt;Integer&gt; getIntegerList();

@Property(&quot;cuba.test.stringList&quot;)
@Default(&quot;aaa|bbb|ccc&quot;)
@Factory(factory = StringListTypeFactory.class)
List&lt;String&gt; getStringList();</programlisting></para>
          <para>Для сущностей  значение по умолчанию задается строкой вида <literal>{entity_name}-{id}-{optional_view_name}</literal>, например:<programlisting language="java">@Default(&quot;sec$User-98e5e66c-3ac9-11e2-94c1-3860770d7eaf-browse&quot;)
User getAdminUser();

@Default(&quot;sec$Role-a294aef0-3ac9-11e2-9433-3860770d7eaf&quot;)
Role getAdminRole();</programlisting></para>
        </section>
      </section>
    </section>
    <section id="localization">
      <title>Локализация сообщений</title>
      <para>Приложение на основе платформы CUBA поддерживает локализацию сообщений, то есть вывод всех элементов пользовательского интерфейса на языке, выбранном пользователем.</para>
      <para>Возможности выбора языка пользователем определяются комбинацией свойств приложения <link linkend="cuba.localeSelectVisible">cuba.localeSelectVisible</link> и <link linkend="cuba.availableLocales">cuba.availableLocales</link>.</para>
      <para>Для того, чтобы некоторое сообщение могло быть локализовано, т.е. представлено пользователю на нужном языке, его необходимо поместить в так называемый <firstterm>пакет сообщений</firstterm>. Ниже рассмотрены принципы работы механизма локализации и правила создания сообщений.   </para>
      <para><xref linkend="getting_messages"/> содержит информацию о способах получения локализованных сообщений в различных компонентах системы.</para>
      <section id="message_packs">
        <title>Пакеты сообщений</title>
        <para>Пакет сообщений представляет собой набор файлов свойств с именами вида <filename>messages{_XX}.properties</filename>, расположенных в одном Java-пакете. Суффикс <literal>XX</literal> определяет язык, для которого в данном файле содержатся сообщения, и соответствует коду языка в <code>Locale.getLanguage()</code>. Возможно также использование остальных атрибутов <code>Locale</code>, например, <code>country</code>. В этом случая файл пакета будет иметь вид <filename>messages{_XX_YY}.properties</filename>. Один из файлов пакета может быть без суффикса языка - это <firstterm>файл по умолчанию</firstterm>. Именем пакета сообщений считается имя Java-пакета, в котором расположены файлы пакета.</para>
        <para>Рассмотрим пример:<programlisting>/com/abc/sales/gui/customer/messages.properties
/com/abc/sales/gui/customer/messages_fr.properties
/com/abc/sales/gui/customer/messages_ru.properties</programlisting></para>
        <para>Данный пакет состоит из 3-х файлов - один для русского языка, один для французского, и один по умолчанию. Имя пакета - <code>com.abc.sales.gui.customer</code> </para>
        <para>Файлы сообщений содержат пары ключ-значение,  где ключ - это идентификатор сообщения, на который ссылается код приложения, а значение - само сообщение на языке данного файла. Правила задания пар аналогичны правилам файлов свойств <code>java.util.Properties</code>, со следующими особенностями:<itemizedlist>
            <listitem>
              <para>Кодировка файла - обязательно <code>UTF-8</code></para>
            </listitem>
            <listitem>
              <para>Поддерживается включение других пакетов сообщений с помощью ключа <literal>@include</literal>, в том числе нескольких сразу - перечислением через запятую. При этом если некоторый ключ сообщения встречается и во включаемом пакете, и в текущем, будет использовано сообщение из текущего. Пример включения пакетов:<programlisting>@include=com.haulmont.cuba.web, com.abc.sales.web

someMessage=Some Message
...</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Получение сообщений из пакетов производится с помощью методов интерфейса <code>
            <link linkend="messages">Messages</link>
          </code> по следующим правилам:<itemizedlist>
            <listitem>
              <para>Сначала производится поиск в <link linkend="conf_dir">конфигурационном каталоге</link> приложения<itemizedlist>
                  <listitem>
                    <para>Ищется файл <filename>messages_XX.properties</filename> в каталоге, задаваемом именем пакета сообщений, где <literal>XX</literal> - код требуемого языка</para>
                  </listitem>
                  <listitem>
                    <para>Если такого файла нет, в этом же каталоге ищется файл по умолчанию <filename>messages.properties</filename></para>
                  </listitem>
                  <listitem>
                    <para>Если найден или файл нужного языка, или файл по умолчанию, он загружается вместе со всеми <literal>@include</literal>, и в нем ищется ключ сообщения</para>
                  </listitem>
                  <listitem>
                    <para>Если файл не найден, либо нужный ключ в нем отсутствует, производится смена каталога на родительский, и процедура поиска повторяется. И так до достижения корня конфигурационного каталога.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para>Если в конфигурационном каталоге сообщение не найдено, производится поиск в classpath по такому же алгоритму.</para>
            </listitem>
            <listitem>
              <para>На клиентском <link linkend="app_tiers">уровне</link>, если сообщение не найдено на предыдущих шагах, отправляется запрос на <structname>Middleware</structname>, и сообщение ищется там аналогичным способом.</para>
            </listitem>
            <listitem>
              <para>Если сообщение найдено, оно кэшируется и возвращается. Если не найдено - кэшируется факт отсутствия сообщения и возвращается ключ, который был передан для поиска. Таким образом, сложная процедура поиска выполняется только один раз, в дальнейшем результат загружается из локального для блока приложения кэша.</para>
            </listitem>
          </itemizedlist></para>
        <tip>
          <para>Рекомендуется организовывать пакеты сообщений следующим образом:<itemizedlist>
              <listitem>
                <para>Если приложение не предполагает интернационализации, то можно не использовать пакеты и включать строки сообщений прямо в код приложения, либо пользоваться файлами по умолчанию <filename>messages.properties</filename> для отделения ресурсов от кода.</para>
              </listitem>
              <listitem>
                <para>Если приложение  интернациональное, логично файлы по умолчанию использовать для языка основной аудитории приложения, либо для английского языка. Именно сообщения из файлов по умолчанию будут показаны пользователю, если сообщений для нужного языка не найдено.</para>
              </listitem>
            </itemizedlist></para>
        </tip>
      </section>
      <section id="main_message_pack">
        <title>Главный пакет сообщений</title>
        <para>Каждый стандартный <link linkend="app_tiers">блок</link> приложения определяет для себя один <firstterm>главный</firstterm> пакет сообщений. Для блоков клиентского уровня этот пакет содержит названия пунктов главного меню и общих элементов UI (например, названия кнопок <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton>). Для всех блоков приложения, включая <structname>Middleware</structname>, главный пакет  определяет форматы преобразований <link linkend="datatype">
            <code>Datatype</code>
          </link>.</para>
        <para>Для указания главного пакета сообщений используется свойство приложения <property>
            <link linkend="cuba.mainMessagePack">cuba.mainMessagePack</link>
          </property>. Значением свойства может быть либо один пакет, либо список пакетов, разделенный пробелами. Например:<programlisting>cuba.mainMessagePack=com.haulmont.cuba.web com.abc.sales.web</programlisting></para>
        <para>В данном случае сообщения, заданные во втором пакете списка будут перекрывать сообщений из первого пакета. Таким образом в проекте приложения можно переопределять сообщения, заданные в пакетах <link linkend="base_projects">базовых проектов</link>.</para>
      </section>
      <section id="entity_localization">
        <title>Локализация названий сущностей и атрибутов</title>
        <para>Для отображения в UI локализованных названий сущностей и их атрибутов необходимо создать специальные пакеты сообщений в тех же Java-пакетах, что и сами сущности. Формат файлов сообщений должен быть следующим:<itemizedlist>
            <listitem>
              <para>Ключ названия сущности - простое имя класса (без пакета)</para>
            </listitem>
            <listitem>
              <para>Ключ названия атрибута - простое имя класса, затем через точку имя атрибута</para>
            </listitem>
          </itemizedlist></para>
        <para>Пример русской локализации сущности <code>com.abc.sales.entity.Customer</code> - файл <filename>/com/abc/sales/entity/messages_ru.properties</filename>:<programlisting>Customer=Покупатель
Customer.name=Имя
Customer.email=Email

Order=Заказ
Order.customer=Покупатель
Order.date=Дата
Order.amount=Сумма</programlisting></para>
        <para>Такие пакеты сообщений, как правило, используются неявно для  разработчика, например, визуальными компонентами <code>
            <link linkend="gui_Table">Table</link>
          </code> и <code>
            <link linkend="gui_FieldGroup">FieldGroup</link>
          </code>. Кроме того, названия сущностей и атрибутов могут быть также получены следующими методами:<itemizedlist>
            <listitem>
              <para>программно - методами <code>
                  <link linkend="messageTools">MessageTools</link>
                </code> <code>getEntityCaption()</code>, <code>getPropertyCaption()</code></para>
            </listitem>
            <listitem>
              <para>в XML дескрипторе экрана - указанием ссылки на сообщение по правилам <code>MessageTools.<link linkend="messageTools.loadString">loadString</link>()</code>: <literal>msg://{entity_package}/{key}</literal>, например, <programlisting>caption=&quot;msg://com.abc.sales.entity/Customer.name&quot;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="enum_localization">
        <title>Локализация enum</title>
        <para>Для локализации названий  и значений перечислений необходимо в пакет сообщений, находящийся в Java-пакете класса перечисления добавить сообщения со следующими ключами:<itemizedlist>
            <listitem>
              <para>Ключ названия перечисления - простое имя класса (без пакета)</para>
            </listitem>
            <listitem>
              <para>Ключ значения - простое имя класса, затем через точку имя значения</para>
            </listitem>
          </itemizedlist></para>
        <para>Например, для перечисления <programlisting language="java">package com.abc.sales;

public enum CustomerGrade { PREMIUM, HIGH, STANDARD }</programlisting></para>
        <para>файл русской локализации <filename>/com/abc/sales/messages_ru.properties</filename> должен содержать строки:<programlisting>CustomerGrade=Уровень покупателя
CustomerGrade.PREMIUM=Премиум
CustomerGrade.HIGH=Высокий
CustomerGrade.STANDARD=Стандартный</programlisting></para>
        <para>Локализованные значения перечислений автоматически используются различными визуальными компонентами, например, <code>
            <link linkend="gui_LookupField">LookupField</link>
          </code>. Для программного получения локализованного значения перечисления можно использовать метод <code>getMessage()</code> интерфейса <code>
            <link linkend="messages">Messages</link>
          </code>, просто передавая в него экземпляр <code>enum</code>.</para>
      </section>
    </section>
    <section id="authentication">
      <title>Аутентификация пользователей</title>
      <para>В данном разделе рассмотрены некоторые аспекты управления доступом с точки зрения разработчика приложения. Для получения полной информации о возможностях и настройке ограничения доступа пользователей к данным см. <xref linkend="chapter_security"/>. </para>
      <section id="userSession">
        <title>UserSession</title>
        <para>Основной элемент подсистемы контроля доступа в CUBA-приложении - пользовательская сессия. Это объект класса <code>UserSession</code>, который ассоциирован с аутентифицированным в данный момент в системе пользователем, и содержит информацию о правах доступа пользователя к данным. Объект текущей сессии может быть получен в любом <link linkend="app_tiers">блоке</link> приложения через интерфейс инфраструктуры <code>
            <link linkend="userSessionSource">UserSessionSource</link>
          </code>.</para>
        <para>Пользовательская сессия создается на <structname>Middleware</structname> при выполнении метода <code>LoginService.login()</code> после аутентификации пользователя по переданному имени и паролю. Объект <code>UserSession</code> затем кэшируется в данном блоке <structname>Middleware</structname>, и возвращается на клиентский уровень. При работе в кластере объект сессии реплицируется на соседние узлы кластера <structname>Middleware</structname>. Клиентский блок, получив объект сессии, также сохраняет его у себя, так или иначе ассоциируя с активным пользователем (например, в HTTP сессии). Далее все вызовы <structname>Middleware</structname> для данного пользователя сопровождаются передачей идентификатора сессии (типа <code>UUID</code>), причем прикладному коду не нужно об этом заботиться - идентификатор сессии передается автоматически, независимо от сигнатуры вызываемых методов среднего слоя. Обработка вызовов клиентов на <structname>Middleware</structname> начинается с извлечения из кэша сессии по полученному идентификатору и установки ее в потоке выполнения. Объект сессии удаляется из кэша при вызове метода <code>LoginService.logout()</code>, либо при истечении времени бездействия, определяемого свойством  приложения <property>
            <link linkend="cuba.userSessionExpirationTimeoutSec">cuba.userSessionExpirationTimeoutSec</link>
          </property>.</para>
        <para>Таким образом, идентификатор сессии, создаваемой при входе пользователя в систему, служит для аутентификации пользователя при каждом вызове среднего слоя.</para>
        <para>Объект <code>UserSession</code> содержит также методы для <firstterm>авторизации</firstterm> текущего пользователя, т.е. проверки его прав на объекты системы: <code>isScreenPermitted()</code>, <code>isEntityOpPermitted()</code>, <code>isEntityAttrPermitted()</code>, <code>isSpecificPermitted()</code>.</para>
        <para>С объектом <code>UserSession</code> могут быть ассоциированы именованные атрибуты произвольного сериализуемого типа. Атрибуты устанавливаются методом <code>setAttribute()</code> и возвращаются методом <code>getAttribute()</code>. Последний может также возвращать следующие параметры сессии, как если бы они были атрибутами:<itemizedlist>
            <listitem>
              <para><code>userId</code> - ID текущего зарегистрированного или замещенного пользователя;</para>
            </listitem>
            <listitem>
              <para><code>userLogin</code> - логин текущего зарегистрированного или <link linkend="user_substitution">замещенного</link> пользователя в нижнем регистре.</para>
            </listitem>
          </itemizedlist></para>
        <para>Атрибуты реплицируются в кластере <structname>Middleware</structname> так же, как и  все остальные данные сессии.</para>
      </section>
      <section id="login">
        <title>Вход в систему</title>
        <para>Стандартный вариант входа пользователя: <itemizedlist>
            <listitem>
              <para>пользователь вводит свой логин и пароль</para>
            </listitem>
            <listitem>
              <para>клиентский блок приложения хэширует пароль, вызывая метод <code>getPlainHash()</code> бина <code>PasswordEncryption</code> и вызывает на <structname>Middleware</structname> метод <code>LoginService.login()</code>, передавая ему логин пользователя и хэш пароля</para>
            </listitem>
            <listitem>
              <para><code>LoginService</code> делегирует выполнение бину <code>LoginWorker</code>, который загружает объект <code>User</code> по полученному логину, хэширует полученный хэш пароля повторно, используя в качестве соли идентификатор пользователя, и сравнивает полученный хэш с сохраненным в БД хэшем пароля. В случае несовпадения выбрасывается исключение <code>LoginException</code>.</para>
            </listitem>
            <listitem>
              <para>После успешной аутентификации в созданный экземпляр <code>
                  <link linkend="userSession">UserSession</link>
                </code> загружаются все параметры доступа данного пользователя: список ролей, права, ограничения и атрибуты сессии.</para>
            </listitem>
          </itemizedlist></para>
        <para>Алгоритм хэширования паролей реализуется бином типа <code>EncryptionModule</code> и задается в свойстве приложения <property>
            <link linkend="cuba.passwordEncryptionModule">cuba.passwordEncryptionModule</link>
          </property>. По умолчанию - SHA-1.</para>
        <para>Возможен вариант, когда пароль пользователя (точнее, хэш пароля) не хранится в базе данных, а проверяется внешними средствами, например, путем интеграции с <application>ActiveDirectory</application>. В этом случае фактически аутентификацию выполняет клиентский блок, а <structname> Middleware</structname> &quot;доверяет&quot; клиенту, создавая сессию по одному только логину пользователя без пароля методом <code>LoginService.loginTrusted()</code>. Метод <code>loginTrusted()</code> требует выполнения следующих условия:<itemizedlist>
            <listitem>
              <para>клиентский блок должен передать так называемый доверенный пароль, задаваемый на <structname>Middleware</structname> и на клиентском блоке свойством приложения <property>
                  <link linkend="cuba.trustedClientPassword">cuba.trustedClientPassword</link>
                </property></para>
            </listitem>
            <listitem>
              <para>IP адрес клиентского блока должен соответствовать маске, задаваемой свойством приложения <property>
                  <link linkend="cuba.trustedClientPermittedIpMask">cuba.trustedClientPermittedIpMask</link>
                </property></para>
            </listitem>
          </itemizedlist></para>
        <para>Вход в систему требуется также для автоматических процессов, запускаемых по расписанию, а также при подключении к бинам <structname>Middleware</structname> через JMX-интерфейс. Строго говоря, такие действия считаются административными и не требуют аутентификации до тех пор, пока не выполняется каких-либо изменений сущностей в базе данных. При записи сущностей в БД требуется проставить логин пользователя, который выполнил изменения, поэтому для работы таких процессов должен быть указан пользователь, от лица которого выполняются изменения. </para>
        <para>Дополнительным плюсом входа в систему для автоматического процесса и для JMX-вызова является то, что вывод в журнал сообщений от логгеров сопровождается указанием логина текущего пользователя, если пользовательская сессия установлена в потоке выполнения. Это упрощает поиск сообщений от конкретного процесса при разборе журнала.</para>
        <para>Вход в систему для процессов внутри <structname>Middleware</structname> выполняется вызовом <code>LoginWorker.loginSystem()</code> с передачей логина пользователя (без пароля), от имени которого будет работать данный процесс. В результате создается объект <code>
            <link linkend="userSession">UserSession</link>
          </code>, который будет закэширован в данном блоке <structname>Middleware</structname> и не будет реплицироваться в кластере. </para>
        <para>Более подробно аутентификация процессов внутри <structname>Middleware</structname> рассмотрена в разделе <xref linkend="system_authentication"/></para>
      </section>
      <section id="securityContext">
        <title>SecurityContext</title>
        <para>Экземпляр класса <code>SecurityContext</code> хранит информацию о пользовательской сессии для текущего потока выполнения. Он создается и передается в метод <code>AppContext.setSecurityContext()</code> в следующие моменты:<itemizedlist>
            <listitem>
              <para>для блоков <structname>Web Client</structname>  и <structname>Web Portal</structname> - в начале обработки каждого HTTP-запроса от пользовательского браузера</para>
            </listitem>
            <listitem>
              <para>для блока <structname>Middleware</structname> - в начале обработки каждого запроса от клиентского уровня</para>
            </listitem>
            <listitem>
              <para>для блока <structname>Desktop Client</structname> - один раз после входа пользователя, так как десктопное приложение является однопользовательским</para>
            </listitem>
          </itemizedlist></para>
        <para>По окончании выполнения запроса в первых двух случаях  <code>SecurityContext</code> удаляется из потока выполнения.</para>
        <para>При создании прикладным кодом нового потока выполнения в него необходимо передать текущий экземпляр <code>SecurityContext</code>, например:<programlisting language="java">final SecurityContext securityContext = AppContext.getSecurityContext();
executor.submit(new Runnable() {
    public void run() {
        AppContext.setSecurityContext(securityContext);
        // business logic here
    }
});</programlisting></para>
      </section>
    </section>
    <section id="exception_handling">
      <title>Обработка исключений</title>
      <para>В данном разделе рассмотрены различные аспекты генерации и обработки исключений в CUBA-приложениях.</para>
      <section id="exception_classes">
        <title>Классы исключений</title>
        <para>При создании собственных классов исключений следует придерживаться следующих правил:<itemizedlist>
            <listitem>
              <para>Если исключение является нормальной частью бизнес-логики и при его возникновении требуется предпринимать некоторые нетривиальные действия, то класс исключения следует делать декларируемым (наследником <code>Exception</code>). Обработка таких исключений производится вызывающим кодом.</para>
            </listitem>
            <listitem>
              <para>Если исключение сигнализирует об  ошибочной ситуации, и реакцией на него должно быть прерывание хода выполнения и простое действие типа отображения информации об ошибке пользователю, то класс исключения следует делать недекларируемым (наследником <code>RuntimeException</code>). Обработка таких исключений производится специальными классами-обработчиками, зарегистрированными в клиентских блоках приложения.</para>
            </listitem>
            <listitem>
              <para>Если исключение выбрасывается и обрабатывается в рамках одного <link linkend="app_tiers">блока</link> приложения, то класс исключения следует объявлять в соответствующем <link linkend="app_modules">модуле</link>. Если же исключение выбрасывается на <structname>Middleware</structname>, а обрабатывается на клиентском уровне, то класс исключения необходимо объявлять в модуле <structname>global</structname>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Платформа содержит специальный класс недекларируемого исключения <code>SilentException</code>, который можно использовать для прерывания хода выполнения без выдачи каких-либо сообщений пользователю или в лог. <code>SilentException</code> объявлен в модуле <structname>global</structname>, поэтому доступен как на <structname>Middleware</structname>, так и в клиентских блоках.</para>
      </section>
      <section id="remoteException">
        <title>Передача исключений Middleware</title>
        <para>Если при выполнении запроса от клиента на <structname>Middleware</structname> возникает исключение, выполнение прерывается и на клиента возвращается объект исключения, как правило, включающий цепочку порождающих друг друга исключений. Так как цепочка исключений может содержать классы, недоступные клиентскому блоку (например, исключения JDBC-драйвера), на клиента передается не сама эта цепочка, а ее представление внутри специального создаваемого исключения <code>RemoteException</code>. </para>
        <para>Информация об исключениях-причинах сохраняется в виде списка объектов <code>RemoteException.Cause</code>. Каждый объект <code>Cause</code> хранит обязательно имя класса исключения и его сообщение. Кроме того, если класс исключения &quot;поддерживается клиентом&quot;, то <code>Cause</code> содержит также и сам объект исключения. Это дает возможность передать на клиента информацию в полях исключения. </para>
        <para>Класс исключения, объекты которого нужно передавать на клиентский уровень именно в виде Java-объектов, нужно аннотировать <code>@SupportedByClient</code>, например: <programlisting language="java">@SupportedByClient
public class WorkflowException extends RuntimeException {
...</programlisting></para>
        <para>Таким образом, при возникновении на <structname>Middleware</structname> исключения, не аннотированного <code>@SupportedByClient</code>, вызывающий клиентский код получит <code>RemoteException</code>, внутри которого будет находиться исходное исключение  в виде строки. Если же исходное исключение аннотировано <code>@SupportedByClient</code>, то вызывающий код получит именно его. Это дает возможность в прикладном коде организовывать обработку декларируемых <link linkend="services">сервисами</link> <structname>Middleware</structname> исключений традиционным образом - с помощью блоков <code>try...catch</code>. </para>
        <para>Следует иметь в виду, что чтобы поддерживаемое клиентом исключение было действительно передано на клиента в виде объекта, оно не должно содержать внутри себя в цепочке <code>getCause()</code> неподдерживаемых исключений. Поэтому если вы создаете на <structname>Middleware</structname> экземпляр исключения и хотите передать его на клиента, указывайте для него параметр <code>cause</code> только если вы уверены, что он содержит только исключения, известные клиенту.</para>
        <para>Упаковку объектов исключений в <code>RemoteException</code> перед передачей на клиентский уровень выполняет перехватчик вызовов <link linkend="services">сервисов</link> - класс <code>ServiceInterceptor</code>. Кроме того, он же выполняет логгирование исключений. По умолчанию в журнал выводится вся информация об исключении, включая полный stack trace. Если это нежелательно, можно добавить классу исключения аннотацию <code>@Logging</code>, указав в ней тип логгирования:<itemizedlist>
            <listitem>
              <para><code>FULL</code> - (по умолчанию) полная информация, включая stacktrace</para>
            </listitem>
            <listitem>
              <para><code>BRIEF</code> - только имя класса исключения и сообщение</para>
            </listitem>
            <listitem>
              <para><code>NONE</code> - не выводить ничего</para>
            </listitem>
          </itemizedlist></para>
        <para>Например:<programlisting language="java">@SupportedByClient
@Logging(Logging.Type.BRIEF)
public class FinancialTransactionException extends Exception {
...</programlisting></para>
      </section>
      <section id="exceptionHandlers">
        <title>Обработчики исключений клиентского уровня</title>
        <para>Необработанные исключения в <link linkend="app_tiers">блоках</link> <structname>Web Client</structname> и <structname>Desktop Client</structname>, возникшие на клиентском уровне или переданные с <structname>Middleware</structname>, попадают в специальный механизм обработчиков. Этот механизм схож для обоих блоков, однако использует разные (хотя и в основном одноименные) классы реализации. </para>
        <para>Рассмотрим механизм на примере блока <structname>Web Client</structname>. </para>
        <para>В файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename> блока объявляется бин класса <code>ExceptionHandlersConfiguration</code>, в свойстве <code>handlerClasses</code> которого задается список имен классов обработчиков. Например: <programlisting language="xml">&lt;bean id=&quot;sales_exceptionHandlersConf&quot; class=&quot;com.haulmont.cuba.web.exception.ExceptionHandlersConfiguration&quot;&gt;
    &lt;property name=&quot;handlerClasses&quot;&gt;
        &lt;list&gt;
            &lt;value&gt;com.sample.sales.web.exception.ZeroBalanceExceptionHandler&lt;/value&gt;
            &lt;value&gt;com.sample.sales.web.exception.InvalidCustomerStateExceptionHandler&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting></para>
        <para>Идентификатор бина должен быть уникальным и не совпадать ни с одним из бинов <link linkend="base_projects">базовых проектов</link>, так как базовые проекты в свою очередь могут содержать аналогичные конфигурационные бины с собственными идентификаторами. </para>
        <para>Обработчик должен реализовывать интерфейс <code>ExceptionHandler</code>, в методе <code>handle()</code> которого производить обработку и возвращать <code>true</code>, либо сразу возвращать <code>false</code>, если данный обработчик не может обработать переданное ему исключение. Такое поведение позволяет организовать &quot;цепочку ответственности&quot; обработчиков. </para>
        <para>Рекомендуется наследовать класс своего обработчика от базового класса <code>AbstractExceptionHandler</code>, который умеет разбирать цепочку исключений (с учетом упакованных внутри <code>RemoteException</code>) и реагировать на конкретные типы исключений. Типы исключений, для которых предназначен данный обработчик, указываются в массиве строк, передаваемом в конструкторе обработчика базовому конструктору. Каждая строка массива должна содержать одно полное имя класса обрабатываемого исключения, например:<programlisting language="java">public class ReportExceptionHandler extends AbstractExceptionHandler {

    public ReportExceptionHandler() {
        super(ReportingException.class.getName(),
              FailedToConnectToOpenOfficeException.class.getName(),
              UnsupportedFormatException.class.getName());
    }
...</programlisting></para>
        <para>Если класс исключения недоступен на клиенте, следует указывать его имя строковым литералом:<programlisting language="java">public class OptimisticExceptionHandler extends AbstractExceptionHandler {

    public OptimisticExceptionHandler() {
        super(&quot;org.springframework.orm.jpa.JpaOptimisticLockingFailureException&quot;);
    }
...</programlisting></para>
        <para>В случае использования в качестве базового класса <code>AbstractExceptionHandler</code> логика обработки располагается в методе <code>doHandle()</code>, и для блока <structname>Web Client</structname> может выглядеть следующим образом:<programlisting language="java">@Override
protected void doHandle(App app, String className, String message, @Nullable Throwable throwable) {
    String msg = messages.getMainMessage(&quot;zeroBalance.message&quot;);
    app.getAppWindow().showNotification(msg, Window.Notification.TYPE_ERROR_MESSAGE);
}</programlisting></para>
        <para>Если имени класса исключения недостаточно для того, чтобы принять решение о применимости данного обработчика к исключению, следует определить метод canHandle(), получающий кроме прочего текст исключения. Метод должен вернуть true, если данный обработчик применим для исключения. Например:<programlisting language="java">public class NumericOverflowExceptionHandler extends AbstractExceptionHandler {

    public NumericOverflowExceptionHandler() {
        super(ReportingSQLException.class.getName());
    }

    @Override
    protected boolean canHandle(String className, String message, @Nullable Throwable throwable) {
        return StringUtils.containsIgnoreCase(message, &quot;Numeric field overflow&quot;);
    }
...</programlisting></para>
      </section>
    </section>
  </section>
  <section id="dbms">
    <title>Компоненты работы с базой данных</title>
    <para>В данном разделе приведена информация о возможных типах СУБД приложений на платформе CUBA. Кроме того, описан механизм на основе скриптов, с помощью которого можно создать новую базу данных, и в дальнейшем поддерживать ее в актуальном состоянии на протяжении всего цикла разработки и эксплуатации приложения. </para>
    <para>Компоненты работы с базой данных принадлежат <link linkend="app_tiers">блоку</link> <structname>Middleware</structname>, другие блоки приложения не имеют прямого доступа к БД. </para>
    <para>Дополнительная практическая  информация по работе с базой данных приведена в <xref linkend="db_dev"/> и <xref linkend="db_update_in_prod"/>.</para>
    <section id="dbms_types">
      <title>Типы СУБД</title>
      <para>Тип используемой СУБД определяется свойствами приложения <property>
          <link linkend="cuba.dbmsType">cuba.dbmsType</link>
        </property> и (опционально) <link linkend="cuba.dbmsVersion">cuba.dbmsVersion</link>, а также настройкой источника данных <code>javax.sql.DataSource</code>, через который производится обращение к базе данных. Экземпляр источника данных извлекается из JNDI по имени, заданному в свойстве приложения <property>
          <link linkend="cuba.dataSourceJndiName">cuba.dataSourceJndiName</link>
        </property>. Конфигурационный файл для <application>Tomcat</application>, определяющий источник данных, описан в <xref linkend="context.xml"/></para>
      <para>Платформа &quot;из коробки&quot; поддерживает следующие СУБД:<informaltable frame="all">
          <tgroup cols="3">
            <colspec colname="c1"/>
            <colspec colname="c2"/>
            <colspec colname="c3"/>
            <thead>
              <row>
                <entry/>
                <entry>cuba.dbmsType</entry>
                <entry>cuba.dbmsVersion</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>HSQLDB</entry>
                <entry>hsql</entry>
                <entry/>
              </row>
              <row>
                <entry>PostgreSQL 8.4+</entry>
                <entry>postgres</entry>
                <entry/>
              </row>
              <row>
                <entry>Microsoft SQL Server 2005, 2008</entry>
                <entry>mssql</entry>
                <entry/>
              </row>
              <row>
                <entry>Microsoft SQL Server 2012+</entry>
                <entry>mssql</entry>
                <entry>2012</entry>
              </row>
              <row>
                <entry>Oracle Database 11g</entry>
                <entry>oracle</entry>
                <entry/>
              </row>
            </tbody>
          </tgroup>
        </informaltable></para>
      <para>Таблица ниже описывает рекомендованное соответствие типов данных между атрибутами сущностей в Java и колонками таблиц различных СУБД. Эти типы автоматически выбираются Studio при генерации скриптов создания и обновления БД, и для них гарантируется работоспособность всех механизмов платформы. </para>
      <informaltable frame="all">
        <tgroup cols="5">
          <colspec colnum="1" colname="c0"/>
          <colspec colnum="2" colname="cgen2"/>
          <colspec colnum="3" colname="c1"/>
          <colspec colnum="4" colname="c2"/>
          <colspec colnum="5" colname="cgen1"/>
          <thead>
            <row>
              <entry>Java</entry>
              <entry>HSQL</entry>
              <entry>PostgreSQL</entry>
              <entry>MS SQL Server</entry>
              <entry>Oracle</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>UUID</entry>
              <entry>varchar(36)</entry>
              <entry>uuid</entry>
              <entry>uniqueidentifier</entry>
              <entry>varchar2(32)</entry>
            </row>
            <row>
              <entry>Date</entry>
              <entry>timestamp</entry>
              <entry>timestamp</entry>
              <entry>datetime</entry>
              <entry>timestamp</entry>
            </row>
            <row>
              <entry>java.sql.Date</entry>
              <entry>timestamp</entry>
              <entry>date</entry>
              <entry>datetime</entry>
              <entry>date</entry>
            </row>
            <row>
              <entry>java.sql.Time</entry>
              <entry>timestamp</entry>
              <entry>time</entry>
              <entry>datetime</entry>
              <entry>timestamp</entry>
            </row>
            <row>
              <entry>BigDecimal</entry>
              <entry>decimal(p, s)</entry>
              <entry>decimal(p, s)</entry>
              <entry>decimal(p, s)</entry>
              <entry>number(p, s)</entry>
            </row>
            <row>
              <entry>Double</entry>
              <entry>double precision</entry>
              <entry>double precision</entry>
              <entry>double precision</entry>
              <entry>float</entry>
            </row>
            <row>
              <entry>Long</entry>
              <entry>bigint</entry>
              <entry>bigint</entry>
              <entry>bigint</entry>
              <entry>number(19)</entry>
            </row>
            <row>
              <entry>Integer</entry>
              <entry>integer</entry>
              <entry>integer</entry>
              <entry>integer</entry>
              <entry>integer</entry>
            </row>
            <row>
              <entry>Boolean</entry>
              <entry>boolean</entry>
              <entry>boolean</entry>
              <entry>tinyint</entry>
              <entry>char(1)</entry>
            </row>
            <row>
              <entry>String (limited)</entry>
              <entry>varchar(n)</entry>
              <entry>varchar(n)</entry>
              <entry>varchar(n)</entry>
              <entry>varchar2(n)</entry>
            </row>
            <row>
              <entry>String (unlimited)</entry>
              <entry>longvarchar</entry>
              <entry>text</entry>
              <entry>varchar(max)</entry>
              <entry>clob</entry>
            </row>
            <row>
              <entry>byte[]</entry>
              <entry>longvarbinary</entry>
              <entry>bytea</entry>
              <entry>image</entry>
              <entry>blob</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
      <para>Как правило, всю работу по преобразованию данных между БД и кодом Java выполняет <link linkend="orm">слой ORM</link> совместно с соответствующим JDBC драйвером. Это означает, что при работе с данными через методы <link linkend="entityManager">EntityManager</link> и <link linkend="query">запросы на JPQL</link> никакой ручной конвертации выполнять не нужно - вы просто используете типы Java, перечисленные в левой колонке таблицы.</para>
      <para>При использовании native SQL через <code>EntityManager.<link linkend="nativeQuery">createNativeQuery</link>()</code> или через <code>
          <link linkend="queryRunner">QueryRunner</link>
        </code> для разных типов СУБД некоторые типы данных в Java коде будут отличаться от приведенных. В первую очередь это касается атрибутов типа <code>UUID</code> - только драйвер PostgreSQL возвращает значения соответствующих колонок в этом типе, для других серверов это будет <code>String</code>. Для обеспечения независимости кода от используемой СУБД рекомендуется конвертировать типы параметров и результатов запросов с помощью интерфейса <code>
          <link linkend="dbTypeConverter">DbTypeConverter</link>
        </code>.</para>
      <section id="arbitrary_dbms">
        <title>Поддержка произвольных СУБД</title>
        <para>На уровне прикладного проекта можно реализовать работу с любой СУБД, поддерживаемой фреймворком <link linkend="orm">ORM</link> (OpenJPA). Для этого достаточно выполнить следующее:<itemizedlist>
            <listitem>
              <para>Указать тип СУБД в виде произвольного кода в свойстве <link linkend="cuba.dbmsType">cuba.dbmsType</link>. Код должен отличаться от используемых в платформе кодов <code>hsql</code>, <code>postgres</code>, <code>mssql</code>, <code>oracle</code>.</para>
            </listitem>
            <listitem>
              <para>Реализовать интерфейсы <code>DbmsFeatures</code>, <code>SequenceSupport</code>, <code>DbTypeConverter</code> классами с именами соответственно  <code>TypeDbmsFeatures</code>, <code>TypeSequenceSupport</code>, <code>TypeDbTypeConverter</code>, где <code>Type</code> - код типа СУБД. Пакет класса имплементации должен быть таким же, как у интерфейса.</para>
            </listitem>
            <listitem>
              <para>Если проект включает базовый проект <structname>Workflow</structname>, необходимо переопределить бин <code>CubaJbpmSpringHelper</code> и его метод <code>getHibernateDialectName()</code> для выбора диалекта Hibernate, используемого в jBPM.</para>
            </listitem>
            <listitem>
              <para>Создать скрипты инициализации и обновления БД в каталогах с кодом СУБД. Скрипты инициализации должны включать создание всех объектов БД, необходимых для сущностей платформы (их можно скопировать из имеющихся в каталоге <code>10-cuba</code> и др. скриптов и исправить для данной СУБД).</para>
            </listitem>
            <listitem>
              <para>Для создания и обновления БД задачами Gradle в build.gradle необходимо для этих задач указать дополнительные параметры:<programlisting language="java">task createDb(dependsOn: assemble, type: CubaDbCreation) {
    dbms = &apos;my&apos;                                            // DBMS code
    driver = &apos;net.my.jdbc.Driver&apos;                          // JDBC driver class
    dbUrl = &apos;jdbc:my:myserver://192.168.47.45/mydb&apos;        // Database URL
    masterUrl = &apos;jdbc:my:myserver://192.168.47.45/master&apos;  // URL of a master DB to connect to for creating the application DB
    dropDbSql = &apos;drop database mydb;&apos;                      // Drop database statement
    createDbSql = &apos;create database mydb;&apos;                  // Create database statement
    timeStampType = &apos;datetime&apos;                             // Date and time datatype - needed for SYS_DB_CHANGELOG table creation
    dbUser = &apos;sa&apos;
    dbPassword = &apos;saPass1&apos;
}

task updateDb(dependsOn: assemble, type: CubaDbUpdate) {
    dbms = &apos;my&apos;                                            // DBMS code
    driver = &apos;net.my.jdbc.Driver&apos;                          // JDBC driver class
    dbUrl = &apos;jdbc:my:myserver://192.168.47.45/mydb&apos;        // Database URL
    dbUser = &apos;sa&apos;
    dbPassword = &apos;saPass1&apos;
}</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="dbms_version">
        <title>Версия СУБД</title>
        <para>В дополнение к свойству приложения <link linkend="cuba.dbmsType">cuba.dbmsType</link> существует опциональное свойство <link linkend="cuba.dbmsVersion">cuba.dbmsVersion</link>. Оно влияет на выбор имплементаций интерфейсов <code>DbmsFeatures</code>, <code>SequenceSupport</code>, <code>DbTypeConverter</code>, и на поиск скриптов создания и обновления БД.</para>
        <para>Имя класса имплементации интеграционного интерфейса формируется следующим образом: <code>TypeVersionName</code>. Здесь <code>Type</code> - значение <code>cuba.dbmsType</code> с заглавной буквы, <code>Version</code> - значение <code>cuba.dbmsVersion</code>, <code>Name</code> - имя интерфейса. Пакет класса должен быть таким же, как у интерфейса. Если класс с таким именем отсутствует, предпринимается попытка найти класс с именем без версии: <code>TypeName</code>. Если и такого класса нет, выдается исключение.</para>
        <para>Например, в платформе определен класс <code>com.haulmont.cuba.core.sys.persistence.Mssql2012SequenceSupport</code>, который вступит в силу, если в проекте указаны следующие свойства:<programlisting>cuba.dbmsType = mssql
cuba.dbmsVersion = 2012</programlisting></para>
        <para>При поиске <link linkend="db_scripts">скриптов создания и обновления БД</link> каталог с именем <code>type-version</code> имеет приоритет над каталогом с именем <code>type</code>. Это значит, что скрипты каталога <code>type-version</code> заменяют одноименные скрипты каталога <code>type</code>. В каталоге <code>type-version</code> могут быть и скрипты с собственными именами, они будут также добавлены в общий набор скриптов для выполнения. Сортировка скриптов производится по пути начиная с каталога, вложенного в <code>type</code> или <code>type-version</code>, то есть без учета того, в каком каталоге (с версией или без) находится скрипт.</para>
        <para>Например, следующим образом можно определить скрипты создания БД для Microsoft SQL Server для версий ниже и выше 2012:<programlisting>modules/core/db/init/
     mssql/
         10.create-db.sql
         20.create-db.sql
         30.create-db.sql
     mssql-2012/
         10.create-db.sql </programlisting></para>
      </section>
    </section>
    <section id="db_scripts">
      <title>Скрипты создания и обновления БД</title>
      <para>Проект CUBA-приложения всегда содержит два набора  скриптов:<itemizedlist>
          <listitem>
            <para>Скрипты <emphasis>создания</emphasis> БД, предназначенные для создания базы данных с нуля. Они содержат набор DDL и DML операторов, после выполнении которых на пустой БД  схема базы данных полностью соответствует текущему состоянию <link linkend="data_model">модели данных</link> приложения. Скрипты создания могут также наполнять БД необходимыми первичными данными.</para>
          </listitem>
          <listitem>
            <para>Скрипты <emphasis>обновления</emphasis> БД - предназначены для поэтапного приведения структуры БД к текущему состоянию модели данных.</para>
          </listitem>
        </itemizedlist></para>
      <para>При изменении модели данных необходимо отразить соответствующее изменение схемы БД и в скриптах содания, и в скриптах обновления. Например, при добавлении атрибута <code>address</code> в сущность <code>Customer</code>, нужно:<orderedlist>
          <listitem>
            <para>Изменить оператор создания таблицы в скрипте создания:<programlisting>create table SALES_CUSTOMER (
    ID varchar(36) not null ,
    CREATE_TS timestamp,          
    CREATED_BY varchar(50),       
    -- 
    NAME varchar(100),            
    ADDRESS varchar(200), -- added column
    -- 
    primary key (ID)
)</programlisting></para>
          </listitem>
          <listitem>
            <para>Добавить скрипт обновления, содержащий оператор модификации таблицы:<programlisting>alter table SALES_CUSTOMER add ADDRESS varchar(200)</programlisting></para>
          </listitem>
        </orderedlist></para>
      <para>Скрипты создания располагаются в каталоге <filename>/db/init</filename> модуля <structname>core</structname>. Для каждого типа СУБД, поддерживаемой приложением, создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим свойству приложения <property>
          <link linkend="cuba.dbmsType">cuba.dbmsType</link>
        </property>, например, <filename>/db/init/postgres</filename>. Имена скриптов создания должны иметь вид <filename>{optional_prefix}create-db.sql</filename>.</para>
      <para>Скрипты обновления располагаются в каталоге <filename>/db/update</filename> модуля <structname>core</structname>. Для каждого типа СУБД, поддерживаемой приложением,  создается свой набор скриптов и располагается в подкаталоге с именем, соответствующим свойству приложения <property>
          <link linkend="cuba.dbmsType">cuba.dbmsType</link>
        </property>, например, <filename>/db/update/postgres</filename>. </para>
      <para>Скрипты обновления могут быть двух типов: с расширением <filename>*.sql</filename> или с расширением <filename>*.groovy</filename>. SQL-скрипты являются основным средством  обновления базы данных. Groovy-скрипты выполняются только <link linkend="db_update_server">механизмом запуска скриптов БД сервером</link>, поэтому применяются в основном на этапе эксплуатации приложения - как правило, это процессы миграции или импорта данных, которые невозможно реализовать на SQL. </para>
      <para>Скрипты обновления должны иметь имена, которые при сортировке в алфавитном порядке образуют правильную последовательность их выполнения (обычно это хронологическая последовательность их создания). Поэтому при ручном создании рекомендуется задавать имя скрипта обновления в виде <filename>{yymmdd}-{description}.sql</filename>, где <literal>yy</literal> - год, <literal>mm</literal> - месяц, <literal>dd</literal> - день, <literal>description</literal> - краткое описание скрипта. Например, <filename>121003-addCodeToCategoryAttribute.sql</filename>. Studio при автоматической генерации скриптов также придерживается этого формата.</para>
      <para>Скрипты обновления можно группировать в подкаталоги, главное, чтобы путь к скрипту с учетом подкаталога не нарушал хронологической последовательности. Например, можно создавать подкаталоги по номеру года или по году и месяцу.</para>
      <para>В развернутом приложении скрипты создания и обновления БД располагаются в специальном <link linkend="db_dir">каталоге скриптов базы данных</link>, задаваемым свойством приложения <property>
          <link linkend="cuba.dbDir">cuba.dbDir</link>
        </property>.</para>
      <section>
        <title>Структура SQL-скриптов</title>
        <para>SQL-скрипты создания и обновления представляют собой текстовые файлы с набором DDL и DML команд, разделенных символом &quot;<literal>^</literal>&quot;. Символ &quot;<literal>^</literal>&quot; применяется для того, чтобы можно было применять разделитель &quot;<literal>;</literal>&quot; в составе сложных команд, например, при создании функций или триггеров. Механизм исполнения скриптов разделяет входной файл на команды по разделителю &quot;<literal>^</literal>&quot; и выполняет  каждую команду в отдельной транзакции. Это означает, что при необходимости можно сгруппировать несколько простых операторов (например, <literal>insert</literal>), разделенных точкой с запятой, и обеспечить их выполнение  в одной транзакции.</para>
        <para>Пример SQL-скрипта обновления:<programlisting>create table LIBRARY_COUNTRY (
    ID varchar(36) not null,
    CREATE_TS time,
    CREATED_BY varchar(50),
    --
    NAME varchar(100) not null,
    --
    primary key (ID)
)^

alter table LIBRARY_TOWN add column COUNTRY_ID varchar(36) ^
alter table LIBRARY_TOWN add constraint FK_LIBRARY_TOWN_COUNTRY_ID foreign key (COUNTRY_ID) references LIBRARY_COUNTRY(ID)^
create index IDX_LIBRARY_TOWN_COUNTRY on LIBRARY_TOWN (COUNTRY_ID)^</programlisting></para>
      </section>
      <section>
        <title>Структура Groovy-скриптов</title>
        <para>Groovy-скрипты обновления  имеют следующую структуру:<itemizedlist>
            <listitem>
              <para><emphasis>Основная</emphasis> часть, содержащая код, выполняемый до старта <link linkend="appContext">контекста приложения</link>. В этой части можно использовать любые классы Java, Groovy и блока <structname>Middleware</structname> приложения, но при этом необходимо иметь в виду, что никакие бины,  интерфейсы инфраструктуры и прочие объекты приложения еще не инстанциированы, и с ними работать нельзя.</para>
              <para>Основная часть предназначена в первую очередь, как и обычные SQL-скрипты,  для обновления схемы данных.</para>
            </listitem>
            <listitem>
              <para><emphasis>PostUpdate</emphasis> часть - набор замыканий, которые будут выполнены после завершения процесса обновления и после старта контекста приложения. Внутри этих замыканий можно оперировать любыми объектами <structname>Middleware</structname> приложения.</para>
              <para>В этой части скрипта удобно, напимер, выполнять импорт данных, так как в ней можно использовать интерфейс <link linkend="persistence">Persistence</link> и объекты модели данных.</para>
            </listitem>
          </itemizedlist></para>
        <para>На вход Groovy-скриптов механизм выполнения передает следующие переменные:<itemizedlist>
            <listitem>
              <para><code>ds</code> - экземпляр <code>javax.sql.DataSource</code> для базы данных приложения.</para>
            </listitem>
            <listitem>
              <para><code>log</code> - экземпляр <code>org.apache.commons.logging.Log</code> для вывода сообщений в журнал сервера</para>
            </listitem>
            <listitem>
              <para><code>postUpdate</code> - объект, содержащий метод <code>add(Closure closure)</code> для добавления замыканий, выполняющихся после старта контекста сервера.</para>
            </listitem>
          </itemizedlist></para>
        <warning>
          <para>Groovy-скрипты выполняются только <link linkend="db_update_server">механизмом запуска скриптов БД сервером</link>.</para>
        </warning>
        <para>Пример Groovy-скрипта обновления:<programlisting language="java">import com.haulmont.cuba.core.Persistence
import com.haulmont.cuba.core.global.AppBeans
import com.haulmont.refapp.core.entity.Colour
import groovy.sql.Sql

log.info(&apos;Executing actions in update phase&apos;)

Sql sql = new Sql(ds)
sql.execute &quot;&quot;&quot;
  alter table MY_COLOR add DESCRIPTION varchar(100);
&quot;&quot;&quot;

// Add post update action
postUpdate.add({
    log.info(&apos;Executing post update action using fully functioning server&apos;)

    def p = AppBeans.get(Persistence.class)
    def tr = p.createTransaction()
    try {
        def em = p.getEntityManager()

        Colour c = new Color()
        c.name = &apos;yellow&apos;
        c.description = &apos;a description&apos;

        em.persist(c)
        tr.commit()
    } finally {
        tr.end()
    }
})</programlisting></para>
      </section>
    </section>
    <section id="db_update_gradle">
      <title>Выполнение скриптов БД задачами Gradle</title>
      <para>Данный механизм применяется обычно разработчиками приложения для собственного экземпляра базы данных. Выполнение скриптов в этом случае сводится к запуску специальных задач Gradle, описанных в скрипте сборки <filename>
          <link linkend="build.gradle">build.gradle</link>
        </filename>. Это можно сделать как из командной строки, так и с помощью интерфейса Studio.</para>
      <para>Для запуска скриптов <emphasis>создания</emphasis> БД служит задача <code>createDb</code>. В Studio ей соответствует команда главного меню <guimenu>Run</guimenu> -&gt; <guimenu>Create database</guimenu>. При запуске задачи происходит следующее:<orderedlist>
          <listitem>
            <para>В каталоге <filename>modules/core/build/db</filename> собираются скрипты <link linkend="base_projects">базовых проектов</link> платформы и скрипты <filename>db/**/*.sql</filename> модуля <structname>core</structname> текущего проекта. Наборы скриптов базовых проектов располагаются в подкаталогах с числовыми префиксами начиная с 10, скрипты текущего проекта - в подкаталоге с префиксом 50. Числовые префиксы необходимы для соблюдения алфавитного порядка выполнения скриптов - сначала выполняются скрипты <structname>cuba</structname>, затем других базовых проектов, затем текущего проекта.</para>
          </listitem>
          <listitem>
            <para>Если БД существует, она полностью очищается. Если не существует, то создается новая пустая БД.</para>
          </listitem>
          <listitem>
            <para>Последовательно в алфавитном порядке выполняются все скрипты создания <filename>modules/core/build/db/init/**/*create-db.sql</filename>, и их имена вместе с путем относительно каталога <filename>db</filename> регистрируются в таблице <database>SYS_DB_CHANGELOG</database>.</para>
          </listitem>
          <listitem>
            <para>В таблице <database>SYS_DB_CHANGELOG</database> аналогично регистрируются все имеющиеся на данный момент скрипты обновления <filename>modules/core/build/db/update/**/*.sql</filename>. Это необходимо для будущего инкрементального обновления БД новыми скриптами. </para>
          </listitem>
        </orderedlist></para>
      <para>Для запуска скриптов <emphasis>обновления</emphasis> БД служит задача <code>updateDb</code>. В Studio ей соответствует команда главного меню <guimenu>Run</guimenu> -&gt; <guimenu>Update database</guimenu>. При запуске задачи происходит следующее:<orderedlist>
          <listitem>
            <para>Производится сборка скриптов аналогично описанному выше.</para>
          </listitem>
          <listitem>
            <para>В каталогах <filename>modules/core/build/db/update/**</filename> производится поиск скриптов обновления, не зарегистрированных в таблице <database>SYS_DB_CHANGELOG</database>, то есть не выполненных ранее и содержимое которых не отражено в БД при ее инициализации.</para>
          </listitem>
          <listitem>
            <para>Последовательно в алфавитном порядке выполняются все найденные на предыдущем шаге скрипты, и их имена вместе с путем относительно каталога <filename>db</filename> регистрируются в таблице <database>SYS_DB_CHANGELOG</database>. </para>
          </listitem>
        </orderedlist></para>
    </section>
    <section id="db_update_server">
      <title>Выполнение скриптов БД сервером</title>
      <para>Механизм выполнения скриптов  сервером предназначен для приведения БД в актуальное состояние на старте сервера приложения, и активируется во время инициализации  блока <structname>Middleware</structname>. Понятно, что при этом приложение должно быть собрано и развернуто на сервере, будь то собственный  Tomcat разработчика или сервер в режиме эксплуатации.</para>
      <para>Данный механизм в зависимости от описанных ниже условий выполняет либо скрипты создания, либо скрипты обновления, то есть он может и инициализировать БД с нуля, и обновлять ее. Однако, в отличие от описанной в предыдущем разделе задачи Gradle <code>createDb</code>, для выполнения инициализации базы она должна существовать - сервер не создает БД автоматически, а только прогоняет на ней скрипты.</para>
      <para>Механизм выполнения скриптов сервером действует следующим образом:<itemizedlist>
          <listitem>
            <para>Скрипты извлекаются из <link linkend="db_dir">каталога скриптов базы данных</link>, определяемого свойством приложения <link linkend="cuba.dbDir">
                <property>cuba.dbDir</property>
              </link>. В стандартном варианте развертывания в Tomcat это  <filename>tomcat/webapps/app-core/WEB-INF/db</filename>.</para>
          </listitem>
          <listitem>
            <para>Если в БД отсутствует таблица <database>SEC_USER</database>, то считается, что база данных пуста, и запускается полная инициализация с помощью скриптов создания БД. После выполнения инициализирующих скриптов их имена запоминаются в таблице <database>SYS_DB_CHANGELOG</database>. Кроме того, там же сохраняются имена всех доступных скриптов обновления, <emphasis>без их выполнения</emphasis>.</para>
          </listitem>
          <listitem>
            <para>Если в БД имеется таблица <database>SEC_USER</database>, но отсутствует таблица <database>SYS_DB_CHANGELOG</database> (это случай, когда в первый раз запускается описываемый механизм на имеющейся рабочей БД), никакие скрипты <emphasis>не запускаются</emphasis>. Вместо этого создается таблица <database>SYS_DB_CHANGELOG</database> и в ней сохраняются имена всех доступных на данный момент скриптов создания и обновления. </para>
          </listitem>
          <listitem>
            <para>Если в БД имеются и таблица <database>SEC_USER</database> и таблица <database>SYS_DB_CHANGELOG</database>, то производится запуск скриптов обновления, и их имена запоминаются в таблице <database>SYS_DB_CHANGELOG</database>. Причем запускаются только те скрипты, имен которых до этого не было в таблице <database>SYS_DB_CHANGELOG</database>, т.е. не запускавшиеся ранее.
Последовательность запуска скриптов определяется 2-мя факторами: приоритетом базового проекта (см. содержимое <link linkend="db_dir">каталога скриптов базы данных</link>: <filename>10-cuba</filename>, <filename>20-workflow</filename>, ...) и именем файла скрипта (с учетом подкаталогов внутри каталога <filename>update</filename>) в алфавитном порядке.</para>
          </listitem>
        </itemizedlist></para>
      <para>Механизм выполнения скриптов на старте сервера  включается свойством приложения <property>
          <link linkend="cuba.automaticDatabaseUpdate">cuba.automaticDatabaseUpdate</link>
        </property>.</para>
      <para>В запущенном приложении механизм выполнения скриптов можно стартовать с помощью  JMX-бина <code>app-core.cuba:type=PersistenceManager</code>, вызвав его метод <code>updateDatabase()</code> с параметром <userinput>update</userinput>. Понятно, что таким способом можно только обновить БД, а не проинициализировать новую, так как войти в систему для запуска метода JMX-бина при пустой БД невозможно. При этом следует иметь в виду, что если на старте <structname>Middleware</structname> или при входе пользователя в систему начнется инициализация той части модели данных, которая уже не соответствует устаревшей схеме БД, то произойдет ошибка, и продолжение работы станет невозможным. Именно поэтому универсальным является только автоматическое обновление БД на старте сервера перед инициализацией модели данных.</para>
      <para>JMX-бин <code>app-core.cuba:type=PersistenceManager</code> имеет еще один метод, относящийся к механизму обновления БД: <code>findUpdateDatabaseScripts()</code>. Он возвращает список новых скриптов обновления, имеющихся в каталоге и не зарегистрированных в БД.</para>
      <para>Практические рекомендации по использованию механизма  обновления БД сервером приведены в <xref linkend="db_update_in_prod"/>.</para>
    </section>
  </section>
  <section id="middleware">
    <title>Компоненты среднего слоя</title>
    <para>На следующем рисунке приведены основные компоненты среднего слоя CUBA-приложения.</para>
    <figure>
      <title>Компоненты среднего слоя</title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/Middleware.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para><link linkend="services">Services</link> – управляемые <glossterm linkend="container">контейнером</glossterm> компоненты, формирующие границу приложения и предоставляющие интерфейс клиентскому <link linkend="app_tiers">уровню</link> приложения. Сервисы могут содержать бизнес-логику сами, либо делегировать выполнение <link linkend="managed_beans">Managed Beans</link>.</para>
    <para><link linkend="managed_beans">Managed Beans</link> – управляемые <glossterm linkend="container">контейнером</glossterm> компоненты, содержащие бизнес-логику приложения. Вызываются <link linkend="services">сервисами</link>, другими бинами или через опциональный <glossterm linkend="jmx">JMX</glossterm> интерфейс.</para>
    <para><code>
        <link linkend="persistence">Persistence</link>
      </code> − инфраструктурный интерфейс для доступа к функциональности хранения данных: управлению <link linkend="transactions">транзакциями</link> и <link linkend="orm">ORM</link>. </para>
    <section id="services">
      <title>Сервисы</title>
      <para>Сервисы образуют слой  компонентов, определяющий множество операций <structname>Middleware</structname>, доступных клиентскому <link linkend="app_tiers">уровню</link> приложения. Внутри сервисов  инкапсулируется бизнес-логика и  управление <link linkend="transactions">транзакциями</link>.</para>
      <para>Основные задачи сервисов:</para>
      <itemizedlist>
        <listitem>
          <para>Предоставляют удаленный (remote) интерфейс для вызова с клиентского уровня</para>
        </listitem>
        <listitem>
          <para>Проверяют наличие активной <link linkend="userSession">пользовательской сессии</link>, соответствующей идентификатору сессии, переданному с клиента</para>
        </listitem>
        <listitem>
          <para>Записывают в журнал  необработанные исключения среднего слоя</para>
        </listitem>
      </itemizedlist>
      <para>Кроме того, именно в слое сервисов рекомендуется выполнять авторизацию текущего пользователя, т.е. проверять его права на ту или иную функциональность.</para>
      <para>Общие для всех сервисов задачи решаются следующим образом:<itemizedlist>
          <listitem>
            <para>Проверка наличия пользовательской сессии и логгирование исключений производится классом-<glossterm linkend="interceptor">интерцептором</glossterm> <code>ServiceInterceptor</code>, который перехватывает выполнение каждого метода сервиса с помощью <application>Spring AOP</application></para>
          </listitem>
          <listitem>
            <para>Удаленный интерфейс для доступа к сервису через <application>Spring HTTP Invoker</application> создается бином <code>RemoteServicesBeanCreator</code>, который конфигурируется в файле <filename>
                <link linkend="remoting-spring.xml">remoting-spring.xml</link>
              </filename> модуля <structname>core</structname>. </para>
          </listitem>
        </itemizedlist></para>
      <figure>
        <title>Диаграмма классов сервиса</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/MiddlewareServices.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <section>
        <title>Создание сервиса</title>
        <para>Имена интерфейсов сервисов должны заканчиваться на <code>Service</code>, имена классов реализации на <code>ServiceBean</code>.</para>
        <para>При создании сервиса необходимо выполнить следующее:</para>
        <procedure>
          <step>
            <para>Создать интерфейс в <link linkend="app_modules">модуле</link> <structname>global</structname> (т.к. интерфейс сервиса должен быть доступен на всех <link linkend="app_tiers">уровнях</link>) и задать в нем имя сервиса. Имя рекомендуется задавать в формате <literal>{имя_проекта}_{имя_интерфейса}</literal>. Например:</para>
            <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;

public interface OrderService {
    String NAME = &quot;sales_OrderService&quot;;

    void calculateTotals(Order order);
}</programlisting>
          </step>
          <step>
            <para>Создать класс сервиса в модуле <structname>core</structname> и добавить ему аннотацию <code>@org.springframework.stereotype.Service</code> с именем, заданным в интерфейсе</para>
            <programlisting language="java">package com.sample.sales.core;

import com.sample.sales.entity.Order;
import org.springframework.stereotype.Service;

@Service(OrderService.NAME)
public class OrderServiceBean implements OrderService {
    @Override
    public void calculateTotals(Order order) {
    }
}</programlisting>
            <para>Класс сервиса, как и класс любого другого <link linkend="managed_beans">управляемого бина</link>, должен находиться внутри дерева пакетов с корнем, заданным в элементе <literal>context:component-scan</literal> файла <filename>
                <link linkend="spring.xml">spring.xml</link>
              </filename>. В нашем случае файл <filename>spring.xml</filename> содержит элемент:<programlisting language="xml">&lt;context:component-scan base-package=&quot;com.sample.sales&quot;/&gt;</programlisting>что означает, что поиск аннотированных бинов для данного блока приложения будет происходить начиная с пакета <code>com.sample.sales</code>.</para>
          </step>
        </procedure>
        <warning>
          <para>Сервисы предназначены только для вызова &quot;снаружи&quot; <structname>Middleware</structname>. Не рекомендуется вызывать методы сервисов из других компонентов среднего слоя. При обнаружении факта вызова сервиса из другого сервиса в журнал  выводится сообщение об ошибке.</para>
          <para>Если некоторую бизнес-логику требуется вызывать из разных сервисов либо других компонентов <structname>Middleware</structname>, ее необходимо выделить и инкапсулировать внутри соответствующего <link linkend="managed_beans">Managed Bean</link>.</para>
        </warning>
      </section>
      <section id="service_import">
        <title>Использование сервиса</title>
        <para>Для того чтобы вызывать сервис, в клиентском  блоке приложения для него должен быть создан соответствующий прокси-объект. Делается это путем объявления имени и интерфейса сервиса в параметрах фабрики прокси-объектов. Для блока <structname>Web Client</structname> это бин класса <code>WebRemoteProxyBeanCreator</code>, для <structname>Web Portal</structname> - <code>PortalRemoteProxyBeanCreator</code> , для <structname>Desktop Client</structname> - <code>RemoteProxyBeanCreator</code> .</para>
        <para>Фабрика прокси-объектов конфигурируется в файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename> соответствующего клиентского блока.</para>
        <para>Например, чтобы в приложении <application>sales</application> вызвать с веб-клиента сервис <code>sales_OrderService</code>, необходимо добавить в файл <filename>web-spring.xml</filename> модуля <structname>web</structname> следующее:</para>
        <programlisting language="xml">&lt;bean id=&quot;sales_proxyCreator&quot; class=&quot;com.haulmont.cuba.web.sys.remoting.WebRemoteProxyBeanCreator&quot;&gt;
    &lt;property name=&quot;clusterInvocationSupport&quot; ref=&quot;cuba_clusterInvocationSupport&quot;/&gt;
    &lt;property name=&quot;remoteServices&quot;&gt;
        &lt;map&gt;
            &lt;entry key=&quot;sales_OrderService&quot; value=&quot;com.sample.sales.core.OrderService&quot;/&gt;
        &lt;/map&gt;
    &lt;/property&gt;
&lt;/bean&gt;</programlisting>
        <para>Все импортируемые сервисы объявляются в одном свойстве <code>remoteServices</code>  в элементах <literal>map/entry</literal>.</para>
        <para>С точки зрения прикладного кода прокси-объект сервиса на клиентском уровне является обычным бином <application>Spring</application> и может быть получен либо инжекцией, либо с помощью класса <code>AppBeans</code>, например:<programlisting language="java">@Inject
protected OrderService orderService;
...
orderService.calculateTotals(order);</programlisting></para>
      </section>
    </section>
    <section id="system_authentication">
      <title>Системная аутентификация</title>
      <para>При выполнении пользовательских запросов программному коду <structname>Middleware</structname>  через интерфейс <code>
          <link linkend="userSessionSource">UserSessionSource</link>
        </code> всегда доступна информация о текущем пользователе. Это возможно потому, что при получении запроса с клиентского уровня в потоке выполнения автоматически устанавливается соответствующий объект <code>
          <link linkend="securityContext">SecurityContext</link>
        </code>.</para>
      <para>Однако существуют ситуации, когда текущий поток выполнения  не связан ни с каким пользователем системы: например, при вызове метода бина из <link linkend="scheduled_tasks_spring">планировщика</link>, либо через JMX-интерфейс. Если при этом бин выполняет изменение сущностей в базе данных, то ему потребуется информация о том, кто выполняет изменения, то есть аутентификация.</para>
      <para>Такого рода аутентификация называется системной, так как не требует участия пользователя - средний слой приложения просто создает (или использует имеющуюся) пользовательскую сессию, и устанавливает в потоке выполнения соответствующий объект <code>SecurityContext</code>. </para>
      <para>Обеспечить системную аутентификацию некоторого участка кода можно следующими способами:<itemizedlist>
          <listitem>
            <para>явно используя бин <code>com.haulmont.cuba.security.app.Authentication</code>, например:<programlisting language="java">@Inject
protected Authentication authentication;
...
authentication.begin();
try {
    // authenticated code
} finally {
    authentication.end();
}</programlisting></para>
          </listitem>
          <listitem>
            <para>добавив методу бина аннотацию <code>@Authenticated</code>, например:<programlisting language="java">@Authenticated
public String foo(String value) {
    // authenticated code
}</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Во втором случае также используется бин <code>Authentication</code>, но неявно, через интерцептор <code>AuthenticationInterceptor</code>, который перехватывает вызовы всех методов бинов с аннотацией <code>@Authenticated</code>.</para>
      <para>В приведенных примерах пользовательская сессия будет создаваться от лица пользователя, логин которого указан в свойстве приложения <property>
          <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
        </property>. Если требуется аутентификация от имени другого пользователя, нужно воспользоваться первым вариантом и передать в метод <code>begin()</code> логин нужного пользователя.</para>
      <warning>
        <para>Если в момент выполнения <code>Authentication.begin()</code> в текущем потоке выполнения присутствует активная пользовательская сессия, то она не заменяется - соответственно, код, требующий аутентификации, будет выполняться с имеющейся сессией, и последующий метод <code>end()</code> не будет очищать поток.</para>
        <para>Например,  вызов метода JMX-бина из встроенной в <structname>Web Client</structname> консоли JMX, если бин находится в той же JVM, что и блок WebClient, к которому в данный момент подключен пользователь, будет выполнен от имени текущего зарегистрированного в системе пользователя, независимо от наличия системной аутентификации.</para>
      </warning>
    </section>
    <section id="persistence">
      <title>Интерфейс Persistence</title>
      <para>Интерфейс инфраструктуры, являющийся точкой входа в функциональность хранения данных в БД.</para>
      <para>Методы интерфейса:<itemizedlist>
          <listitem>
            <para><code>createTransaction()</code>, <code>getTransaction()</code> - получить интерфейс управления <link linkend="transactions">транзакциями</link></para>
          </listitem>
          <listitem>
            <para><code>isInTransaction()</code> - определяет, существует ли в данный момент активная транзакция</para>
          </listitem>
          <listitem>
            <para><code>getEntityManager()</code> - возвращает экземпляр <code>
                <link linkend="entityManager">EntityManager</link>
              </code> для текущей транзакции</para>
          </listitem>
          <listitem>
            <para><code>isSoftDeletion()</code> - позволяет определить, активен ли режим <link linkend="soft_deletion">мягкого удаления</link></para>
          </listitem>
          <listitem>
            <para><code>setSoftDeletion()</code> - устанавливает или отключает режим мягкого удаления. Влияет на аналогичный признак всех создаваемых экземпляров <code>EntityManager</code>. По умолчанию мягкое удаление включено.</para>
          </listitem>
          <listitem>
            <para><code>getDbTypeConverter()</code> - возвращает экземпляр <code>
                <link linkend="dbTypeConverter">DbTypeConverter</link>
              </code> для используемой в данный момент базы данных.</para>
          </listitem>
          <listitem>
            <para><code>getDataSource()</code> - получить <code>javax.sql.DataSource</code> для используемой в данный момент базы данных.</para>
            <warning>
              <para>Для всех объектов <code>javax.sql.Connection</code>, получаемых методом <code>getDataSource().getConnection()</code>, необходимо после использования соединения вызвать метод <code>close()</code> в секции <code>finally</code>. В противном случае соединение не вернется в пул, через какое-то время пул переполнится, и приложение не сможет выполнять запросы к базе данных. </para>
            </warning>
          </listitem>
          <listitem>
            <para><code>getTools()</code> - возвращает экземпляр интерфейса  <code>PersistenceTools</code> (см. ниже).</para>
          </listitem>
        </itemizedlist></para>
      <section id="persistenceTools">
        <title>PersistenceTools</title>
        <para><link linkend="managed_beans">ManagedBean</link>, содержащий вспомогательные методы работы с хранилищем данных. Интерфейс <code>PersistenceTools</code> можно получить либо методом <code>Persistence.getTools()</code>, либо как любой другой бин - инжекцией или через класс <code>AppBeans</code>.</para>
        <para>Методы <code>PersistenceTools</code>:<itemizedlist>
            <listitem>
              <para><code>getDirtyFields()</code> - возвращает коллекцию имен атрибутов сущности, измененных со времени последней загрузки экземпляра из БД. Для новых экземпляров возвращает пустую коллекцию.</para>
            </listitem>
            <listitem>
              <para><code>isLoaded()</code> - определяет, загружен ли из БД указанный атрибут экземпляра. Атрибут может быть <emphasis>не</emphasis> загружен, если он не указан в примененном при загрузке <link linkend="views">представлении</link>. </para>
              <para>Данный метод работает только для экземпляров в  состоянии <link linkend="entity_states">Managed</link>.</para>
            </listitem>
            <listitem>
              <para><code>getReferenceId()</code> - возвращает идентификатор связанной сущности без загрузки ее из БД. </para>
              <para>Предположим, в <glossterm linkend="persistence_context">персистентный контекст</glossterm> загружен экземпляр <code>Order</code>, и нужно получить значение идентификатора экземпляра <code>Customer</code>, связанного с данным Заказом. Стандартное решение <code>order.getCustomer().getId()</code> приведет к выполнению SQL запроса к БД для загрузки экземпляра <code>Customer</code>, что в данном случае избыточно, так как значение идентификатора Покупателя физически находится также и в таблице Заказов. Выполнение же <programlisting language="java">persistence.getTools().getReferenceId(order, &quot;customer&quot;)</programlisting>не вызовет никаких дополнительных запросов к базе данных. </para>
              <para>Данный метод работает только для экземпляров в  состоянии <link linkend="entity_states">Managed</link>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Для расширения набора вспомогательных методов в конкретном приложении бин <code>PersistenceTools</code> можно <link linkend="bean_extension">переопределить</link>. Примеры работы с  расширенным интерфейсом:<programlisting language="java">MyPersistenceTools tools = persistence.getTools();
tools.foo();</programlisting><programlisting language="java">((MyPersistenceTools) persistence.getTools()).foo();</programlisting></para>
      </section>
      <section id="persistenceHelper">
        <title>PersistenceHelper</title>
        <para>Вспомогательный класс для получения информации о персистентных сущностях. В отличие от бинов <code>Persistence</code> и <code>PersistenceTools</code> доступен на всех <link linkend="app_tiers">уровнях</link> приложения.</para>
        <para>Методы <code>PersistenceHelper</code>:<itemizedlist>
            <listitem>
              <para><code>isNew()</code> - определяет, является ли переданный экземпляр только что созданным, т.е. находящимся в состоянии <link linkend="entity_states">New</link>. Возвращает <code>true</code>, также если экземпляр не является персистентной сущностью.</para>
            </listitem>
            <listitem>
              <para><code>isDetached()</code> - определяет, находится ли переданный экземпляр в состоянии <link linkend="entity_states">Detached</link>. Возвращает <code>true</code>, также если экземпляр не является персистентной сущностью.</para>
            </listitem>
            <listitem>
              <para><code>isSoftDeleted()</code> - определяет, поддерживает ли переданный класс сущности <link linkend="soft_deletion">мягкое удаление</link></para>
            </listitem>
            <listitem>
              <para><code>getEntityName()</code> - возвращает имя сущности, заданное в <link linkend="entity_annotations">аннотации</link> <code>@Entity</code></para>
            </listitem>
            <listitem>
              <para><code>getTableName()</code> - возвращает имя таблицы БД, хранящей экземпляры сущности, заданное в <link linkend="entity_annotations">аннотации</link> <code>@Table</code></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="dbTypeConverter">
        <title>DbTypeConverter</title>
        <para>Интерфейс, определяющий методы для конвертации данных между значениями атрибутов <link linkend="data_model">модели данных</link> и параметрами и результатами запросов JDBC. Объект данного интерфейса можно получить методом <code><link linkend="persistence">Persistence</link>.getDbTypeConverter()</code>.</para>
        <para>Методы <code>DbTypeConverter</code>:<itemizedlist>
            <listitem>
              <para><code>getJavaObject()</code> - конвертирует результат JDBC запроса в тип, подходящий для присвоения атрибуту сущности. </para>
            </listitem>
            <listitem>
              <para><code>getSqlObject()</code> - конвертирует значение атрибута сущности в тип, подходящий для присвоения параметру JDBC запроса.</para>
            </listitem>
            <listitem>
              <para><code>getSqlType()</code> - возвращает константу из <code>java.sql.Types</code>, соответствующую переданному типу атрибута сущности.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="orm">
      <title>Слой ORM</title>
      <para>Object-Relational Mapping - объектно-реляционное отображение - технология связывания таблиц реляционной базы данных с объектами языка программирования. </para>
      <variablelist>
        <varlistentry>
          <term>Преимущества использования ORM:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>Позволяет работать с  данными реляционной СУБД, манипулируя объектами Java</para>
              </listitem>
              <listitem>
                <para>Упрощает программирование, избавляя от рутины написания тривиальных SQL-запросов</para>
              </listitem>
              <listitem>
                <para>Упрощает программирование, позволяя извлекать и сохранять целые графы объектов одной командой</para>
              </listitem>
              <listitem>
                <para>Обеспечивает легкое портирование приложения на различные СУБД</para>
              </listitem>
              <listitem>
                <para>Использует лаконичный язык запросов <glossterm linkend="jpql">JPQL</glossterm></para>
              </listitem>
              <listitem>
                <para>Оптимизирует количество выполняемых SQL-запросов на команды insert и update</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
        <varlistentry>
          <term>Недостатки:</term>
          <listitem>
            <itemizedlist>
              <listitem>
                <para>Требует понимания особенностей работы с ORM</para>
              </listitem>
              <listitem>
                <para>Не позволяет напрямую оптимизировать SQL или использовать особенности применяемой СУБД</para>
              </listitem>
            </itemizedlist>
          </listitem>
        </varlistentry>
      </variablelist>
      <para>В платформе <productname>CUBA</productname> используется реализация ORM по стандарту Java Persistence API на основе фреймворка <application>Apache OpenJPA</application>.</para>
      <section id="entityManager">
        <title>EntityManager</title>
        <para><code>EntityManager</code> - основной интерфейс ORM, служит для управления персистентными <link linkend="data_model">сущностями</link>.
</para>
        <para>Ссылку на <code>EntityManager</code>  можно получить через интерфейс <code>Persistence</code>,  вызовом метода  <code>getEntityManager()</code>.
Полученный экземпляр <code>EntityManager</code> привязан к текущей <link linkend="transactions">транзакции</link>, то есть все вызовы <code>getEntityManager()</code> в рамках одной транзакции возвращают один и тот же экземпляр <code>EntityManager</code>. После завершения транзакции обращения к данному экземпляру невозможны.
</para>
        <para>Экземпляр <code>EntityManager</code> содержит в себе &quot;персистентный контекст&quot; – набор экземпляров сущностей, загруженных из БД или только что созданных. Персистентный контекст является своего рода кэшем данных в рамках  транзакции.
<code>EntityManager</code> автоматически сбрасывает в БД все изменения, сделанные в его персистентном контексте, в момент коммита транзакции, либо при явном вызове метода  <code>flush()</code>.</para>
        <para>Интерфейс <code>EntityManager</code>, используемый в CUBA-приложениях, в основном повторяет стандартный <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/EntityManager.html">javax.persistence.EntityManager</ulink>. Рассмотрим его основные методы:<itemizedlist>
            <listitem>
              <para><code>persist()</code> - вводит <link linkend="entity_states">новый экземпляр</link> сущности в персистентный контекст. При коммите транзакции командой SQL <code>INSERT</code>  в БД будет создана соответствующая запись.</para>
            </listitem>
            <listitem>
              <para><code>merge()</code> - переносит состояние <link linkend="entity_states">отсоединенного экземпляра</link> сущности в персистентный контекст следующим образом: из БД  загружается экземпляр с тем же идентификатором, в него переносится состояние переданного Detached экземпляра и возвращается загруженный Managed экземпляр. Далее надо работать именно с возвращенным Managed экземпляром. При коммите транзакции командой SQL <code>UPDATE</code>  в БД будет сохранено состояние данного экземпляра.</para>
            </listitem>
            <listitem>
              <para><code>remove()</code> - удалить объект из базы данных, либо, если  включен режим <link linkend="soft_deletion">мягкого удаления</link>, установить атрибуты <code>deleteTs</code> и <code>deletedBy</code>.</para>
              <para>Если переданный экземпляр находится в Detached состоянии, сначала выполняется <code>merge()</code>.</para>
            </listitem>
            <listitem>
              <para><code>find()</code> - загружает экземпляр сущности по идентификатору. </para>
              <para>При формировании запроса к БД учитывается <link linkend="views">представление</link>, переданное в параметре данного метода, либо установленное для всего <code>EntityManager</code> методом <code>setView()</code>. В результате в персистентном контексте окажется граф объектов, для которого загружены все не-lazy атрибуты представления. Остальные атрибуты можно дозагрузить обращением к соответствующим методам доступа объектов, либо вызовом метода <code>fetch()</code>.</para>
            </listitem>
            <listitem>
              <para><code>createQuery()</code> - создать объект <code>Query</code> для выполнения <link linkend="query">JPQL запроса</link>. </para>
              <para>Рекомендуется использовать вариант метода с передачей класса сущности для получения экземпляра <code>TypedQuery</code>.</para>
            </listitem>
            <listitem>
              <para><code>createNativeQuery()</code> - создать объект <code>Query</code> для выполнения <link linkend="nativeQuery">SQL запроса</link>. </para>
            </listitem>
            <listitem>
              <para><code>setView()</code> - устанавливает <link linkend="views">представление</link> по умолчанию, с которым будет производиться последующая загрузка сущностей методом <code>find()</code> либо JPQL запросами. В результате <glossterm linkend="eager_fetching">жадно загружены</glossterm> будут все не-<literal>lazy</literal> атрибуты представления.</para>
              <para>Если в данный метод передать <code>null</code>, либо не вызывать его вообще, загрузка будет производиться в соответствие с правилами <link linkend="entity_annotations">аннотаций сущностей</link>.</para>
              <para>Представления, явно переданные в метод <code>find()</code> или установленные в объекте <code>Query</code> имеют приоритет над установленным данным методом.</para>
            </listitem>
            <listitem>
              <para><code>addView()</code> - аналогичен методу <code>setView()</code>, но в случае наличия уже установленного в <code>EntityManager</code> представления, не заменяет его, а добавляет атрибуты переданного представления.</para>
            </listitem>
            <listitem>
              <para><code>fetch()</code> - обеспечивает для экземпляра сущности загрузку всех атрибутов указанного <link linkend="views">представления</link>, включая <literal>lazy</literal> атрибуты. Экземпляр сущности должен быть в <link linkend="entity_states">Managed</link> состоянии.</para>
              <para>Данный метод рекомендуется вызывать перед коммитом транзакции, если представление содержит <literal>lazy</literal> атрибуты, а экземпляр сущности нужно отправить на клиентский уровень. В этом случае только после вызова <code>fetch()</code> можно быть уверенным, что все нужные клиентсткому коду атрибуты действительно загружены.</para>
            </listitem>
            <listitem>
              <para><code>reload()</code> - перезагрузить экземпляр сущности с указанным <link linkend="views">представлением</link>. Обеспечивает загрузку всех атрибутов представления, вызывая внутри себя метод <code>fetch()</code>. </para>
            </listitem>
            <listitem>
              <para><code>isSoftDeletion()</code> - проверяет, находится ли данный <code>EntityManager</code> в режиме <link linkend="soft_deletion">мягкого удаления</link>.</para>
            </listitem>
            <listitem>
              <para><code>setSoftDeletion()</code> - устанавливает режим <link linkend="soft_deletion">мягкого удаления</link> для данного экземпляра <code>EntityManager</code>.</para>
            </listitem>
            <listitem>
              <para><code>getConnection()</code> - возвращает  <code>java.sql.Connection</code>, через который выполняет запросы данный экземпляр <code>EntityManager</code>, и, соответственно, текущая транзакция. Закрывать такое соединение не нужно, оно будет закрыто при завершении транзакции.</para>
            </listitem>
            <listitem>
              <para><code>getDelegate()</code> - возвращает <code>javax.persistence.EntityManager</code>, предоставляемый реализацией ORM. </para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="entity_states">
        <title>Состояния сущности</title>
        <para><variablelist>
            <varlistentry>
              <term>New</term>
              <listitem>
                <para>Только что созданный в памяти экземпляр, например: <code>Car car = new Car()</code></para>
                <para>Новый экземпляр может быть передан в <methodname>EntityManager.persist()</methodname> для сохранения в БД, при этом он переходит в состояние Managed.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Managed</term>
              <listitem>
                <para>Загруженный из БД или новый, переданный в <methodname>EntityManager.persist()</methodname>, экземпляр. Принадлежит некоторому экземпляру <code>EntityManager</code>, другими словами, находится в его персистентном контексте.</para>
                <para>Любые изменения  экземпляра в состоянии Managed будут сохранены в БД в случае коммита транзакции, к которой принадлежит данный <code>EntityManager</code></para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Detached</term>
              <listitem>
                <para>Экземпляр, загруженный из БД и отсоединенный от своего персистентного контекста (вследствие закрытия транзакции или сериализации).</para>
                <para>Изменения, вносимые в Detached экземпляр, запоминаются в самом этом экземпляре (в полях, добавленных с помощью bytecode enhancement).
Эти изменения будут сохранены в БД, только если данный экземпляр будет снова переведен в состояние Managed путем передачи в метод <methodname>EntityManager.merge()</methodname>. </para>
              </listitem>
            </varlistentry>
          </variablelist></para>
      </section>
      <section id="lazy_loading">
        <title>Загрузка по требованию</title>
        <para>Загрузка по требованию (lazy loading) позволяет загружать связанные сущности отложенно, т.е. только в момент первого обращения к их свойствам.</para>
        <para>Загрузка по требованию  в сумме порождает больше запросов к БД, чем <glossterm linkend="eager_fetching">жадная загрузка (eager fetching)</glossterm>, однако нагрузка при этом растянута во времени.<itemizedlist>
            <listitem>
              <para>Например, при извлечении списка N экземпляров сущности A, содержащих ссылку на экземпляр сущности B, в случае загрузки по требованию будет выполнено N+1 запросов к базе данных.</para>
            </listitem>
            <listitem>
              <para>Для минимизации времени отклика и снижения нагрузки необходимо стремиться к меньшему количеству обращений к БД. Для этого  в платформе  используется механизм <link linkend="views">представлений</link>, с помощью которого в вышеописанном случае ORM может сформировать один  запрос к БД с объединением таблиц.</para>
            </listitem>
            <listitem>
              <para>Если A содержит коллекцию B, в случае жадной загрузки ORM сформирует SQL запрос, возвращающий произведение строк A и B. </para>
            </listitem>
            <listitem>
              <para>Иногда загрузка по требованию с точки зрения производительности предпочтительнее, чем жадная загрузка. Например, когда работает асинхронный процесс, выполняющий некоторую бизнес-логику, общее время выполнения некритично и желательно распределить во времени  нагрузку на БД.</para>
            </listitem>
          </itemizedlist></para>
        <para>Загрузка по требованию работает только для экземпляра в состоянии <link linkend="entity_states">Managed</link>, то есть внутри транзакции, загрузившей данный экземпляр.</para>
      </section>
      <section id="query">
        <title>Выполнение JPQL запросов</title>
        <para>Для выполнения <link linkend="jpql">JPQL</link> запросов предназначен интерфейс <code>Query</code>, ссылку на который  можно получить у текущего экземпляра <code>EntityManager</code> вызовом метода <code>createQuery()</code>. Если запрос предполагается использовать для извлечения сущностей, рекомендуется вызывать <code>createQuery()</code> с передачей типа результата, что приведет к созданию <code>TypedQuery</code>. </para>
        <para>Методы <code>Query</code> в основном соответствуют методам стандартного интерфейса <ulink url="http://docs.oracle.com/javaee/5/api/javax/persistence/Query.html">
            <code>javax.persistence.Query</code>
          </ulink>. Рассмотрим отличия.<itemizedlist>
            <listitem>
              <para><code>setParameter()</code> - устанавливает значение параметра запроса. При передаче в данный метод экземпляра сущности выполняет неявное преобразование экземпляра в его идентификатор. Например:<programlisting language="java">Customer customer = ...;
TypedQuery&lt;Order&gt; query = entityManager.createQuery(
    &quot;select o from sales$Order o where o.customer.id = ?1&quot;, Order.class);
query.setParameter(1, customer);</programlisting></para>
              <para>Обратите внимание на сравнение в запросе по идентификатору, но передачу в качестве параметра самого экземпляра сущности. </para>
              <para>Вариант метода с передачей <code>implicitConversions = false</code> не выполняет такого преобразования.</para>
            </listitem>
            <listitem>
              <para><code>setView()</code>, <code>addView()</code> - аналогичны одноименным методам интерфейса <code>EntityManager</code> - устанавливают <link linkend="views">представление</link>, используемое при загрузке данных текущим запросом, не влияя на представление всего <code>EntityManager</code>.</para>
            </listitem>
            <listitem>
              <para><code>getDelegate()</code> - возвращает экземпляр <code>javax.persistence.Query</code>, предоставляемый реализацией ORM.</para>
            </listitem>
          </itemizedlist></para>
        <para>При выполнении запроса через <code>Query</code> изменения в текущем персистентном контексте не учитываются, т.е. запрос просто выполняется в БД. Если результатом выборки являются экземпляры, уже находящиеся в персистентном контексте, то в результате запроса окажутся именно они, а не прочитанные из БД. Ситуацию поясняет следующий фрагмент теста:<programlisting language="java">TypedQuery&lt;User&gt; query;
List&lt;User&gt; list;

query = em.createQuery(&quot;select u from sec$User u where u.name = ?1&quot;, User.class);
query.setParameter(1, &quot;testUser&quot;);
list = query.getResultList();
assertEquals(1, list.size());
User user = list.get(0);

user.setName(&quot;newName&quot;);

query = em.createQuery(&quot;select u from sec$User u where u.name = ?1&quot;, User.class);
query.setParameter(1, &quot;testUser&quot;);
list = query.getResultList();
assertEquals(1, list.size());
User user1 = list.get(0);

assertTrue(user1 == user);</programlisting></para>
        <para>Такое поведение определяется параметром <code>openjpa.IgnoreChanges=true</code>, заданным в файле <link linkend="persistence.xml">
            <filename>persistence.xml</filename>
          </link> базового проекта <structname>cuba</structname>. В прикладном проекте данный параметр можно изменить, указав его в собственном <filename>persistence.xml</filename>.</para>
        <para>Запросы, модифицирующие данные (<code>update</code>, <code>delete</code>) приводят к сбросу (flush) в базу данных текущего персистентного контекста перед выполнением. Другими словами, ORM сначала синхронизирует состояние сущностей в персистентном контексте и в БД, а уже потом выполняет модифицирующий запрос. Рекомендуется выполнять такие запросы в неизмененном персистентном контексте, чтобы исключить неявные действия ORM, которые могут отрицательно сказаться на производительности.</para>
        <section>
          <title>Поиск подстроки без учета регистра</title>
          <para>Для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс <literal>(?i)</literal> в значении параметра запроса. Например, имеется запрос:<programlisting>select c from sales$Customer c where c.name like :name</programlisting></para>
          <para>Если в значении параметра <code>name</code> передать строку <userinput>(?i)%doe%</userinput>, то при наличии в БД записи со значением <userinput>John Doe</userinput> она будет найдена, несмотря на раличие в регистре символа. Это произойдет потому, что ORM выполнит SQL с условием вида <literal>lower(C.NAME) like ?</literal>.</para>
          <para>Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю <code>NAME</code>, не используется.</para>
        </section>
        <section id="jpql_macro">
          <title>Макросы в JPQL</title>
          <para>Текст JPQL запроса может включать макросы, которые обрабатываются перед выполнением и превращаются в исполняемый JPQL, дополнительно модифицируя набор параметров.</para>
          <para>Макросы, определенные в платформе, решают следующие задачи:<itemizedlist>
              <listitem>
                <para>Позволяют обойти принципиальную невозможность средствами JPQL выразить условие зависимости значения поля от текущего момента времени (не работает арифметика типа current_date-1)</para>
              </listitem>
              <listitem>
                <para>Позволяют сравнивать с датой поля типа Timestamp (содержащие дату+время)</para>
              </listitem>
            </itemizedlist></para>
          <para>Рассмотрим их подробно:<variablelist>
              <varlistentry>
                <term>@between</term>
                <listitem>
                  <para>Имеет вид <literal>@between(field_name, moment1, moment2, time_unit)</literal>, где <itemizedlist>
                      <listitem>
                        <para><literal>field_name</literal> - имя атрибута для сравнения </para>
                      </listitem>
                      <listitem>
                        <para><literal>moment1</literal>, <literal>moment2</literal> - моменты времени, в которые должно попасть значение атрибута <literal>field_name</literal>. Каждый из моментов должен быть определен выражением с участием переменной <literal>now</literal>, к которой может быть прибавлено или отнято целое число </para>
                      </listitem>
                      <listitem>
                        <para><literal>time_unit</literal> - определяет единицу измерения времени, которое прибавляется или вычитается из <literal>now</literal> в выражениях моментов, а также точность округления моментов. Может быть следующим: <literal>year</literal>, <literal>month</literal>, <literal>day</literal>, <literal>hour</literal>, <literal>minute</literal>, <literal>second</literal>. При включенном <link linkend="base_projects">базовом проекте</link> <structname>workflow</structname> можно также использовать единицы рабочего времени: <literal>workday</literal>, <literal>workhour</literal>, workminute. </para>
                      </listitem>
                    </itemizedlist></para>
                  <para>Макрос преобразуется в следующее выражение JPQL: <literal>field_name &gt;= :moment1 and field_name &lt; :moment2</literal></para>
                  <para>Пример 1. Покупатель создан сегодня:<programlisting>select c from sales$Customer where @between(c.createTs, now, now+1, day)</programlisting></para>
                  <para>Пример 2. Покупатель создан в течение последних 10 минут:<programlisting>select c from sales$Customer where @between(c.createTs, now-10, now, minute)</programlisting></para>
                  <para>Пример 3. Документы, датированные последними 5 рабочими днями (для проектов, включающих <structname>workflow</structname>): <programlisting>select d from sales$Doc where @between(d.createTs, now-5, now, workday)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@today</term>
                <listitem>
                  <para>Имеет вид <literal>@today(field_name)</literal> и обеспечивает формирование условия попадания значения атрибута в текущий день. По сути это частный случай макроса <literal>@between</literal>.</para>
                  <para>Пример.

Пользователь создан сегодня: <programlisting>select d from sales$Doc where @today(d.createTs)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@dateEquals</term>
                <listitem>
                  <para>Имеет вид <literal>@dateEquals(field_name, parameter)</literal> и позволяет сформировать условие попадания значения поля <literal>field_name</literal> типа <code>Timestamp</code> в дату, задаваемую параметром <literal>parameter</literal>.</para>
                  <para>Пример:<programlisting>select d from sales$Doc where @dateEquals(d.createTs, :param)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@dateBefore</term>
                <listitem>
                  <para>Имеет вид <literal>@dateBefore(field_name, parameter</literal>) и позволяет сформировать условие, что дата значения поля <literal>field_name</literal> типа <code>Timestamp</code> меньше даты, задаваемой параметром <literal>parameter</literal>.</para>
                  <para>Пример:<programlisting>select d from sales$Doc where @dateBefore(d.createTs, :param)</programlisting></para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>@dateAfter</term>
                <listitem>
                  <para>Имеет вид <literal>@dateAfter(field_name, parameter</literal>) и позволяет сформировать условие, что дата значения поля <literal>field_name</literal> типа <code>Timestamp</code>  больше или равна дате, задаваемой параметром <literal>parameter</literal>.</para>
                  <para>Пример:<programlisting>select d from sales$Doc where @dateAfter(d.createTs, :param)</programlisting></para>
                </listitem>
              </varlistentry>
            </variablelist></para>
          <para>Список макросов может быть расширен в прикладном проекте. Для создания нового макроса необходимо определить бин, реализующий интерфейс <code>QueryMacroHandler</code>, и задать ему <code>@Scope(&quot;prototype&quot;)</code>. Механизм выполнения JPQL  запросов создает все доступные бины типа <code>QueryMacroHandler</code>, и по очереди передает им текст запроса с набором параметров. Очередность вызова обработчиков не определена.</para>
        </section>
      </section>
      <section id="nativeQuery">
        <title>Выполнение SQL запросов</title>
        <para>ORM позволяет выполнять SQL запросы к базе данных, возвращая как списки отдельных полей, так и экземпляры сущностей. Для этого необходимо создать объект <code>Query</code> или <code>TypedQuery</code> вызовом одного из методов <code>EntityManager.createNativeQuery()</code>. </para>
        <para>Если  выполняется выборка отдельных колонок таблицы, то результирующий список будет содержать строки в виде <code>Object[]</code>. Например:<programlisting language="java">Query query = em.createNativeQuery(&quot;select ID, NAME from SALES_CUSTOMER where NAME like ?1&quot;);
query.setParameter(1, &quot;%Company%&quot;);
List list = query.getResultList();
for (Iterator it = list.iterator(); it.hasNext(); ) {
    Object[] row = (Object[]) it.next();
    UUID id = (UUID) row[0];
    String name = (String) row[1];
}</programlisting></para>
        <para>Следует иметь в виду, при использовании SQL колонки, соответствующие атрибутам сущностей типа <code>UUID</code>, возвращаются в виде <code>UUID</code> или в виде <code>String</code>, в зависимости от используемой СУБД и JDBC драйвера:<itemizedlist>
            <listitem>
              <para><application>HSQLDB</application> - <code>String</code></para>
            </listitem>
            <listitem>
              <para><application>PostgreSQL</application>, драйвер <filename>postgresql-8.3-603.jdbc4.jar</filename> - <code>String</code></para>
            </listitem>
            <listitem>
              <para><application>PostgreSQL</application>, драйвер <filename>postgresql-9.1-901.jdbc4.jar</filename> - <code>UUID</code></para>
            </listitem>
            <listitem>
              <para><application>Microsoft SQL Server</application>, драйвер <filename>jtds-1.2.4.jar</filename> - <code>String</code></para>
            </listitem>
            <listitem>
              <para><application>Oracle</application> - <code>String</code></para>
            </listitem>
          </itemizedlist></para>
        <para>Параметры этого типа также должны задаваться либо как <code>UUID</code>, либо своим строковым представлением, в зависимости от используемой СУБД и JDBC драйвера. Для обеспечения независимости кода от используемой СУБД рекомендуется использовать <code>
            <link linkend="dbTypeConverter">DbTypeConverter</link>
          </code>.</para>
        <para>Если вместе с текстом запроса передан класс результирующей сущности, то возвращается <code>TypedQuery</code> и после выполнения производится попытка отображения результатов запроса на атрибуты сущности. Например:<programlisting language="java">TypedQuery&lt;Customer&gt; query = em.createNativeQuery(
    &quot;select * from SALES_CUSTOMER where NAME like ?1&quot;, 
    Customer.class);
query.setParameter(1, &quot;%Company%&quot;);
List&lt;Customer&gt; list = query.getResultList();</programlisting></para>
        <para>Поведение SQL запросов, возвращающих сущности, и модифицирующих запросов (<code>update</code>, <code>delete</code>), по отношению к текущему персистентному контексту аналогично описанному для <link linkend="query">JPQL запросов</link>.</para>
        <para>См. также <xref linkend="queryRunner"/>.</para>
      </section>
      <section id="entity_listeners">
        <title>Entity Listeners</title>
        <para><firstterm>Entity Listeners</firstterm> предназначены для реакции на события жизненного цикла экземпляров сущностей на уровне<structname> Middleware</structname>.</para>
        <para>Слушатель представляет собой класс, реализующий один или несколько интерфейсов пакета <code>com.haulmont.cuba.core.listener</code>. Слушатель будет реагировать на события  типов, соответствующих реализуемым интерфейсам.</para>
        <variablelist>
          <varlistentry>
            <term>
              <code>BeforeDetachEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeDetach()</code> вызывается  перед отделением объекта от <link linkend="entityManager">EntityManager</link> при коммите транзакции.</para>
              <para>Данный слушатель можно использовать, например, для заполнения неперсистентных атрибутов сущности перед отправкой ее на клиентский уровень.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeAttachEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeAttach()</code> вызывается  перед введением объекта в персистентный контекст при выполнении операции <code>EntityManager.merge()</code>.</para>
              <para>Данный слушатель можно использовать, например, для заполнения персистентных атрибутов сущности перед сохранением ее в базе данных.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeInsertEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeInsert()</code> вызывается перед выполнением вставки записи в БД. В данном методе возможны любые операции с текущим <code>EntityManager</code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>AfterInsertEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onAfterInsert()</code> вызывается после выполнения вставки записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <link linkend="queryRunner">QueryRunner</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeUpdateEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeUpdate()</code> вызывается перед изменением записи в БД. В данном методе возможны любые операции с текущим <code>EntityManager</code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>AfterUpdateEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onAfterUpdate()</code> вызывается после изменения записи в БД, но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <code>QueryRunner</code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>BeforeDeleteEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onBeforeDelete()</code> вызывается перед удалением записи из БД (или в случае <link linkend="soft_deletion">мягкого удаления</link> - перед изменением записи). В данном методе возможны любые операции с текущим <code>EntityManager</code>.</para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
              <code>AfterDeleteEntityListener</code>
            </term>
            <listitem>
              <para>Метод <code>onAfterDelete()</code> вызывается после удаления записи из БД (или в случае мягкого удаления - после изменения записи), но до коммита транзакции. В данном методе нельзя модифицировать текущий персистентный контекст, однако можно производить изменения в БД с помощью <code>QueryRunner</code>.</para>
            </listitem>
          </varlistentry>
        </variablelist>
        <para>Entity Listener может быть как обычным классом Java, так и управляемым бином. В последнем случае в нем можно использовать инжекцию: <programlisting language="java">@ManagedBean(&quot;cuba_MyEntityListener&quot;)
public class MyEntityListener implements
        BeforeInsertEntityListener&lt;MyEntity&gt;,
        BeforeUpdateEntityListener&lt;MyEntity&gt; {

    @Inject
    protected Persistence persistence;

    @Override
    public void onBeforeInsert(MyEntity entity) {
        EntityManager em = persistence.getEntityManager();
        ...
    }

    @Override
    public void onBeforeUpdate(MyEntity entity) {
        EntityManager em = persistence.getEntityManager();
        ...
    }
}</programlisting></para>
        <para>Entity Listener  может быть задан 2-мя способами: <itemizedlist>
            <listitem>
              <para>Статически - имена классов слушателей, или, если слушатель является бином, имена бинов, указываются в аннотации <link linkend="listeners_annotation">@Listeners</link> на классе сущности:<programlisting language="java">@Entity(...)
@Table(...)
@Listeners(&quot;cuba_MyEntityListener&quot;)
public class MyEntity extends StandardEntity {
    ...
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Динамически - класс сущности и класс слушателя, или, если слушатель является бином, имя бина, передаются в метод <code>addListener()</code> бина <code>EntityListenerManager</code>. Пример динамического добавления слушателя рассматривается в разделе рецептов разработки: <xref linkend="app_start_recipe"/>. </para>
            </listitem>
          </itemizedlist></para>
        <para>Для всех экземпляров некоторого класса сущности извлекается из контекста Spring или создается и кэшируется <emphasis>один</emphasis> экземпляр слушателя определенного типа, поэтому слушатель <emphasis>не должен иметь состояния</emphasis>.</para>
        <para>Если для сущности объявлены несколько слушателей одного типа (например, аннотациями класса сущности и его предков, плюс динамически), то их вызов будет выполняться в следующем порядке:<orderedlist>
            <listitem>
              <para>Для каждого предка, начиная с самого дальнего, вызываются его динамически добавленные слушатели, затем статически назначенные.</para>
            </listitem>
            <listitem>
              <para>После всех предков вызываются  динамически добавленные слушатели  данного класса, затем статически назначенные.</para>
            </listitem>
          </orderedlist></para>
      </section>
    </section>
    <section id="transactions">
      <title>Управление транзакциями</title>
      <para>В данном разделе рассмотрены различные аспекты управления транзакциями в CUBA-приложениях.</para>
      <section>
        <title>Программное управление транзакциями</title>
        <para>Программное управление транзакциями осуществляется с помощью интерфейса <code>com.haulmont.cuba.core.Transaction</code>, ссылку на который можно получить методами <code>createTransaction()</code> или <code>getTransaction()</code> интерфейса инфраструктуры <code>
            <link linkend="persistence">Persistence</link>
          </code>.</para>
        <para>Метод <code>createTransaction()</code> создает новую транзакцию и возвращает интерфейс <code>Transaction</code>. Последующие вызовы методов <code>commit()</code>, <code>commitRetaining()</code>, <code>end()</code> этого интерфейса управляют созданной транзакцией. Если в момент создания существовала другая транзакция, то она будет приостановлена, и возобновлена после завершения созданной. </para>
        <para>Метод <code>getTransaction()</code> вызывает либо создание новой, либо присоединение к текущей транзакции. Если в момент вызова существовала активная транзакция, то метод успешно завершается, и последующие вызовы <code>commit()</code>, <code>commitRetaining()</code>, <code>end()</code> не оказывают никакого влияния на существующую транзакцию. Однако если <code>end()</code> вызван без предварительного вызова <code>commit()</code>, то текущая транзакция помечается как <code>RollbackOnly</code>.</para>
        <para>Пример ручного управления транзакцией:<programlisting language="java">@Inject
private Persistence persistence;
...
Transaction tx = persistence.createTransaction();
try {
    EntityManager em = persistence.getEntityManager();
    Customer customer = new Customer();
    customer.setName(&quot;John Smith&quot;);
    em.persist(customer);

    tx.commit();
} finally {
    tx.end();
}</programlisting></para>
        <para>Интерфейс Transaction имеет также метод execute(), принимающий на вход класс-действие, которое нужно выполнить в данной транзакции. Это позволяет организовать управление транзакциями в функциональном стиле, например:<programlisting language="java">persistence.createTransaction().execute(new Transaction.Runnable() {
    public void run(EntityManager em) {
        // transactional code here
    }
});</programlisting></para>
        <para>Если транзакционный блок должен вернуть результат, класс-действие должен реализовывать интерфейс <code>Transaction.Callable</code>. Если результат не требуется, как в приведенном примере, то класс-действие удобно наследовать от абстрактного класса <code>Transaction.Runnable</code>.</para>
        <para>Следует иметь в виду, что метод <code>execute()</code> у некоторого экземпляра <code>Transaction</code> можно вызвать только один раз, так как после выполнения кода класса-действия транзакция завершается.</para>
      </section>
      <section>
        <title>Декларативное управление транзакциями</title>
        <para>Любой метод <link linkend="managed_beans">управляемого бина</link> <structname>Middleware</structname> можно пометить аннотацией <code>@org.springframework.transaction.annotation.Transactional</code>, что вызовет автоматическое создание транзакции при вызове этого метода. В таком методе не нужно вызывать <code>Persistence.createTransaction()</code>, а можно сразу получать <code>EntityManager</code> и работать с ним.</para>
        <para>Для аннотации <code>@Transactional</code> можно указать параметры. Основным параметром является режим создания транзакции - <code>Propagation</code>. Значение <code>REQUIRED</code> соответствует <code>getTransaction()</code>, значение <code>REQUIRES_NEW</code> - <code>createTransaction()</code>. По умолчанию <code>REQUIRED</code>.
</para>
        <para>Декларативное управление транзакциями позволяет уменьшить количество <ulink url="http://en.wikipedia.org/wiki/Boilerplate_code">boilerplate кода</ulink>, однако имеет следующий недостаток: коммит транзакции происходит вне прикладного кода, что часто затрудняет отладку, т.к. скрывается момент отправки изменений в БД и перехода сущностей в состояние <link linkend="entity_states">Detached</link>. Кроме того, следует иметь в виду, что декларативная разметка сработает только в случае вызова метода контейнером, т.е. вызов транзакционного метода из другого метода того же самого объекта не приведет к старту транзакции.
</para>
        <para>В связи с этим рекомендуется применять декларативное управление транзакциями только для простых случаев типа метода <link linkend="services">сервиса</link>, читающего некоторый объект и возвращающего его на клиента. </para>
      </section>
      <section>
        <title>Примеры взаимодействия транзакций</title>
        <section>
          <title>Откат вложенной транзакции</title>
          <para>Если вложенная транзакция создана через <code>getTransaction()</code>, то ее откат приведет к невозможности коммита охватывающей транзакции. Например:<programlisting language="java">void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        // (1) вызываем метод, создающий вложенную транзакцию
        methodB();   

        // (4) в этот момент будет выброшено исключение, т.к. транзакция 
        //     помечена как rollback only
        tx.commit(); 
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.getTransaction();
    try {
        // (2) допустим здесь возникло исключение
        tx.commit();
    } catch (Exception e) {
        // (3) обрабатываем его и выходим
        return;    
    } finally {
        tx.end();
    }
}</programlisting></para>
          <para>Если же транзакция в <code>methodB()</code> будет создана через <code>createTransaction()</code>, то ее откат не окажет никакого влияния на коммит охватывающей транзакции в <code>methodA()</code>. </para>
        </section>
        <section>
          <title>Чтение и изменение данных во вложенной транзакции</title>
          <para>Рассмотрим сначала зависимую вложенную транзакцию, создаваемую через <code>getTransaction()</code>:<programlisting language="java">void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        EntityManager em = persistence.getEntityManager();
        
        // (1) загружаем сущность, в которой name == &quot;old name&quot;
        Employee employee = em.find(Employee.class, id); 
        assertEquals(&quot;old name&quot;, employee.getName());
        
        // (2) присваиваем новое значение полю 
        employee.setName(&quot;name A&quot;);                      
        
        // (3) вызываем метод, создающий вложенную транзакцию
        methodB();                                       
        
        // (8) здесь происходит коммит изменений в БД, и в ней 
        //     окажется значение &quot;name B&quot;
        tx.commit();                                     
                                                         
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.getTransaction();
    try {
        // (4) получаем тот же экземпляр EntityManager, что и methodA
        EntityManager em = persistence.getEntityManager(); 

        // (5) загружаем сущность с тем же идентификатором
        Employee employee = em.find(Employee.class, id);   

        // (6) значение поля новое, т.к. мы работаем с тем же
        //     персистентным контекстом, и обращения к БД вообще 
        //     не происходит
        assertEquals(&quot;name A&quot;, employee.getName());        
        employee.setName(&quot;name B&quot;);                        

        // (7) в этот момент реально коммита не происходит                        
        tx.commit();                                       
    } finally {
        tx.end();
    }
}</programlisting></para>
          <para>Теперь рассмотрим тот же самый пример с независимой вложенной транзакцией, создаваемой через <code>createTransaction()</code>: <programlisting language="java">void methodA() {
    Transaction tx = persistence.createTransaction();
    try {
        EntityManager em = persistence.getEntityManager();

        // (1) загружаем сущность, в которой name == &quot;old name&quot; 
        Employee employee = em.find(Employee.class, id); 
        assertEquals(&quot;old name&quot;, employee.getName());

        // (2) присваиваем новое значение полю 
        employee.setName(&quot;name A&quot;);                      

        // (3) вызываем метод, создающий вложенную транзакцию
        methodB();                                       

        // (8) здесь возникнет исключение из-за оптимистичной блокировки
        //     и коммит не пройдет вообще
        tx.commit();                                     
                                                         
    } finally {
        tx.end();
    }
}

void methodB() {
    Transaction tx = persistence.createTransaction();
    try {
        // (4) создается новый экземпляр EntityManager, т.к. это 
        //     новая транзакция                                       
        EntityManager em = persistence.getEntityManager(); 

        // (5) загружаем сущность с тем же идентификатором
        Employee employee = em.find(Employee.class, id);   

        // (6) значение поля старое, т.к. произошла загрузка из БД
        //     старого экземпляра сущности
        assertEquals(&quot;old name&quot;, employee.getName());      
                                                           
        employee.setName(&quot;name B&quot;);                        

        // (7) здесь происходит коммит изменений в БД, и в ней                         
        //     окажется значение &quot;name B&quot;
        tx.commit();                                       
                                                           
    } finally {
        tx.end();
    }
}</programlisting></para>
          <para>В последнем случае исключение в точке (8) возникнет, только если сущность является оптимистично блокируемой, т.е. если она реализует интерфейс <code>Versioned</code>.</para>
        </section>
      </section>
      <section id="transaction_timeout">
        <title>Таймаут транзакции</title>
        <para>Для создаваемой транзакции может быть указан таймаут в секундах, при превышении которого транзакция будет прервана и откачена. Таймаут транзакции  ограничивает максимальную длительность запросов к базе данных.</para>
        <para>При программном управлении транзакциями таймаут включается путем передачи объекта <code>TransactionParams</code> в метод <code>Persistence.createTransaction()</code>. Например:<programlisting language="java">Transaction tx = persistence.createTransaction(new TransactionParams().setTimeout(2));</programlisting></para>
        <para>При декларативном управлении транзакциями используется параметр <code>timeout</code> аннотации <code> @Transactional</code>, например:<programlisting language="java">@Transactional(timeout = 2)
public void someServiceMethod() {
...</programlisting></para>
        <para>Таймаут по умолчанию может быть задан в свойстве приложения <property>
            <link linkend="cuba.defaultQueryTimeoutSec">cuba.defaultQueryTimeoutSec</link>
          </property>. </para>
        <section>
          <title>Особенности реализации для различных СУБД</title>
          <para><application>PostgreSQL</application></para>
          <para>К сожалению, JDBC драйвер <application>PostgreSQL</application> не поддерживает метод <code>setQueryTimeout()</code> интерфейса <code>java.sql.Statement</code>, поэтому в начале каждой транзакции, для которой определен таймаут (любым способом, включая ненулевое значение  свойства <property>
              <link linkend="cuba.defaultQueryTimeoutSec">cuba.defaultQueryTimeoutSec</link>
            </property>), выполняется дополнительный оператор в БД: <code>set local statement_timeout to {value}</code>. При этом в случае превышения таймаута запрос будет прерван самим сервером БД. </para>
          <para>Для снижения нагрузки от этих дополнительных операторов рекомендуется поступать следующим образом: <itemizedlist>
              <listitem>
                <para>Таймаут по умолчанию устанавливать не на <structname>Middleware</structname> с помощью свойства <property>cuba.defaultQueryTimeoutSec</property>, а на самом сервере <application>PostgreSQL</application> в файле <filename>postgresql.conf</filename>, например, <literal>statement_timeout = 3000</literal> (это в миллисекундах). </para>
              </listitem>
              <listitem>
                <para>Для методов, которым требуется большее время таймаута (отчеты и пр.), явно указывать желаемый таймаут в параметрах транзакции. </para>
              </listitem>
            </itemizedlist></para>
          <para><application>Microsoft SQL Server</application></para>
          <para>Драйвер JTDS поддерживает метод <code>setQueryTimeout()</code> интерфейса <code>java.sql.Statement</code>, поэтому для <code>EntityManager</code> просто устанавливается стандартное свойство <literal>javax.persistence.query.timeout</literal>, которое соответствующим образом влияет на JDBC запросы. </para>
        </section>
      </section>
    </section>
    <section id="dataService">
      <title>DataService и DataWorker</title>
      <para><link linkend="managed_beans">Управляемый бин</link> <code>DataWorker</code> является универсальным средством для загрузки графов сущностей из базы данных, и для сохранения изменений, произведенных в <link linkend="entity_states">Detached</link> экземплярах сущностей. <link linkend="services">Сервис</link> <code>DataService</code> является фасадом для вызова <code>DataWorker</code> с клиентского <link linkend="app_tiers">уровня</link> приложения.</para>
      <para>Выделение бизнес-логики загрузки и сохранения в <code>DataWorker</code> дает возможность при необходимости создать свой сервис, делегирующий основную работу <code>DataWorker</code> и выполняющий дополнительные преобразования, например, перед возвратом данных на клиентский уровень.</para>
      <para><code>DataWorker</code> всегда стартует новую транзакцию и по завершении работы выполняет коммит, таким образом возвращая сущности в состоянии <link linkend="entity_states">Detached</link>.</para>
      <para>Методы <code>DataService</code> и <code>DataWorker</code>:<itemizedlist>
          <listitem>
            <para><code>load()</code>, <code>loadList()</code> - загружает граф сущностей в соответствии с параметрами переданного объекта <code>LoadContext</code>. </para>
            <para>В <code>LoadContext</code> обязательно должен быть передан либо JPQL-запрос, либо идентификатор сущности. Если передано и то и другое, используется запрос, а идентификатор игнорируется. </para>
            <para>Правила создания запросов аналогичны описанным в <xref linkend="query"/>. Отличием является то, что в запросе <code>LoadContext</code> могут быть использованы только именованные параметры, позиционные не поддерживаются.</para>
            <para>Методы <code>load()</code> и <code>loadList()</code> проверяют наличие у пользователя права <code>EntityOp.READ</code> на загружаемую сущность. Кроме того, при извлечении сущностей из БД накладываются ограничения групп доступа (см. руководство <productname>Подсистема безопасности</productname>). Для отмены действия ограничений в текущем запросе можно передать в <code>LoadContext</code> атрибут <code>useSecurityConstraints = false</code>.</para>
            <para>Примеры загрузки сущностей  в контроллере экрана:<programlisting language="java">@Inject
private DataService dataService;

private Book loadBookById(UUID bookId) {
    LoadContext loadContext = new LoadContext(Book.class)
            .setId(bookId).setView(&quot;book.edit&quot;);
    return dataService.load(loadContext);
}

private List&lt;BookPublication&gt; loadBookPublications(UUID bookId) {
    LoadContext loadContext = new LoadContext(BookPublication.class)
            .setView(&quot;bookPublication.full&quot;);
    loadContext.setQueryString(&quot;select p from library$BookPublication p where p.book.id = :bookId&quot;)
            .setParameter(&quot;bookId&quot;, bookId);
    return dataService.loadList(loadContext);
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>commit()</code> - сохраняет в базе данных набор сущностей, переданный в объекте <code>CommitContext</code>. Отдельно указываются коллекции сущностей, которые нужно сохранить, и которые нужно удалить.</para>
            <para>Метод возвращает набор экземпляров сущностей, возвращенных из метода <code>EntityManager.merge()</code>, то есть по сути свежие экземпляры, только что обновленные в БД. Дальнейшая работа должна производиться именно с этими возвращенными экземплярами, чтобы предотвратить потерю данных или исключения оптимистичной блокировки. Для того, чтобы обеспечить наличие нужных атрибутов у возвращенных сущностей, с помощью мэп <code>CommitContext.getViews()</code> можно указать <link linkend="views">представление</link> для каждого сохраняемого экземпляра. </para>
            <para>Метод <code>commit()</code>  проверяет наличие у пользователя права <code>EntityOp.UPDATE</code> на изменяемые сущности, и <code>EntityOp.DELETE</code> на  удаляемые. </para>
            <para>Примеры сохранения коллекций сущностей:<programlisting language="java">@Inject
private DataService dataService;

/**
 * @param toSave    entities to update in the database
 * @param toDelete  entities to delete from the database
 */
private void saveBookInstances(List&lt;BookInstance&gt; toSave, List&lt;BookInstance&gt; toDelete) {
    CommitContext commitContext = new CommitContext(toSave, toDelete);
    dataService.commit(commitContext);
}

/**
 * @param toSave    entities to update in the database    
 * @param view      view to fetch each updated entity before returning it back to the client
 * @return          set of updated entities, fetched according to the view
 */
private Set&lt;Entity&gt; saveAndReturnBookInstances(List&lt;BookInstance&gt; toSave, View view) {
    CommitContext commitContext = new CommitContext();
    for (BookInstance bookInstance : toSave) {
        commitContext.getCommitInstances().add(bookInstance);
        commitContext.getViews().put(bookInstance, view);
    }
    return dataService.commit(commitContext);
}</programlisting></para>
          </listitem>
          <listitem>
            <para><code>commitNotDetached()</code> - аналогичен методу <code>commit()</code>, но предназначен для сохранения в БД экземпляров, у которых отсутствует информация о <link linkend="entity_states">Detached</link> состоянии. Такие экземпляры сущностей могут быть переданы с клиентов, которые работают не напрямую с объектами, загруженными <structname>Middleware</structname>, а с дополнительными Data Transfer Objects, либо вообще не с Java объектами, а с их XML или JSON представлением (как, например, клиенты <link linkend="rest_api">REST API</link>)</para>
          </listitem>
        </itemizedlist></para>
      <para>В процессе загрузки данных <code>DataWorker</code> может реализовывать дополнительную функциональность, описанную ниже.</para>
      <section>
        <title>Запросы с distinct</title>
        <para>В JPQL запросах для экранов со списками сущностей, в которых включено постраничное отображение и возможна непредсказуемая модификация запроса <link linkend="gui_Filter">универсальным фильтром</link> или механизмом ограничений групп доступа, при отсутствии в запросе оператора <literal>distinct</literal> может возникать следующий эффект: <itemizedlist>
            <listitem>
              <para>при объединении с коллекцией на уровне извлечения из базы данных возникает набор с дубликатами строк</para>
            </listitem>
            <listitem>
              <para>на клиентском уровне в источнике данных дубликаты исчезают, т.к. попадают в мэп (<code>java.util.Map</code>) </para>
            </listitem>
            <listitem>
              <para>при постраничном отображении на одной странице оказывается меньшее количество строк, чем запрошено, общее количество строк наоборот завышено.</para>
            </listitem>
          </itemizedlist></para>
        <para>Таким образом, рекомендуется в JPQL запросы браузеров включать предложение <literal> distinct</literal>, которое гарантирует отсутствие дубликатов записей при выборке из базы данных. Однако в некоторых серверах БД (в частности <application>PostgreSQL</application>) при большом количестве извлекаемых записей (более 10000) SQL запрос с <literal>distinct</literal> выполняется недопустимо долго.</para>
        <para>Для решения этой проблемы в платформе реализована возможность корректной работы без <literal>distinct</literal> на уровне SQL. Данный механизм включается свойством приложения <property>
            <link linkend="cuba.inMemoryDistinct">cuba.inMemoryDistinct</link>
          </property>, при активации которого выполняется следующее: <itemizedlist>
            <listitem>
              <para>В JPQL запросе должен по-прежнему присутствовать <literal>select distinct</literal></para>
            </listitem>
            <listitem>
              <para>В <code>DataWorker</code> из JPQL запроса перед отправкой в ORM <literal>distinct</literal> вырезается  </para>
            </listitem>
            <listitem>
              <para>После загрузки страницы данных на <structname>Middleware</structname> удаляются дубликаты и выполняются дополнительные запросы к БД для получения нужного количества строк, которые затем и возвращаются клиенту.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="query_from_selected">
        <title>Последовательная выборка</title>
        <para><code>DataWorker</code> может выполнять последовательную выборку данных из результатов предыдущего запроса. Эта возможность используется в <link linkend="gui_Filter">универсальном фильтре</link> при последовательном наложении фильтров. </para>
        <para>Данный механизм работает следующим образом:<itemizedlist>
            <listitem>
              <para>При получении <code>LoadContext</code> с установленными атрибутами <code>prevQueries</code> и <code>queryKey</code> <code>DataWorker</code> выполняет выборку по предыдущему запросу и сохраняет идентификаторы полученных сущностей в таблице <database>SYS_QUERY_RESULT</database> (соответствующей сущности <literal>sys$QueryResult</literal>), разделяя наборы записей по идентификаторам пользовательских сессий и ключу сеанса выборки <code>queryKey</code>. </para>
            </listitem>
            <listitem>
              <para>Текущий запрос модифицируется для объединения с результатами предыдущего, так что в итоге возвращает данные, соответствующие условиям обоих запросов, объединенных по &quot;И&quot;.</para>
            </listitem>
            <listitem>
              <para>Далее процесс может повторяться, при  этом уменьшающийся набор предыдущих результатов удаляется из таблицы <database>SYS_QUERY_RESULT</database> и заполняется заново.</para>
            </listitem>
          </itemizedlist></para>
        <para>Таблицу <database>SYS_QUERY_RESULT</database> необходимо периодически чистить от ненужных результатов запросов, оставленных завершенными пользовательскими сессиями. Для этого предназначен метод <code>deleteForInactiveSessions</code> бина <code>QueryResultsManagerAPI</code>. В прикладном проекте с включенным параметром <property>
            <link linkend="cuba.allowQueryFromSelected">cuba.allowQueryFromSelected</link>
          </property> необходимо вызывать этот метод из <link linkend="scheduled_tasks">назначенных заданий</link>, например:<programlisting language="xml">&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;cuba_QueryResultsManager&quot; method=&quot;deleteForInactiveSessions&quot; fixed-rate=&quot;600000&quot;/&gt;
&lt;/task:scheduled-tasks&gt;</programlisting></para>
      </section>
    </section>
  </section>
  <section id="gui_framework">
    <title>Универсальный пользовательский интерфейс</title>
    <para>Подсистема универсального пользовательского интерфейса (Generic UI, GUI) позволяет разрабатывать экраны пользовательского интерфейса, используя  XML и Java. Созданные таким образом экраны одинаково работоспособны в двух
стандартных клиентских <link linkend="app_tiers">блоках</link>: <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
    <figure>
      <title>Структура универсального пользовательского интерфейса </title>
      <mediaobject>
        <imageobject>
          <imagedata align="center" fileref="img/ClientStructure.png"/>
        </imageobject>
      </mediaobject>
    </figure>
    <para>Здесь в центре изображены основные составляющие  экранов универсального пользовательского интерфейса:<itemizedlist>
        <listitem>
          <para><link linkend="screen_xml">XML-дескрипторы</link> - файлы XML, содержащие информацию об источниках данных и компоновке
экрана</para>
        </listitem>
        <listitem>
          <para><link linkend="screen_controller">Контроллеры</link> - классы Java, содержащие логику инициализации экрана
и обработки событий от элементов пользовательского интерфейса.</para>
        </listitem>
      </itemizedlist></para>
    <para>Код экранов приложения, расположенный в <link linkend="app_modules">модуле</link> <structname>gui</structname>,  взаимодействует с интерфейсами визуальных
компонентов (VCL Interfaces), реализованными по-отдельности в модулях <structname>web</structname>  и <structname>desktop</structname> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname>. Для <structname>Web Client</structname> реализация основана на фреймворке <application>Vaadin</application>, для <structname>Desktop Client</structname> – на фреймворке <application>Java Swing</application>.</para>
    <para><link linkend="gui_vcl">Библиотека визуальных компонентов</link> (Visual Components Library, VCL)
содержит большой набор готовых компонентов для отображения данных.</para>
    <para>Механизм <link linkend="datasources">источников данных</link>  (Datasources) предоставляет унифицированный
интерфейс, обеспечивающий
функционирование
связанных
с
данными визуальных компонентов.</para>
    <para>Инфраструктура клиента  (Infrastructure) включает в себя главное окно приложения,
механизмы отображения и взаимодействия  экранов UI, а также средства
взаимодействия со средним слоем.</para>
    <section id="screens">
      <title>Экраны</title>
      <para>Экран универсального пользовательского интерфейса состоит из <link linkend="screen_xml">XML-дескриптора</link> и класса <link linkend="screen_controller">контроллера</link>. Дескриптор содержит ссылку на класс контроллера. </para>
      <para>Для того чтобы экран можно было вызывать из главного меню или из Java кода (например, из контроллера другого экрана), XML-дескриптор должен быть зарегистрирован в файле <link linkend="screens.xml">
          <filename>screens.xml</filename>
        </link> проекта.</para>
      <para>Главное меню приложения формируется отдельно для <structname>Web Client</structname> и <structname>Desktop Client</structname> на основе файлов <filename>
          <link linkend="menu.xml">menu.xml</link>
        </filename>, расположенных соответственно в модулях <structname>web</structname> и <structname>desktop</structname> проекта.</para>
      <section>
        <title>Типы экранов</title>
        <para>В данном разделе рассматриваются основные типы экранов:<itemizedlist>
            <listitem>
              <para><link linkend="frame">Фрейм</link></para>
            </listitem>
            <listitem>
              <para><link linkend="screen_simple">Простой экран</link></para>
            </listitem>
            <listitem>
              <para><link linkend="screen_lookup">Экран выбора</link></para>
            </listitem>
            <listitem>
              <para><link linkend="screen_edit">Экран редактирования</link></para>
            </listitem>
          </itemizedlist></para>
        <section id="frame">
          <title>Фрейм</title>
          <para>Фреймы представляют собой части экранов, которые применяются для декомпозиции и многократного использования.</para>
          <para>Для подключения фрейма в XML экрана используется элемент <link linkend="gui_IFrame">
              <sgmltag>iframe</sgmltag>
            </link> c указанием либо пути к файлу XML фрейма, либо идентификатора фрейма, если он зарегистрирован в  <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link>.</para>
          <para>Контроллер фрейма должен быть унаследован от класса <link linkend="abstractFrame">AbstractFrame</link>.</para>
          <para>Правила взаимодействия экрана и вложенного в него фрейма:</para>
          <itemizedlist>
            <listitem>
              <para>Из экрана обращаться к компонентам фрейма можно через точку: <code>frame_id.component_id</code></para>
            </listitem>
            <listitem>
              <para>Из контроллера фрейма получить компонент экрана  можно обычным вызовом <code>getComponent(component_id)</code> или <link linkend="screen_controller_injection">инжекцией</link>, но только в том случае, если компонент с таким именем не объявлен в самом фрейме. То есть компоненты фрейма маскируют компоненты экрана.</para>
            </listitem>
            <listitem>
              <para>Из фрейма получить <link linkend="datasources">источник данных</link> экрана можно простым вызовом <code>getDsContext().get(ds_id)</code> или <link linkend="screen_controller_injection">инжекцией</link>, либо в <link linkend="datasource_query">запросе</link> <code>ds$ds_id</code>, но только в том случае, если источник данных с таким именем не объявлен в самом фрейме (аналогично компонентам).</para>
            </listitem>
            <listitem>
              <para>Из экрана получить источник данных фрейма можно только через итерацию по <code>getDsContext().getChildren()</code></para>
            </listitem>
          </itemizedlist>
          <para>При коммите экрана вызывается также коммит измененных источников  данных фрейма.</para>
        </section>
        <section id="screen_simple">
          <title>Простой экран</title>
          <para>Простой экран предназначен для отображения и редактирования произвольной информации, в том числе отдельных экземпляров и списков сущностей. Данный тип экрана имеет только базовую функциональность, позволяющую отобразить его в главном окне системы, закрыть, а также работать с <link linkend="datasources">источниками данных</link>.</para>
          <para>Идентификатор экрана в файле <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link> может быть произвольного вида.</para>
          <para>Контроллер простого экрана должен быть унаследован от класса <link linkend="abstractWindow">AbstractWindow</link>. </para>
        </section>
        <section id="screen_lookup">
          <title>Экран выбора</title>
          <para>Экран выбора (lookup) отличается от простого экрана тем, что при вызове методом <code>openLookup()</code> отображает внизу панель с кнопками, позволяющими передать вызывающему коду экземпляр выбранной в данный момент в списке сущности. При вызове методом <code>openWindow()</code> или, например, из главного меню, панель с кнопками выбора не отображается.</para>
          <para>В метод <code>openLookup()</code> передается объект с интерфейсом <code>Window.Lookup.Handler</code>. Метод <code>handleLookup()</code> этого объекта вызывается экраном, и ему передается коллекция выбранных пользователем экземпляров сущности. Тем самым вызывающий код получает из экрана выбранные экземпляры. </para>
          <para>Экраны  выбора рекомендуется использовать для отображения списков сущностей. Визуальные компоненты, предназначенные для отображения и редактирования ссылок между сущностями (такие как <code>
              <link linkend="gui_PickerField">PickerField</link>
            </code>, <code>
              <link linkend="gui_LookupPickerField">LookupPickerField</link>
            </code>, <code>
              <link linkend="gui_SearchPickerField">SearchPickerField</link>
            </code>), вызывают экраны выбора для поиска связанных сущностей. </para>
          <para>Для корректной работы <link linkend="standard_actions">стандартных действий</link> идентификатор экрана выбора  в файле <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link> должен иметь вид <literal>{имя_сущности}.lookup</literal>, например, <literal>sales$Customer.lookup</literal>.</para>
          <para>Контроллер экрана выбора должен быть унаследован от класса <link linkend="abstractLookup">AbstractLookup</link>. В XML экрана в атрибуте <sgmltag>lookupComponent</sgmltag> должен быть указан компонент (например, <code>
              <link linkend="gui_Table">Table</link>
            </code>), из которого будет взят экземпляр сущности при выборе.</para>
        </section>
        <section id="screen_edit">
          <title>Экран редактирования</title>
          <para>Экран редактирования предназначен для отображения и редактирования  экземпляра сущности. Поддерживает функциональность установки редактируемого экземпляра и <link linkend="gui_Action">действия</link> по  коммиту изменений в базу данных. Экран редактирования должен вызываться методом <code>openEditor()</code> с передачей экземпляра сущности.</para>
          <para>Для корректной работы <link linkend="standard_actions">стандартных действий</link> идентификатор экрана редактирования в файле <link linkend="screens.xml">
              <filename>screens.xml</filename>
            </link> должен иметь вид <literal>{имя_сущности}.edit</literal>, например, <literal>sales$Customer.edit</literal>.</para>
          <para>Контроллер экрана редактирования  должен быть унаследован от класса <link linkend="abstractEditor">AbstractEditor</link>. В XML экрана в атрибуте <sgmltag>datasource</sgmltag> указывается источник данных, в который проставляется редактируемый экземпляр сущности. Для отображения действий, выполняющих коммит или отмену изменений, в XML можно использовать следующие стандартные фреймы с кнопками:<itemizedlist>
              <listitem>
                <para><literal>editWindowActions</literal> (файл <filename>com/haulmont/cuba/gui/edit-window.actions.xml</filename>) - содержит кнопки <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton></para>
              </listitem>
              <listitem>
                <para><literal>extendedEditWindowActions</literal> (файл <filename>com/haulmont/cuba/gui/extended-edit-window.actions.xml</filename>) - содержит кнопки <guibutton>OK &amp; Close</guibutton>, <guibutton>OK</guibutton> и <guibutton>Cancel</guibutton></para>
              </listitem>
            </itemizedlist></para>
          <para>В экране редактирования неявно создаются следующие действия:<itemizedlist>
              <listitem>
                <para><literal>windowCommitAndClose</literal> (соответствует константе <code>Window.Editor.WINDOW_COMMIT_AND_CLOSE</code>) - действие, выполняющее коммит изменений в базу данных и закрывающее экран. Создается  при наличии в экране визуального компонента с идентификатором <literal>windowCommitAndClose</literal>, в частности, при использовании вышеописанного стандартного фрейма <literal>extendedEditWindowActions</literal> отображается кнопкой <guibutton>OK &amp; Close</guibutton>.</para>
              </listitem>
              <listitem>
                <para><literal>windowCommit</literal> (соответствует константе <code>Window.Editor.WINDOW_COMMIT</code>) - действие, выполняющее коммит изменений в базу данных. При отсутствии действия <literal>windowCommitAndClose</literal> после коммита закрывает экран. Создается всегда, и при наличии в экране  вышеописанных стандартных фреймов отображается кнопкой <guibutton>OK</guibutton>.</para>
              </listitem>
              <listitem>
                <para><literal>windowClose</literal> (соответствует константе <code>Window.Editor.WINDOW_CLOSE</code>) - действие, закрывающее экран без коммита изменений. Создается всегда, и при наличии в экране  вышеописанных стандартных фреймов отображается кнопкой <guibutton>Cancel</guibutton>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Таким образом, если  в экран добавлен фрейм <literal>editWindowActions</literal>, то кнопка <guibutton>OK</guibutton> коммитит изменения и закрывает экран, а кнопка <guibutton>Cancel</guibutton> - закрывает без коммита. Если же добавлен фрейм <literal>extendedEditWindowActions</literal>, то кнопка <guibutton>OK</guibutton> только коммитит изменения, оставляя экран открытым, кнопка <guibutton>OK &amp; Close</guibutton> коммитит и закрывает экран, кнопка <guibutton>Cancel</guibutton> - закрывает без коммита.</para>
          <para>Вместо стандартных фреймов для отображения действий можно использовать произвольные компоненты, например, <code>
              <link linkend="gui_LinkButton">LinkButton</link>
            </code>.</para>
        </section>
      </section>
      <section id="screen_xml">
        <title>XML-дескриптор</title>
        <para>XML-дескриптор - это файл формата XML, описывающий <link linkend="datasources">источники данных</link> и расположение визуальных компонентов экрана.</para>
        <para>Схема XML доступна по адресу <ulink url="http://schemas.haulmont.com/cuba/5.3/window.xsd">http://schemas.haulmont.com/cuba/5.3/window.xsd</ulink></para>
        <para>Рассмотрим структуру дескриптора.</para>
        <para><sgmltag>window</sgmltag> − корневой элемент.</para>
        <para>Атрибуты <sgmltag>window</sgmltag>:<itemizedlist>
            <listitem>
              <para><property>
                  <sgmltag>class</sgmltag>
                </property> − имя класса <link linkend="screen_controller">контроллера</link></para>
            </listitem>
            <listitem>
              <para><sgmltag>messagesPack</sgmltag> −  <link linkend="message_packs">пакет сообщений</link> данного экрана, который будет использован при получении локализованных строк  без указания  пакета из XML-дескриптора и из контроллера методом <code>getMessage()</code></para>
            </listitem>
            <listitem>
              <para><sgmltag>caption</sgmltag> − заголовок экрана, может содержать <link linkend="messageTools.loadString">ссылку на сообщение</link> из вышеуказанного пакета, например, <programlisting>caption=&quot;msg://caption&quot;</programlisting></para>
            </listitem>
            <listitem>
              <para><sgmltag>focusComponent</sgmltag> − идентификатор компонента, который получит фокус ввода при отображении экрана</para>
            </listitem>
            <listitem>
              <para><sgmltag>lookupComponent</sgmltag> - обязательный для <link linkend="screen_lookup">экрана выбора</link> атрибут, задающий идентификатор визуального компонента, из которого будет выбран экземпляр сущности. Поддерживаются компоненты следующих типов (и их наследников):<itemizedlist>
                  <listitem>
                    <para><code>Table</code></para>
                  </listitem>
                  <listitem>
                    <para><code>Tree</code></para>
                  </listitem>
                  <listitem>
                    <para><code>LookupField</code></para>
                  </listitem>
                  <listitem>
                    <para><code>PickerField</code></para>
                  </listitem>
                  <listitem>
                    <para><code>OptionsGroup</code></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
            <listitem>
              <para><sgmltag>datasource</sgmltag> - обязательный для <link linkend="screen_edit">экрана редактирования</link> атрибут, задающий идентификатор <link linkend="datasources">источника данных</link>, в который будет проставлен экземпляр редактируемой сущности.</para>
            </listitem>
          </itemizedlist></para>
        <para>Элементы <sgmltag>window</sgmltag>:<itemizedlist>
            <listitem>
              <para><sgmltag>metadataContext</sgmltag> −  элемент для инициализации <link linkend="views">представлений</link> (views), необходимых данному экрану. Предпочтительным является определение всех представлений в одном общем файле <filename>
                  <link linkend="views.xml">views.xml</link>
                </filename>, так как все описатели представлений разворачиваются в один общий репозиторий, и при рассредоточении описателей по разным файлам трудно обеспечить уникальность имен.</para>
            </listitem>
            <listitem>
              <para><sgmltag>dsContext</sgmltag> −  определяет <link linkend="datasources">источники данных</link> данного экрана.</para>
            </listitem>
            <listitem>
              <para><sgmltag>actions</sgmltag> -  определяет список <link linkend="gui_Action">действий</link> данного экрана.</para>
            </listitem>
            <listitem>
              <para><sgmltag>timers</sgmltag> -  определяет список таймеров данного экрана.</para>
            </listitem>
            <listitem>
              <para><sgmltag>companions</sgmltag> -  определяет список классов-<link linkend="companions">компаньонов</link> данного контроллера</para>
              <para>Элементы <sgmltag>companions</sgmltag>:<itemizedlist>
                  <listitem>
                    <para><sgmltag>web</sgmltag> - задает компаньон, реализованный в модуле <structname>web</structname></para>
                  </listitem>
                  <listitem>
                    <para><sgmltag>desktop</sgmltag> - задает компаньон, реализованный в модуле <structname>desktop</structname></para>
                  </listitem>
                </itemizedlist></para>
              <para>Каждый из этих элементов содержит атрибут <sgmltag>class</sgmltag>, задающий класс компаньона.</para>
            </listitem>
            <listitem>
              <para><sgmltag>layout</sgmltag> − корневой элемент компоновки экрана. Является сам по себе контейнером с вертикальным расположением компонентов, аналогичным <link linkend="gui_BoxLayout">
                  <sgmltag>vbox</sgmltag>
                </link>.</para>
              <para>Атрибуты <sgmltag>layout</sgmltag>:<itemizedlist>
                  <listitem>
                    <para><link linkend="gui_attr_basic_spacing">
                        <sgmltag>spacing</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="gui_attr_basic_margin">
                        <sgmltag>margin</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="gui_attr_basic_expand">
                        <sgmltag>expand</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="gui_attr_basic_stylename">
                        <sgmltag>stylename</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="gui_attr_basic_height">
                        <sgmltag>height</sgmltag>
                      </link></para>
                  </listitem>
                  <listitem>
                    <para><link linkend="gui_attr_basic_width">
                        <sgmltag>width</sgmltag>
                      </link></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="screen_controller">
        <title>Контроллер экрана</title>
        <para>Контроллер экрана - это <code>Java</code> или <code>Groovy</code> класс, связанный с <link linkend="screen_xml">XML-дескриптором</link>, и содержащий логику инициализации и обработки событий экрана.</para>
        <para>Контроллер должен быть унаследован от одного из следующих базовых классов:</para>
        <itemizedlist>
          <listitem>
            <para><code>
                <link linkend="abstractFrame">AbstractFrame</link>
              </code> − предназначен для реализации <link linkend="frame">фреймов</link>.</para>
          </listitem>
          <listitem>
            <para><code>
                <link linkend="abstractWindow">AbstractWindow</link>
              </code> − предназначен для реализации <link linkend="screen_simple">простых экранов</link>.</para>
          </listitem>
          <listitem>
            <para><code>
                <link linkend="abstractLookup">AbstractLookup</link>
              </code> − предназначен для реализации <link linkend="screen_lookup">экранов выбора</link>.</para>
          </listitem>
          <listitem>
            <para><code>
                <link linkend="abstractEditor">AbstractEditor</link>
              </code> − предназначен для реализации <link linkend="screen_edit">экранов редактирования</link>.</para>
          </listitem>
        </itemizedlist>
        <tip>
          <para>Если экрану не нужна никакая дополнительная логика, то в качестве контроллера можно использовать сам базовый класс <code>AbstractWindow</code>, <code>AbstractLookup</code> или <code>AbstractEditor</code>, указав его в XML-дескрипторе (эти классы на самом деле не являются абстрактными в смысле невозможности создания экземпляров). Для фрейма класс контроллера можно не указывать вообще.</para>
        </tip>
        <para>Класс контроллера должен быть зарегистрирован в XML-дескрипторе экрана в атрибуте <sgmltag>class</sgmltag> корневого элемента <sgmltag>window</sgmltag>.</para>
        <figure>
          <title>Базовые классы контроллеров</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/Controllers.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <section id="abstractFrame">
          <title>AbstractFrame</title>
          <para><code>AbstractFrame</code> является корнем иерархии классов контроллеров. Рассмотрим его основные методы:</para>
          <itemizedlist>
            <listitem id="abstractFrame.init">
              <para><code>init()</code> - вызывается фреймворком после создания всего дерева компонентов, описанного XML-дескриптором, но до отображения экрана.</para>
              <para>В метод <methodname>init()</methodname> из вызывающего кода передается мэп параметров, которые могут быть использованы  внутри контроллера. Эти параметры могут быть переданы как из кода контроллера вызывающего экрана (в методе <code>openWindow()</code>, <code>openLookup()</code> или <code>openEditor()</code>), так и установлены в файле регистрации экранов <filename>
                  <link linkend="screens.xml">screens.xml</link>
                </filename>.</para>
              <para>Метод <code>init()</code> следует имплементировать при необходимости  инициализации компонентов экрана, например:<programlisting language="java">@Inject
private Table someTable;

@Override
public void init(Map&lt;String, Object&gt; params) {
    someTable.addGeneratedColumn(&quot;someColumn&quot;, new Table.ColumnGenerator&lt;Colour&gt;() {
        @Override
        public Component generateCell(Colour entity) {
            ...
        }
    });
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>getMessage()</code>, <code>formatMessage()</code> - методы получения локализованных сообщений из <link linkend="message_packs">пакета</link>, заданного для экрана в XML-дескрипторе. Представляют собой просто короткие варианты вызова одноименных методов интерфейса <code>
                  <link linkend="messages">Messages</link>
                </code>.</para>
            </listitem>
            <listitem>
              <para><code>getDialogParams()</code> - получить объект <code>DialogParams</code> для установки параметров отображения диалоговых окон (высота, ширина и пр.). Значения, установленные в этом объекте, влияют на следующий экран, открываемый в режиме модального диалога (<code>WindowManager.OpenType.DIALOG</code>). После отображения диалога они сбрасываются в значения по умолчанию.</para>
              <para>Таким образом,  устанавливать значения в <code>DialogParams</code> необходимо непосредственно перед вызовом другого экрана в режиме диалога методами <code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code>. Например:<programlisting language="java">getDialogParams().setWidth(400);
openEditor(&quot;sales$Customer.edit&quot;, customer, WindowManager.OpenType.DIALOG);</programlisting></para>
              <para>Если же сам текущий экран открывается в режиме модального диалога, то можно управлять параметрами его отображения, устанавливая параметры <code>DialogParams</code>  в его методе <code>init()</code>. При этом установленные в <code>init()</code> параметры имеют приоритет над установленными в вызывающем коде.</para>
            </listitem>
            <listitem>
              <para><code>openFrame()</code> - загрузить фрейм по идентификатору, зарегистрированному в <filename>
                  <link linkend="screens.xml">screens.xml</link>
                </filename>, и, если в метод передан компонент-контейнер, отобразить его внутри контейнера. Возвращается контроллер фрейма. Например:<programlisting language="java">@Inject
private BoxLayout container;

@Override
public void init(Map&lt;String, Object&gt; params) {
    SomeFrame frame = openFrame(container, &quot;someFrame&quot;);
    frame.setHeight(&quot;100%&quot;);
    frame.someInitMethod();
}</programlisting></para>
              <para>Контейнер не обязательно сразу передавать в метод <code>openFrame()</code>, вместо этого можно загрузить фрейм, а затем добавить его  в нужный контейнер:<programlisting language="java">@Inject
private BoxLayout container;

@Override
public void init(Map&lt;String, Object&gt; params) {
    SomeFrame frame = openFrame(null, &quot;someFrame&quot;);
    frame.setHeight(&quot;100%&quot;);
    frame.someInitMethod();
    container.add(frame);
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>openWindow()</code>, <code>openLookup()</code>, <code>openEditor()</code> - открыть соответственно простой экран, экран выбора или редактирования. Методы возвращают контроллер созданного экрана.</para>
              <para>Для выполнения действий после закрытия вызываемого экрана необходимо добавить слушатель типа <code>CloseListener</code>, например:<programlisting language="java">CustomerEdit editor = openEditor(&quot;sales$Customer.edit&quot;, customer, WindowManager.OpenType.THIS_TAB);
editor.addListener(new CloseListener() {
    @Override
    public void windowClosed(String actionId) {
        // do something
    }
});</programlisting></para>
            </listitem>
            <listitem>
              <para><code>showMessageDialog()</code> - отобразить диалоговое окно с сообщением.</para>
            </listitem>
            <listitem>
              <para><code>showOptionDialog()</code> - отобразить диалоговое окно с сообщением и возможностью выбора пользователем некоторых действий. Действия задаются массивом объектов типа <code>
                  <link linkend="gui_Action">Action</link>
                </code>, которые в диалоге отображаются посредством соответствующих кнопок.</para>
              <para>Для отображения стандартных кнопок типа <guibutton>OK</guibutton>, <guibutton>Cancel</guibutton> и других рекомендуется использовать объекты типа <code>DialogAction</code>, например:<programlisting language="java">showOptionDialog(&quot;PLease confirm&quot;, &quot;Are you sure?&quot;,
        MessageType.CONFIRMATION,
        new Action[] {
                new DialogAction(DialogAction.Type.YES) {
                    @Override
                    public void actionPerform(Component component) {
                        // do something
                    }
                },
                new DialogAction(DialogAction.Type.NO);
        });</programlisting></para>
            </listitem>
            <listitem>
              <para><code>showNotification()</code> - отобразить всплывающее окно с сообщением.</para>
            </listitem>
            <listitem>
              <para><code>showWebPage()</code> - открыть указанную веб-страницу в браузере.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="abstractWindow">
          <title>AbstractWindow</title>
          <para><code>AbstractWindow</code> является наследником <code>
              <link linkend="abstractFrame">AbstractFrame</link>
            </code>, и определяет следующие собственные методы:</para>
          <itemizedlist>
            <listitem id="abstractWindow.ready">
              <para><code>ready()</code> - шаблонный метод, который можно имплементировать в контроллере для перехвата момента открытия экрана. Метод <code>ready()</code> вызывается фреймворком после метода <link linkend="abstractFrame.init">init()</link> непосредственно перед показом экрана в главном окне приложения.</para>
            </listitem>
            <listitem>
              <para><code>validateAll()</code> - валидация экрана. Реализация по умолчанию вызывает метод <code>validate()</code> у всех компонентов экрана, реализующих интерфейс <code>Component.Validatable</code>, накапливает информацию об исключениях, и если таковые имеются, выводит соответствующее сообщение и возвращает <code>false</code>, иначе возвращает <code>true</code>.</para>
              <para>Данный метод следует переопределять только в том случае, если необходимо полностью заменить стандартную процедуру валидации экрана. Если же нужно только дополнить ее, достаточно определить специальный шаблонный метод <code>postValidate()</code>.</para>
            </listitem>
            <listitem>
              <para><code>postValidate()</code> - шаблонный метод, который можно имплементировать в контроллере для дополнительной валидации экрана. Получаемый методом объект <code>ValidationErrors</code> используется для добавления информации об ошибках валидации, которая будет отображена совместно с ошибками стандартной валидации. Например:<programlisting language="java">private Pattern pattern = Pattern.compile(&quot;\\d&quot;);

@Override
protected void postValidate(ValidationErrors errors) {
    if (getItem().getAddress().getCity() != null) {
        if (pattern.matcher(getItem().getAddress().getCity()).find()) {
            errors.add(&quot;City name can&apos;t contain digits&quot;);
        }
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>close()</code> - закрыть данный экран. </para>
              <para>Метод принимает строковое значение, передаваемое далее  в шаблонный метод <code>preClose()</code> и слушателям <code>CloseListener</code>. Таким образом, заинтересованный код может получить информацию о причине закрытия экрана от кода, инициирующего закрытие. В частности, в экранах редактирования сущностей при закрытии экрана после коммита изменений рекомендуется использовать константу <code>Window.COMMIT_ACTION_ID</code>, без коммита изменений - константу <code>Window.CLOSE_ACTION_ID</code>.</para>
              <para>Если какой-либо из источников данных содержит несохраненные изменения, перед закрытием экрана будет выдано диалоговое окно с соответствующим предупреждением. Тип предупреждения можно выбрать с помощью свойства приложения <property>
                  <link linkend="cuba.gui.useSaveConfirmation">cuba.gui.useSaveConfirmation</link>
                </property>.</para>
              <para>Вариант  метода <code>close()</code> с параметром <code>force = false</code> закрывает экран без вызова <code>preClose()</code> и без предупреждения, независимо от наличия несохраненных изменений.</para>
              <para>Метод <code>close()</code> возвращает <code>true</code>, если экран был успешно закрыт, и <code>false</code> - если закрытие было прервано.</para>
            </listitem>
            <listitem>
              <para><code>preClose()</code> - шаблонный метод, который можно имплементировать в контроллере для перехвата момента закрытия экрана. Метод получает строковое значение, указанное инициатором закрытия при вызове метода <code>close()</code>.</para>
              <para>Если метод <code>preClose()</code> возвращает <code>false</code>, то процесс закрытия экрана прерывается.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="abstractLookup">
          <title>AbstractLookup</title>
          <para><code>AbstractLookup</code> базовый класс контроллеров <link linkend="screen_lookup">экранов выбора</link>, является наследником <code>
              <link linkend="abstractWindow">AbstractWindow</link>
            </code>, и определяет следующие собственные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>setLookupComponent()</code> - установить компонент, из которого будет производиться выбор экземпляров сущности. </para>
              <para>Как правило,  компонент выбора устанавливается в XML-дескрипторе экрана, и вызывать данный метод в прикладном коде нет необходимости.</para>
            </listitem>
            <listitem>
              <para><code>setLookupValidator()</code> - установить для экрана объект типа <code>Window.Lookup.Validator</code>, метод <code>validate()</code> которого вызывается фреймворком перед тем как вернуть выбранные экземпляры сущностей. Если <code>validate()</code> возвращает <code>false</code>, процесс выбора и закрытия экрана прерывается.</para>
              <para>По умолчанию валидатор не установлен.</para>
            </listitem>
          </itemizedlist>
        </section>
        <section id="abstractEditor">
          <title>AbstractEditor</title>
          <para><code>AbstractEditor</code> − базовый класс контроллеров <link linkend="screen_edit">экранов редактирования</link>, является наследником <code>
              <link linkend="abstractWindow">AbstractWindow</link>
            </code>.</para>
          <para>При создании конкретного класса контроллера рекомендуется параметризовать <code>AbstractEditor</code> типом редактируемой сущности. При этом методы <code>getItem()</code> и <code>initItem()</code> будут работать с конкретным типом сущности и прикладному коду не потребуется дополнительных приведений типов. Например:</para>
          <programlisting language="java">public class CustomerEdit extends AbstractEditor&lt;Customer&gt; {

    @Override
    protected void initItem(Customer item) {
    ...</programlisting>
          <para><code>AbstractEditor</code> определяет следующие собственные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>getItem()</code> - возвращает экземпляр редактируемой сущности, установленный в главном источнике данных экрана (т.е. указанном в атрибуте <sgmltag>datasource</sgmltag> корневого элемента XML-дескриптора).</para>
              <para>Если редактируется не новый экземпляр, то в момент открытия экрана он перезагружается из базы данных с необходимым <link linkend="views">представлением</link>, указанным для главного источника данных. </para>
              <para>Изменения, вносимые в экземпляр, возвращаемый <code>getItem()</code>,  отражаются на состоянии источника данных, и будут отправлены на <structname>Middleware</structname> при коммите экрана.</para>
              <warning>
                <para>Следует иметь в виду, что <code>getItem()</code> возвращает значение только после инициализации экрана методом <code>setItem()</code>. До этого момента, например, в методах <code>init()</code> и <code>initItem()</code>, данный метод возвращает <code>null</code>.</para>
                <para>Однако в методе <code>init()</code> экземпляр сущности, переданный в <code>openEditor()</code>, можно получить из  параметров следующим образом:<programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
    Customer item = WindowParams.ITEM.getEntity(params);
    // do something
}</programlisting></para>
                <para>В метод <code>initItem()</code> экземпляр передается явно и нужного типа.</para>
                <para>В обоих случаях полученный экземпляр сущности, если он не новый, будет впоследствии перезагружен, и вносить в него изменения или сохранять в поле для последующего использования не имеет смысла.</para>
              </warning>
            </listitem>
            <listitem>
              <para><code>setItem()</code> - вызывается фреймворком при открытии экрана методом <code>openEditor()</code> для установки редактируемого экземпляра сущности в главном источнике данных. В момент вызова   созданы все компоненты и источники данных экрана, и отработал метод <code>init()</code> контроллера.</para>
              <para>Для инициализации экрана редактирования вместо переопределения <code> setItem()</code> рекомендуется имплементировать специальные шаблонные методы <code>initItem()</code> и <code>postInit()</code>.</para>
            </listitem>
            <listitem id="initNewItem">
              <para><code>initNewItem()</code> - шаблонный метод, вызываемый фреймворком перед установкой редактируемого экземпляра сущности в главном источнике данных.</para>
              <tip>
                <para>Метод <code>initNewItem()</code> вызывается только для нового, только что созданного экземпляра сущности. Если редактируется <link linkend="entity_states">detached</link> экземпляр, метод не вызывается.</para>
              </tip>
              <para>Данный метод можно имплементировать в контроллере при необходимости инициализации нового экземпляра сущности перед его установкой в источник данных, например:<programlisting language="java">@Inject
private UserSession userSession;

@Override
protected void initNewItem(Complaint item) {
    item.setOpenedBy(userSession.getUser());
    item.setStatus(ComplaintStatus.OPENED);
}</programlisting></para>
              <para>Более сложный пример использования <code>initNewItem()</code> приведен в разделе <link linkend="init_values_in_initNewItem">рецептов разработки</link>.</para>
            </listitem>
            <listitem>
              <para><code>postInit()</code> - шаблонный метод, вызываемый фреймворком сразу после  установки редактируемого экземпляра сущности в главном источнике данных. Во время выполнения данного метода можно вызывать <code>getItem()</code>, который будет возвращать новый или перезагруженный при инициализации экрана  экземпляр сущности.</para>
              <para>Данный метод можно имплементировать в контроллере для окончательной инициализации экрана, например:<programlisting language="java">@Inject
protected EntityDiffViewer diffFrame;

@Override
protected void postInit() {
    if (!PersistenceHelper.isNew(getItem())) {
        diffFrame.loadVersions(getItem());
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>commit()</code> - валидировать экран и отправить изменения через <code>
                  <link linkend="dataSupplier">DataSupplier</link>
                </code> на <structname>Middleware</structname>.</para>
              <para>Если используется вариант метода с параметром <code>validate = false</code>, то валидация перед коммитом не производится.</para>
              <para>Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code>.</para>
            </listitem>
            <listitem>
              <para><code>commitAndClose()</code> - валидировать экран, отправить изменения  на <structname>Middleware</structname> и закрыть экран. В метод <code>preClose()</code> и зарегистрированным слушателям <code>CloseListener</code> будет передано значение константы <code>Window.COMMIT_ACTION_ID</code>.</para>
              <para>Данный метод не рекомендуется переопределять, лучше использовать специальные шаблонные методы <code>postValidate()</code>, <code>preCommit()</code> и <code>postCommit()</code>.</para>
            </listitem>
            <listitem>
              <para><code>preCommit()</code> - шаблонный метод, вызываемый фреймворком в процессе коммита изменений, после того как валидация завершена успешно и перед отправкой данных на <structname>Middleware</structname>.</para>
              <para>Данный метод можно имплементировать в контроллере. Если метод возвращает <code>false</code>, процесс коммита (и закрытия экрана, если был вызван <code>commitAndClose()</code>), прерывается. Например:<programlisting language="java">@Override
protected boolean preCommit() {
    if (somethingWentWrong) {
        showNotification(&quot;Something went wrong&quot;, NotificationType.WARNING);
        return false;
    }
    return true;
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>postCommit()</code> - шаблонный метод, вызываемый фреймворком на финальной стадии коммита изменений. Параметры метода:<itemizedlist>
                  <listitem>
                    <para><code>committed</code> - установлен в <code>true</code>, если в экране действительно были изменения, и они отправлены на <structname>Middleware</structname>;</para>
                  </listitem>
                  <listitem>
                    <para><code>close</code> - установлен в <code>true</code>, если экран после коммита будет закрыт.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Реализация метода по умолчанию, если экран не закрывается, отображает сообщение об успешном коммите изменений и вызывает метод <code>postInit()</code>.</para>
              <para>Данный метод можно переопределить в контроллере для выполнения некоторых действий после успешного коммита, например:<programlisting language="java">@Inject
private Datasource&lt;Driver&gt; driverDs;
@Inject
private EntitySnapshotService entitySnapshotService;

@Override
protected boolean postCommit(boolean committed, boolean close) {
    if (committed) {
        entitySnapshotService.createSnapshot(driverDs.getItem(), driverDs.getView());
    }
    return super.postCommit(committed, close);
}</programlisting></para>
            </listitem>
          </itemizedlist>
          <para>Далее приведены диаграммы последовательностей инициализации и различных вариантов коммита экрана редактирования.</para>
          <figure>
            <title>Инициализация экрана редактирования</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/EditorInit.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Коммит и закрытие экрана с фреймом editWindowActions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/EditorCommit.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Коммит экрана с фреймом extendedEditWindowActions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/ExtendedEditorCommit.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Коммит и закрытие экрана с фреймом extendedEditWindowActions</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/ExtendedEditorCommitAndClose.png"/>
              </imageobject>
            </mediaobject>
          </figure>
        </section>
        <section id="screen_controller_injection">
          <title>Инжекция зависимостей контроллеров</title>
          <para>В контроллерах можно использовать Dependency Injection для получения ссылок на используемые объекты. Для этого нужно объявить либо поле соответствующего типа, либо метод доступа на запись (setter) с соответствующим типом результата, и добавить ему одну из следующих аннотаций:<itemizedlist>
              <listitem>
                <para><code>@Inject</code> - простейший вариант, поиск объекта для инжекции будет произведен по типу поля/метода и по имени, эквивалентному имени поля либо имени атрибута (по правилам JavaBeans) для метода</para>
              </listitem>
              <listitem>
                <para><code>@Named(&quot;someName&quot;)</code> - вариант с явным указанием имени искомого объекта</para>
              </listitem>
            </itemizedlist></para>
          <para>Инжектировать в контроллеры можно следующие объекты: <itemizedlist>
              <listitem>
                <para>Визуальные компоненты данного экрана, определенные в XML-дескрипторе. Если тип атрибута унаследован от <code>Component</code>, в текущем экране будет произведен поиск компонента с соответствующим именем. </para>
              </listitem>
              <listitem>
                <para>Действия, определенные в XML-дескрипторе - см. <xref linkend="gui_Action"/></para>
              </listitem>
              <listitem>
                <para><link linkend="datasources">Источники данных</link>, определенные в XML-дескрипторе. Если тип атрибута унаследован от <code>Datasource</code>, в текущем экране будет произведен поиск источника данных с соответствующим именем. </para>
              </listitem>
              <listitem>
                <para><code>UserSession</code>. Если тип атрибута - <code>
                    <link linkend="userSession">UserSession</link>
                  </code>, будет инжектирован объект текущей пользовательской сессии. </para>
              </listitem>
              <listitem>
                <para><code>DsContext</code>. Если тип атрибута - <code>DsContext</code>, будет инжектирован <code>DsContext</code> текущего экрана. </para>
              </listitem>
              <listitem>
                <para><code>WindowContext</code>. Если тип атрибута - <code>WindowContext</code>, будет инжектирован <code>WindowContext</code> текущего экрана. </para>
              </listitem>
              <listitem>
                <para><code>DataSupplier</code>. Если тип атрибута - <code>
                    <link linkend="dataSupplier">DataSupplier</link>
                  </code>, будет инжектирован соответствующий экземпляр. </para>
              </listitem>
              <listitem>
                <para>Любой бин, определенный в контексте данного клиентского блока приложения, в том числе:<itemizedlist>
                    <listitem>
                      <para>импортируемые клиентом <link linkend="services">сервисы</link> <structname>Middleware</structname></para>
                    </listitem>
                    <listitem>
                      <para><link linkend="config_interfaces">конфигурационные интерфейсы</link></para>
                    </listitem>
                    <listitem>
                      <para><code>ComponentsFactory</code></para>
                    </listitem>
                    <listitem>
                      <para><code>WindowConfig</code></para>
                    </listitem>
                    <listitem>
                      <para><code>ExportDisplay</code></para>
                    </listitem>
                    <listitem>
                      <para><code>
                          <link linkend="background_tasks">BackgroundWorker</link>
                        </code></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para>Если ничего из вышеперечисленного не подошло и контроллер имеет <link linkend="companions">компаньонов</link>, в случае совпадения типов будет инжектирован компаньон для текущего типа клиента.</para>
              </listitem>
            </itemizedlist></para>
          <para>С помощью специальной аннотации <code>@WindowParam</code> можно инжектировать в контроллер параметры, передаваемые в мэп  метода <code>init()</code>. Аннотация имеет атрибут <code>name</code>, в котором указывается имя параметра (ключ в мэп), и опциональный атрибут <code>required</code>. Если <code>required = true</code>, то при отсутствии в мэп соответствующего параметра в лог выводится сообщение с уровнем <code>WARNING</code>. </para>
          <para>Пример инжекции объекта типа <code>Job</code>, передаваемого в метод <code>init()</code> контроллера:<programlisting language="java">@WindowParam(name = &quot;job&quot;, required = true)
protected Job job;</programlisting></para>
        </section>
        <section id="companions">
          <title>Компаньоны контроллеров</title>
          <para>Базовые классы контроллеров расположены в <link linkend="app_modules">модуле</link> <structname>gui</structname> <link linkend="base_projects">базового проекта</link> <structname>cuba</structname> и не содержат ссылок на классы реализации визуальных компонентов (<application>Swing</application> или <application>Vaadin</application>), что дает возможность использовать их в клиентах обоих типов. Вместо этого базовые классы контроллеров реализуют дополнительный интерфейс <code>Window.Wrapper</code> и делегируют выполнение &quot;обернутому&quot; окну. </para>
          <para>В то же время конкретные классы контроллеров могут быть расположены как в модуле <structname>gui</structname>, так и в <structname>web</structname> или <structname>desktop</structname>, в зависимости от применяемых в проекте клиентских <link linkend="app_tiers">блоков</link> и специфики экрана. Если контроллер является универсальным, но для разных типов клиента требуется дополнительная функциональность, ее можно определить в так называемых <firstterm>классах-компаньонах</firstterm>. </para>
          <para>Класс-компаньон располагается в модуле клиента соответствующего типа (<structname>web</structname> или <structname>desktop</structname>) и реализует интерфейс, задаваемый в использующем его контроллере. Класс компаньона задается в элементе <sgmltag>companions</sgmltag> XML-дескриптора экрана. Контроллер может получить ссылку на экземпляр компаньона с помощью инжекции или вызовом <code>getCompanion()</code>, и в нужный момент передать ему управление, например, для дополнительной инициализации визуальных компонентов специфичным для данного типа клиента способом. </para>
          <para>Например, необходимо раздельно для веб и десктоп клиентов проинициализировать таблицу некоторого экрана. Тогда в контроллере экрана, расположенном в модуле <structname>gui</structname>,  определяем интерфейс компаньона и делегируем ему инициализацию таблицы:<programlisting language="java">public class CustomerBrowse extends AbstractLookup {

    public interface Companion {
        void initTable(Table table);
    }

    @Inject
    protected Table table;

    @Inject
    protected Companion companion;

    @Override
    public void init(Map&lt;String, Object&gt; params) {
        if (companion != null) {
            companion.initTable(table);
        }
    }
}</programlisting></para>
          <para>В модулях <structname>web</structname> и <structname>desktop</structname> создаем соответствующие классы реализации компаньона:<programlisting language="java">public class WebCustomerBrowseCompanion implements CustomerBrowse.Companion {
    @Override
    public void initTable(Table table) {
        com.vaadin.ui.Table webTable = (com.vaadin.ui.Table) WebComponentsHelper.unwrap(table);
        // do something specific to Vaadin table
    }
}</programlisting><programlisting language="java">public class DesktopCustomerBrowseCompanion implements CustomerBrowse.Companion {
    @Override
    public void initTable(Table table) {
        javax.swing.JTable desktopTable = (javax.swing.JTable) DesktopComponentsHelper.unwrap(table);
        // do something specific to Swing table
    }
}</programlisting></para>
          <para>И регистрируем классы реализации компаньона в XML-дескрипторе экрана:<programlisting language="xml">&lt;window ...
        class=&quot;com.company.sample.gui.customers.CustomerBrowse&quot;&gt;
    &lt;companions&gt;
        &lt;web class=&quot;com.company.sample.web.customers.WebCustomerBrowseCompanion&quot;/&gt;
        &lt;desktop class=&quot;com.company.sample.desktop.customers.DesktopCustomerBrowseCompanion&quot;/&gt;
    &lt;/companions&gt;
    &lt;dsContext&gt;...&lt;/dsContext&gt;
    &lt;layout&gt;...&lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
          <para>Так как классы-компаньоны расположены в <structname>web</structname> и <structname>desktop</structname> модулях, в них можно использовать метод <code>unwrap()</code> классов <link linkend="webComponentsHelper">WebComponentsHelper</link> и <link linkend="desktopComponentsHelper">DesktopComponentsHelper</link> для извлечения из интерфейса <link linkend="gui_Table">Table</link> ссылок на реализующие таблицу Vaadin и Swing компоненты, и работать  с ними непосредственно.</para>
        </section>
      </section>
    </section>
    <section id="gui_vcl">
      <title>Библиотека визуальных компонентов</title>
      <para><link linkend="gui_components">Компоненты</link></para>
      <para><link linkend="gui_layouts">Контейнеры</link></para>
      <para><link linkend="gui_misc">Разное</link></para>
      <section id="gui_components">
        <title>Компоненты</title>
        <figure>
          <title>Диаграмма компонентов</title>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="1000" align="center" fileref="img/Components_supplemented.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para><code>Component</code> − предок всех визуальных компонентов. Он содержит базовые атрибуты, позволяющие идентифицировать компонент и располагать его на экране.</para>
        <informaltable frame="none" pgwide="0">
          <tgroup cols="2" colsep="1">
            <colspec colnum="1" colname="c0" colwidth="1*"/>
            <colspec colnum="2" colname="c1" colwidth="4*"/>
            <tbody valign="middle">
              <row>
                <entry align="left">
                  <emphasis role="bold">Buttons</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Button">Button</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/Button.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row valign="middle">
                <entry align="left">
                  <link linkend="gui_PopupButton">PopupButton</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/PopupButton.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_LinkButton">LinkButton</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/LinkButton.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_BulkEditor">BulkEditor</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_bulkEdit.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_RelatedEntities">RelatedEntities</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_relatedEntities.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Text</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Label">Label</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_label.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Text inputs</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TextField">TextField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_textField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>P<entry align="left">
                  <link linkend="gui_PasswordField">PasswordField</link>
                </entry><entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_PasswordField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry></row>
              <row>M<entry align="left">
                  <link linkend="gui_MaskedField">MaskedField</link>
                </entry><entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_MaskedField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry></row>
              <row>
                <entry align="left">
                  <link linkend="gui_TextArea">TextArea</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_TextArea.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_RichTextArea">RichTextArea</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_RichTextArea.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Date inputs</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_DateField">DateField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_dateField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TimeField">TimeField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_timeField1.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Selects</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_CheckBox">CheckBox</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/CheckBox.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_OptionsGroup">OptionsGroup</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_optionsGroup.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_PickerField">PickerField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/PickerField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_LookupField">LookupField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/LookupField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_LookupPickerField">LookupPickerField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/LookupPickerField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_SearchPickerField">SearchPickerField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_searchPickerField.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TwinColumn">TwinColumn</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/TwinColumn.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Uploads</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_FileUploadField">FileUploadField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/Upload.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_FileMultiUploadField">FileMultiUploadField</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/MultiUpload.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Tables and trees</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Table">Table</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_table.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_GroupTable">GroupTable</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_groupTable.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TreeTable">TreeTable</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_treeTable.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Tree">Tree</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_Tree.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <emphasis role="bold">Others</emphasis>
                </entry>
                <entry/>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_FieldGroup">FieldGroup</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_fieldGroup.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_TokenList">TokenList</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_tokenList.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_ProgressBar">ProgressBar</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_progressBar.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Filter">Filter</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_filter_mini.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
              <row>
                <entry align="left">
                  <link linkend="gui_Embedded">Embedded</link>
                </entry>
                <entry align="left">
                  <mediaobject>
                    <imageobject>
                      <imagedata fileref="img/cuba-64-01.png"/>
                    </imageobject>
                  </mediaobject>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </informaltable>
        <section id="gui_Button">
          <title>Button</title>
          <para>Кнопка (<code>Button</code>) −  компонент,  обеспечивающий  выполнение действия при нажатии.</para>
          <para>XML-имя компонента: <sgmltag>button</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_Button_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент кнопки реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Кнопка может содержать  текст или пиктограмму (или и то и другое). На рисунке ниже отображены разные виды кнопок.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="233" contentdepth="128" align="center" fileref="img/gui_buttonTypes.png"/>
            </imageobject>
          </mediaobject>
          <para>Пример кнопки с названием, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>, и с всплывающей подсказкой:<programlisting language="xml">&lt;button id=&quot;textButton&quot; caption=&quot;msg://someAction&quot; description=&quot;Press me&quot;/&gt;</programlisting></para>
          <para>Название кнопки задается с помощью атрибута <link linkend="gui_attr_basic_caption">caption</link>, всплывающая подсказка − с помощью атрибута <link linkend="gui_attr_basic_description">description</link>.</para>
          <para>Атрибут <link linkend="gui_attr_basic_icon">icon</link> указывает на местоположение пиктограммы. Подробную информацию о том, где следует располагать файлы пиктограмм, можно прочитать в  <xref linkend="gui_themes"/></para>
          <para>Пример создания кнопки с пиктограммой:<programlisting language="xml">&lt;button id=&quot;iconButton&quot; caption=&quot;&quot; icon=&quot;icons/save.png&quot;/&gt;</programlisting></para>
          <para id="gui_attr_button_invoke">Основная функция кнопки −  выполнить некоторое действие при нажатии на нее. Определить метод контроллера, который будет вызываться при нажатии на кнопку, можно с помощью атрибута <sgmltag>invoke</sgmltag>. Значением атрибута должно быть    имя  метода контроллера, удовлетворяющего следующим условиям:</para>
          <itemizedlist>
            <listitem>
              <para>Метод должен быть  <code>public</code>.</para>
            </listitem>
            <listitem>
              <para>Метод должен возвращать  <code>void</code>.</para>
            </listitem>
            <listitem>
              <para>Метод должен либо не иметь аргументов, либо иметь один аргумент типа <code>Component</code>. Если метод имеет аргумент <code>Component</code>, то при вызове в него будет передан экземпляр вызвавшей кнопки.</para>
            </listitem>
          </itemizedlist>
          <para>В качестве примера показано описание кнопки, вызывающей метод <code>someMethod:</code><programlisting language="xml">&lt;button invoke=&quot;someMethod&quot; caption=&quot;msg://someButton&quot;/&gt;</programlisting></para>
          <para>В контроллере экрана необходимо определить метод <code>someMethod</code>:<programlisting language="java">public void someMethod() {
   //some actions
}</programlisting></para>
          <para id="gui_attr_button_action">Атрибут <sgmltag>invoke</sgmltag> игнорируется, если для кнопки задан атрибут <sgmltag>action</sgmltag>. Атрибут <sgmltag>action</sgmltag> содержит имя <link linkend="gui_Action">действия</link>, соответствующего данной кнопке.</para>
          <para>Пример кнопки с атрибутом <sgmltag>action</sgmltag>:<programlisting language="xml">&lt;actions&gt;
   &lt;action id=&quot;someAction&quot; caption=&quot;msg://someAction&quot;/&gt;
&lt;/actions&gt;
&lt;layout&gt;
    &lt;button action=&quot;someAction&quot;/&gt;</programlisting></para>
          <para>Кнопке можно назначить любое действие, имеющееся в каком-либо компоненте, реализующем интерфейс <code>Component.ActionsHolder</code> (это актуально для  <link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link>, <link linkend="gui_Tree">Tree</link>). Причем неважно, каким образом эти действия добавлены - декларативно в XML-дескрипторе или программно в контроллере. В любом случае для использования такого действия достаточно в атрибуте <code>action</code> указать через точку имя компонента и идентификатор нужного действия. Например, в следующем примере кнопке назначается действие <code>create</code> таблицы <code>coloursTable</code>:<programlisting language="xml">&lt;button action=&quot;coloursTable.create&quot;/&gt;</programlisting></para>
          <para>Действие для кнопки можно также создавать программно, в контроллере экрана, используя наследование от класса <link linkend="abstractAction">AbstractAction</link>.</para>
          <para>Если для <code>Button</code> установлен экземпляр <code>Action</code>, то кнопка возьмет из него следующие свои свойства: <link linkend="gui_attr_basic_caption">caption</link>, <link linkend="gui_attr_basic_description">description</link>, <link linkend="gui_attr_basic_icon">icon</link>, <link linkend="gui_attr_basic_enable">enable</link>, <link linkend="gui_attr_basic_visible">visible</link>. Свойства <code>caption</code> и <code>description</code> будут проставлены из действия только в том случае, если они не установлены в самом <code>Button</code>. Остальные перечисленные свойства действия имеют безусловный приоритет над свойствами кнопки. Если свойства действия меняются уже после установки этого <code>Action</code> для <code>Button</code>, то соответственно меняться будут и свойства <code>Button</code>, то есть кнопка слушает изменение свойств действия. В этом случае меняется и свойства <code>caption</code> и <code>description</code>, причем даже если они изначально были назначены на саму кнопку.</para>
          <para>Атрибуты <sgmltag>button</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row>
                  <entry align="left">action</entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">invoke</entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_BulkEditor">
          <title>Bulk Editor</title>
          <para><code>Bulk Editor</code> - компонент, позволяющий менять значения атрибутов сразу нескольких выбранных экземпляров сущностей. Компонент представляет собой кнопку, добавляющуюся к <link linkend="gui_Table">таблице</link> или <link linkend="gui_Tree">дереву</link> и при нажатии открывающую редактор сущностей. </para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_bulkEdit.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <code>bulkEditor</code></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_BulkEditor_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Для использования Bulk Editor у таблицы или дерева должен быть задан атрибут <code>multiselect=&quot;true&quot;</code>.</para>
          <para>Экран редактирования сущностей генерируется автоматически на основе заданного представления (содержащего только поля данной сущности, в том числе ссылки) и разрешений пользователя. Системные атрибуты в редакторе также не отображаются. </para>
          <para>Атрибуты сущности в редакторе сортируются по алфавиту. По умолчанию они пусты. При коммите экрана заданные на экране непустые значения атрибутов проставляются всем выбранным экземплярам сущности. </para>
          <para>Редактор позволяет удалить значение определенного поля в БД у всех выбранных сущностей, установив его в <code>null</code>. Для этого необходимо нажать на кнопку <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_bulkEditorSetNullButton.png"/>
              </imageobject>
            </inlinemediaobject>  рядом с соответствующим полем. После этого поле становится нередактируемым. Разблокировать поле можно, нажав на кнопку <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_bulkEditorUnlockButton.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_invoiceBulkEdit.png"/>
            </imageobject>
          </mediaobject>
          <para>Пример описания компонента <code>bulkEditor</code> для таблицы:</para>
          <programlisting language="xml" xml:lang="">&lt;table id=&quot;invoiceTable&quot;
       multiselect=&quot;true&quot;
       width=&quot;100%&quot;&gt;
            &lt;actions&gt;
                &lt;action id=&quot;create&quot;/&gt;
                &lt;action id=&quot;edit&quot;/&gt;
                &lt;action id=&quot;remove&quot;/&gt;
            &lt;/actions&gt;
            &lt;buttonsPanel id=&quot;buttonsPanel&quot;&gt;
                &lt;button id=&quot;createBtn&quot;
                        action=&quot;invoiceTable.create&quot;/&gt;
                &lt;button id=&quot;editBtn&quot;
                        action=&quot;invoiceTable.edit&quot;/&gt;
                &lt;button id=&quot;removeBtn&quot;
                        action=&quot;invoiceTable.remove&quot;/&gt;
                &lt;bulkEditor for=&quot;invoiceTable&quot;
                            exclude=&quot;customer&quot;/&gt;
            &lt;/buttonsPanel&gt;
</programlisting>
          <para id="gui_attr_bulkedit_for">Атрибут <code>for</code> является обязательным. В нем указывается идентификатор таблицы или дерева, в данном случае - <code>invoiceTable</code>.</para>
          <para id="gui_attr_bulkedit_exclude">Атрибут <code>exclude</code> позволяет явно исключить определенные поля из списка редактируемых. Имена атрибутов сущности указываются через запятую. </para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_TableBulkEdit.png"/>
            </imageobject>
          </mediaobject>
          <para>Атрибуты <code>BulkEditor</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_bulkedit_exclude">exclude</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_openType">openType</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_bulkedit_for">for</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_CheckBox">
          <title>CheckBox</title>
          <para>Флажок (<code>CheckBox</code>) − компонент, имеющий два состояния: выбран, не выбран.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/CheckBox.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>checkBox</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_checkBox_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>CheckBox</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Пример флажка с надписью, взятой из <link linkend="message_packs">пакета локализованных сообщений</link>:</para>
          <programlisting language="xml">&lt;checkBox id=&quot;accessField&quot; caption=&quot;msg://accessFieldCaption&quot;/&gt;</programlisting>
          <para>Сброс или установка флажка изменяет его значение: <code>Boolean.TRUE</code> или <code>Boolean.FALSE</code>. Значение может быть получено с помощью метода  <code>getValue()</code> и установлено с помощью метода <code>setValue()</code>. Если в <code>setValue()</code> передать <code>null</code>, то устанавливается значение <code>Boolean.FALSE</code> и флажок снимается.</para>
          <para>Изменение значения флажка, так же как и любого другого компонента, реализующего интерфейс <code>Field</code>, можно отслеживать с помощью слушателя <code>ValueListener</code>. Например:<programlisting language="java">@Inject
private CheckBox accessField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    accessField.addListener(new ValueListener&lt;Object&gt;() {
        @Override
        public void valueChanged(Object source, String property, Object prevValue, Object value) {
            if (Boolean.TRUE.equals(value)) {
                showNotification(&quot;set&quot;, NotificationType.HUMANIZED);
            } else {
                showNotification(&quot;not set&quot;, NotificationType.HUMANIZED);
            }
        }
    });
}</programlisting></para>
          <para>Для создания флажка, связанного с данными, необходимо использовать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>.<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;customerDs&quot; class=&quot;com.sample.sales.entity.Customer&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;checkBox datasource=&quot;customerDs&quot; property=&quot;active&quot;/&gt;</programlisting></para>
          <para>Как видно из примера, в экране описывается <link linkend="datasources">источник данных</link> <code>customerDs</code> для некоторой сущности Покупатель (<code>Customer</code>), имеющей атрибут <code>active</code>. В компоненте <code>checkBox</code> в атрибуте <code>datasource</code> указывается ссылка на источник данных, а в атрибуте <code>property</code> − название атрибута сущности, значение которого должно быть отображено флажком. Атрибут должен быть типа <code>Boolean</code>. Значением атрибута может быть <code>null</code>, при этом флажок снимается.</para>
          <para>Атрибуты <sgmltag>checkBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_DateField">
          <title>DateField</title>
          <para>Поле для отображения и ввода даты и времени. Представляет собой поле  даты, внутри которого имеется кнопка с выпадающим календарем, а правее находится поле для ввода времени.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_dateFieldSimple.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>dateField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_dateField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>DateField</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.<itemizedlist>
              <listitem>
                <para>Для создания  поля даты, связанного с данными, необходимо использовать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>:</para>
                <programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;orderDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot;/&gt;</programlisting>
                <para>Как видно из примера, в экране описывается источник данных <literal>orderDs</literal> для некоторой сущности Заказ (<code>Order</code>), имеющей атрибут <code>date</code>. В компоненте ввода даты   в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название атрибута сущности, значение которого должно быть отображено в  поле.</para>
              </listitem>
              <listitem>
                <para>Если поле связано с атрибутом сущности, то оно автоматически принимает соответствующий вид:<itemizedlist>
                    <listitem>
                      <para>Если атрибут типа <code>java.sql.Date</code> или указана аннотация <code>@Temporal(TemporalType.DATE)</code>, то поле времени не отображается. Формат даты определяется <link linkend="datatype">типом данных</link> <code>date</code> и задается в <link linkend="main_message_pack">главном пакете локализованных сообщений</link> в ключе <code>dateFormat</code>.</para>
                    </listitem>
                    <listitem>
                      <para>В противном случае отображается также поле времени с часами и минутами. Формат времени определяется <link linkend="datatype">типом данных</link> <code>time</code> и задается в <link linkend="main_message_pack">главном пакете локализованных сообщений</link> в ключе <code>timeFormat</code>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para id="gui_attr_dateField_dateFormat">Изменить формат представления даты и времени можно с помощью атрибута  <sgmltag>dateFormat</sgmltag>. Значением атрибута может быть либо сама строка формата, либо ключ в пакете сообщений (если значение начинается с <code>msg://</code>).</para>
                <para>Формат задается по правилам класса <code>SimpleDateFormat</code> (<ulink url="http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html">http://docs.oracle.com/javase/7/docs/api/java/text/SimpleDateFormat.html</ulink>). Если в формате отсутствуют символы <code>H</code> или <code>h</code>, то поле времени не выводится.</para>
                <programlisting language="xml">&lt;dateField dateFormat=&quot;MM/yy&quot; caption=&quot;msg://monthOnlyDateField&quot;/&gt;</programlisting>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_dateField_format.png"/>
                  </imageobject>
                </mediaobject>
              </listitem>
              <listitem>
                <para id="gui_attr_dateField_resolution">Точность представления даты и времени можно определить с помощью  атрибута <sgmltag>resolution</sgmltag>.  Значение атрибута должно соответствовать перечислению <code>DateField.Resolution</code> − <literal>SEC</literal>, <literal>MIN</literal>, <literal>HOUR</literal>, <literal>DAY</literal>, <literal>MONTH</literal>, <literal>YEAR</literal>. По умолчанию - <code>MIN</code>, то есть до минут.</para>
                <para>Если <code>resolution=&quot;DAY&quot;</code> и не указан атрибут <sgmltag>dateFormat</sgmltag>, то в качестве формата будет взят формат, указанный в <link linkend="main_message_pack">главном пакете сообщений</link> с ключом <sgmltag>dateFormat</sgmltag>.</para>
                <para>Если <code>resolution=&quot;MIN&quot;</code> и не указан атрибут <sgmltag>dateFormat</sgmltag>, то в качестве формата будет взят формат, указанный в <link linkend="main_message_pack">главном пакете сообщений</link> с ключом <sgmltag>dateTimeFormat</sgmltag>.</para>
                <para>Ниже показано определения поля для ввода даты с точностью до месяца.</para>
                <programlisting language="xml">&lt;dateField resolution=&quot;MONTH&quot; caption=&quot;msg://monthOnlyDateField&quot;/&gt;</programlisting>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_dateField_resolution.png"/>
                  </imageobject>
                </mediaobject>
              </listitem>
            </itemizedlist>.</para>
          <para>Атрибуты <sgmltag>dateField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry><entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>dateField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_Embedded">
          <title>Embedded</title>
          <para>Компонент <code>Embedded</code> предназначен для вывода изображений и встраивания в экран произвольных веб-страниц.</para>
          <para>XML-имя компонента: <sgmltag>embedded</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_Embedded_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. В десктоп-клиенте поддерживается только вывод изображений.</para>
          <para>Рассмотрим пример использования компонента для вывода изображения из файла, сохраненного в <link linkend="file_storage">FileStorage</link>. <itemizedlist>
              <listitem>
                <para>Объявляем компонент в XML-дескрипторе экрана:<programlisting language="xml">&lt;groupBox caption=&quot;Embedded&quot; spacing=&quot;true&quot;
          height=&quot;250px&quot; width=&quot;250px&quot; expand=&quot;embedded&quot;&gt;
    &lt;embedded id=&quot;embedded&quot; width=&quot;100%&quot;
              align=&quot;MIDDLE_CENTER&quot;/&gt;
&lt;/groupBox&gt;</programlisting></para>
              </listitem>
              <listitem>
                <para>В контроллере экрана инжектируем компонент и интерфейс <code>FileStorageService</code>. Затем в методе <code>init()</code> получаем из параметров экрана переданный из вызывающего кода <code>FileDescriptor</code>, загружаем соответствующий файл в байтовый массив, создаем для него <code>ByteArrayInputStream</code> и передаем в метод <code>setSource()</code> компонента:<programlisting language="java">@Inject
private Embedded embedded;

@Inject
private FileStorageService fileStorageService;

@Override
public void init(Map&lt;String, Object&gt; params) {
    FileDescriptor imageFile = (FileDescriptor) params.get(&quot;imageFile&quot;);

    byte[] bytes = null;
    if (imageFile != null) {
        try {
            bytes = fileStorageService.loadFile(imageFile);
        } catch (FileStorageException e) {
            showNotification(&quot;Unable to load image file&quot;, NotificationType.HUMANIZED);
        }
    }
    if (bytes != null) {
        embedded.setSource(imageFile.getName(), new ByteArrayInputStream(bytes));
        embedded.setType(Embedded.Type.IMAGE);
    } else {
        embedded.setVisible(false);
    }
}</programlisting></para>
              </listitem>
            </itemizedlist></para>
          <para>Веб-клиент позволяет выводить изображения из произвольных файлов на диске, доступных блоку Web Client. Для этого нужно определить каталог ресурсных файлов в свойстве приложения <link linkend="cuba.web.resourcesRoot">cuba.web.resourcesRoot</link>, и указать для компонента <code>Embedded</code> имя файла внутри этого каталога:<programlisting language="java">embedded.setSource(&quot;my-logo.png&quot;);</programlisting></para>
          <para>Для встраивания в экран веб-клиента внешней веб-страницы необходимо передать компоненту URL:<programlisting language="java">try {
    embedded.setSource(new URL(&quot;http://www.cuba-platform.com&quot;));
} catch (MalformedURLException e) {
    throw new RuntimeException(e);
}</programlisting></para>
          <para>Атрибуты <code>embedded</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_FieldGroup">
          <title>FieldGroup</title>
          <para>Компонент <code>FieldGroup</code> предназначен для совместного отображения и редактирования нескольких атрибутов сущностей. </para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_fieldGroup.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>fieldGroup</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_FieldGroup_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Пример описания группы полей в XML-дескрипторе экрана:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;orderDs&quot;
                class=&quot;com.sample.sales.entity.Order&quot;
                view=&quot;orderWithCustomer&quot;&gt;
    &lt;/datasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;fieldGroup id=&quot;orderFieldGroup&quot; datasource=&quot;orderDs&quot; width=&quot;250px&quot;&gt;
        &lt;field id=&quot;date&quot;/&gt;
        &lt;field id=&quot;customer&quot;/&gt;
        &lt;field id=&quot;amount&quot;/&gt;
    &lt;/fieldGroup&gt;</programlisting></para>
          <para>Здесь в элементе <code>dsContext</code> определен <link linkend="datasources">источник данных</link> <code>datasource</code>, который содержит один экземпляр  сущности <code>Order</code>. Для компонента <code>fieldGroup</code> в атрибуте <code>datasource</code> указывается используемый источник данных, а в элементах <code>field</code> - какие атрибуты сущности, содержащейся в источнике данных, необходимо отобразить.</para>
          <para>Элементы <code>fieldGroup</code>:<itemizedlist>
              <listitem>
                <para><code>column</code> - необязательный элемент, позволяющий располагать поля в несколько колонок. Для этого элементы <code>field</code> должны находиться не непосредственно внутри <code>fieldGroup</code>, а внутри своего <code>column</code>. Например:<programlisting language="xml">&lt;fieldGroup id=&quot;orderFieldGroup&quot; datasource=&quot;orderDs&quot; width=&quot;100%&quot;&gt;
    &lt;column width=&quot;250px&quot;&gt;
        &lt;field id=&quot;num&quot;/&gt;
        &lt;field id=&quot;date&quot;/&gt;
        &lt;field id=&quot;amount&quot;/&gt;
    &lt;/column&gt;
    &lt;column width=&quot;400px&quot;&gt;
        &lt;field id=&quot;customer&quot;/&gt;
        &lt;field id=&quot;info&quot;/&gt;
    &lt;/column&gt;
&lt;/fieldGroup&gt;</programlisting></para>
                <para>В данном случае поля будут расположены в две колонки, причем в первой колонке все поля будут шириной <code>250px</code>, а во второй - <code>400px</code>.</para>
                <para>Элемент <code>column</code> может иметь следующие атрибуты:<itemizedlist>
                    <listitem id="gui_attr_fieldGroup_width">
                      <para><code>width</code> - задает ширину полей данной колонки. По умолчанию ширина полей - <code>200px</code>. В данном атрибуте ширина может быть задана как в пикселах, так и в процентах от общего размера колонки по горизонтали.</para>
                    </listitem>
                    <listitem id="gui_attr_fieldGroup_flex">
                      <para><code>flex</code> - число, задающее степень изменения общего размера  данной колонки по горизонтали относительно других колонок при изменении ширины всего компонента <code>fieldGroup</code>. Например, можно задать одной колонке <code>flex=1</code> а другой <code>flex=3</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>id</code> - необязательный идентификатор колонки, позволяющий ссылаться на нее в случае <link linkend="screen_extension">расширении экрана</link>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><code>field</code> - основной элемент компонента, описывает одно поле компонента. </para>
                <para>Атрибуты элемента <code>field</code>:<itemizedlist>
                    <listitem id="gui_attr_fieldGroup_field_id">
                      <para><code>id</code> - обязательный атрибут, должен содержать либо название атрибута сущности, выводимого в поле, либо произвольный уникальный идентификатор программно определяемого поля. В последнем случае элемент <code>field</code> должен иметь также атрибут <code>custom=&quot;true&quot;</code> (см. далее).</para>
                    </listitem>
                    <listitem id="gui_attr_fieldGroup_field_caption">
                      <para><code>caption</code> − позволяет задать  заголовок поля. Если не задан, будет отображено <link linkend="entity_localization">локализованное название атрибута</link> сущности.</para>
                    </listitem>
                    <listitem>
                      <para><code>visible</code> − позволяет  скрыть поле вместе с заголовком.</para>
                    </listitem>
                    <listitem id="gui_attr_fieldGroup_field_datasource">
                      <para><code>datasource</code> − позволяет задать для данного поля <link linkend="datasources">источник данных</link>, отличный от заданного для всего компонента <code>fieldGroup</code>. Таким образом в группе полей могут отображаться атрибуты разных сущностей.</para>
                    </listitem>
                    <listitem>
                      <para><code>optionsDatasource</code> − задает имя <link linkend="datasources">источника данных</link>, используемого для формирования списка опций. Данный атрибут можно задать для поля, связанного со ссылочным атрибутом сущности. По умолчанию выбор связанной сущности производится через экран выбора, а если <code>optionsDatasource</code> указан, то связанную сущность можно выбирать из выпадающего списка опций. Фактически указание <code>optionsDatasource</code> приводит к тому, что вместо компонента <link linkend="gui_PickerField">PickerField</link> в поле используется <link linkend="gui_LookupPickerField">LookupPickerField</link>. </para>
                    </listitem>
                    <listitem>
                      <para><code>width</code> − позволяет задать  ширину поля без учета заголовка. По умолчанию ширина поля - <code>200px</code>. Ширина может быть задана как в пикселах, так и в процентах от общего размера колонки по горизонтали. Для указания ширины всех полей одновременно можно использовать атрибут <code>width</code> элемента <code>column</code>, описанный выше.</para>
                    </listitem>
                    <listitem id="gui_attr_fieldGroup_field_custom">
                      <para><code>custom</code> - установка этого атрибута в <code>true</code> позволяет задать собственное представление поля, или говорит о том, что идентификатор поля не ссылается на атрибут сущности, и компонент, находящийся в поле, будет задан программно с помощью метода <code>addCustomField()</code> компонента <code>FieldGroup</code> (см. ниже). </para>
                    </listitem>
                  </itemizedlist></para>
                <para>Следующие атрибуты элемента <code>field</code> можно применять в зависимости от типа атрибута сущности, отображаемого полем:<itemizedlist>
                    <listitem>
                      <para>Если для текстового атрибута сущности задать значение атрибута <sgmltag>mask</sgmltag>, то в поле вместо компонента <link linkend="gui_TextField">TextField</link> будет использоваться компонент <link linkend="gui_MaskedField">MaskedField</link> с соотвествующей маской. В этом случае можно также задать атрибут <code>valueMode</code>.</para>
                    </listitem>
                    <listitem id="gui_attr_fieldGroup_field_rows">
                      <para>Если для текстового атрибута сущности задать значение атрибута <sgmltag>rows</sgmltag>, то в поле вместо компонента <link linkend="gui_TextField">TextField</link> будет использоваться компонент <link linkend="gui_TextArea">TextArea</link> с соответствующим количеством строк. В этом случае можно также задать атрибут <code>cols</code>.</para>
                    </listitem>
                    <listitem>
                      <para>Для текстового атрибута сущности можно задать атрибут <code>maxLength</code> аналогично описанному для <link linkend="gui_TextField">TextField</link>.</para>
                    </listitem>
                    <listitem>
                      <para>Для атрибута сущности типа <code>date</code> или <code>dateTime</code> можно задать атрибуты <code>dateFormat</code> и <code>resolution</code> для параметризации находящегося в поле компонента <link linkend="gui_DateField">DateField</link>.</para>
                    </listitem>
                    <listitem>
                      <para>Для атрибута сущности типа <code>time</code> можно задать атрибут <code>showSeconds</code> для параметризации находящегося в поле компонента <link linkend="gui_TimeField">TimeField</link>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
          <para>Атрибуты <code>fieldGroup</code>:<itemizedlist>
              <listitem id="gui_attr_fieldGroup_border">
                <para>Атрибут <sgmltag>border</sgmltag> может принимать значение <literal>hidden</literal> или <literal>visible</literal>. По умолчанию - <code>hidden</code>. При установке  в значение <literal>visible</literal> компонент <sgmltag>fieldGroup</sgmltag> выделяется рамкой. В веб-реализации компонента отображение рамки осуществляется добавлением CSS-класса <code>cuba-fieldgroup-border</code>. </para>
              </listitem>
            </itemizedlist></para>
          <para>Методы интерфейса <code>FieldGroup</code>:<itemizedlist>
              <listitem>
                <para>Метод <code>addCustomField()</code> используется вместе с атрибутом <code>custom=&quot;true&quot;</code> элемента <code>field</code> и позволяет задать собственное представление поля. Он принимает два параметра: идентификатор поля, заданный в атрибуте <code>id</code> элемента <code>field</code>,  и реализацию интерфейса <code>FieldGroup.CustomFieldGenerator</code>.</para>
                <para>Метод <code>generateField()</code> интерфейса <code>CustomFieldGenerator</code> вызывается компонентом <code>FieldGroup</code>, и в него передается <link linkend="datasources">источник данных</link> и идентификатор поля, для которого зарегистрирован данный генератор. Метод должен вернуть визуальный компонент (или контейнер), который и будет отображен в поле.</para>
                <para>Пример использования:<programlisting language="java">@Inject
protected FieldGroup fieldGroup;

@Inject
protected ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
    fieldGroup.addCustomField(&quot;password&quot;, new FieldGroup.CustomFieldGenerator() {
        @Override
        public Component generateField(Datasource datasource, String propertyId) {
            PasswordField passwordField = componentsFactory.createComponent(PasswordField.NAME);
            passwordField.setDatasource(datasource, propertyId);
            return passwordField;
        }
    });
}</programlisting></para>
              </listitem>
              <listitem>
                <para>Метод <code>getFieldComponent()</code> возвращает визуальный компонент, находящийся в поле с указанным идентификатором. Это может потребоваться для дополнительной параметризации компонента, недоступной через атрибуты XML-элемента <code>field</code>, описанные выше. </para>
                <para>Вместо явного вызова <code>getFieldComponent()</code> для получения ссылки на компонент поля в контроллере экрана можно использовать <link linkend="screen_controller_injection">инжекцию</link>. Для этого следует использовать аннотацию <code>@Named</code> с указанием идентификатора самого <code>fieldGroup</code>, и через точку - идентификатора поля. </para>
                <para>Например, следующим образом в поле выбора связанной сущности  можно добавить действие открытия экземпляра и убрать действие очистки поля:<programlisting language="xml">&lt;fieldGroup id=&quot;orderFieldGroup&quot; datasource=&quot;orderDs&quot;&gt;
    &lt;field id=&quot;date&quot;/&gt;
    &lt;field id=&quot;customer&quot;/&gt;
    &lt;field id=&quot;amount&quot;/&gt;
&lt;/fieldGroup&gt;</programlisting><programlisting language="java">@Named(&quot;orderFieldGroup.customer&quot;)
protected PickerField customerField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    customerField.addOpenAction();
    customerField.removeAction(customerField.getAction(PickerField.ClearAction.NAME));
}</programlisting></para>
                <para>Для использования метода <code>getFieldComponent()</code> или инжекции компонентов полей необходимо знать тип компонента, находящегося в поле. В следующей таблице приведено соответствие типов атрибутов сущностей и создаваемых для них компонентов:<informaltable frame="all">
                    <tgroup cols="3">
                      <colspec colnum="1" colname="c1" align="left"/>
                      <colspec colnum="2" colname="c2" align="left"/>
                      <colspec colnum="3" colname="c3" align="left"/>
                      <thead>
                        <row>
                          <entry>Тип атрибута сущности</entry>
                          <entry>Дополнительные условия</entry>
                          <entry>Тип компонента поля</entry>
                        </row>
                      </thead>
                      <tbody>
                        <row>
                          <entry morerows="1">Связанная сущность</entry>
                          <entry>Задан атрибут <code> optionsDatasource</code></entry>
                          <entry>
                            <link linkend="gui_LookupPickerField">LookupPickerField</link>
                          </entry>
                        </row>
                        <row>
                          <entry/>
                          <entry>
                            <link linkend="gui_PickerField">PickerField</link>
                          </entry>
                        </row>
                        <row>
                          <entry>Перечисление (<code>enum</code>)</entry>
                          <entry/>
                          <entry>
                            <link linkend="gui_LookupField">LookupField</link>
                          </entry>
                        </row>
                        <row>
                          <entry morerows="2">
                            <code>string</code>
                          </entry>
                          <entry>Задан атрибут <code>mask</code></entry>
                          <entry>
                            <link linkend="gui_MaskedField">MaskedField</link>
                          </entry>
                        </row>
                        <row>
                          <entry>Задан атрибут <code>rows</code></entry>
                          <entry>
                            <link linkend="gui_TextArea">TextArea</link>
                          </entry>
                        </row>
                        <row>
                          <entry/>
                          <entry>
                            <link linkend="gui_TextField">TextField</link>
                          </entry>
                        </row>
                        <row>
                          <entry>
                            <code>boolean</code>
                          </entry>
                          <entry/>
                          <entry>
                            <link linkend="gui_CheckBox">CheckBox</link>
                          </entry>
                        </row>
                        <row>
                          <entry><code>date</code>, <code>dateTime</code></entry>
                          <entry/>
                          <entry>
                            <link linkend="gui_DateField">DateField</link>
                          </entry>
                        </row>
                        <row>
                          <entry>
                            <code>time</code>
                          </entry>
                          <entry/>
                          <entry>
                            <link linkend="gui_TimeField">TimeField</link>
                          </entry>
                        </row>
                        <row>
                          <entry><code>int</code>, <code>long</code>, <code>double</code>, <code>decimal</code></entry>
                          <entry/>
                          <entry>
                            <link linkend="gui_TextField">TextField</link>
                          </entry>
                        </row>
                      </tbody>
                    </tgroup>
                  </informaltable></para>
              </listitem>
            </itemizedlist></para>
          <para>Все атрибуты <sgmltag>fieldGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_fieldGroup_border">border</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Все атрибуты <code>field</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_textArea_cols_rows">cols</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_custom">custom</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_fieldGroup_field_rows">rows</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_timeField_showSeconds">showSeconds</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_fieldGroup_field_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <code>field</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты <code>column</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_fieldGroup_flex">flex</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="gui_attr_fieldGroup_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_FileMultiUploadField">
          <title>FileMultiUploadField</title>
          <para>Компонент <code>FileMultiUploadField</code> позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается стандартное для операционной системы окно выбора файлов, в котором можно выбрать сразу несколько файлов для загрузки.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_multipleUpload.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>multiUpload</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="80%" align="center" fileref="img/gui_FileMultiUploadField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. Для работы веб-версии компонента необходима поддержка браузером технологии <productname>Flash</productname>.</para>
          <para>Рассмотрим пример использования  компонента.</para>
          <itemizedlist>
            <listitem>
              <para>Объявляем компонент в XML-дескрипторе экрана:<programlisting language="xml">&lt;multiUpload id=&quot;multiUploadField&quot; caption=&quot;msg://upload&quot;/&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>В контроллере экрана инжектируем сам компонент, а также интерфейсы <link linkend="file_upload">FileUploadingAPI</link> и <link linkend="dataSupplier">DataSupplier</link>. Затем в методе <code>init()</code> добавляем компоненту слушатель, который будет реагировать на события успешной загрузки или ошибки:<programlisting language="java">@Inject
protected FileMultiUploadField multiUploadField;

@Inject
protected FileUploadingAPI fileUploading;

@Inject
protected DataSupplier dataSupplier;

@Override
public void init(Map&lt;String, Object&gt; params) {
    multiUploadField.addListener(new FileMultiUploadField.UploadListener() {
        @Override
        public void queueUploadComplete() {
            Map&lt;UUID, String&gt; uploadMap = multiUploadField.getUploadsMap();
            for (Map.Entry&lt;UUID, String&gt; entry : uploadMap.entrySet()) {
                UUID fileId = entry.getKey();
                String fileName = entry.getValue();
                FileDescriptor fd = fileUploading.getFileDescriptor(fileId, fileName);
                // save file to FileStorage
                try {
                    fileUploading.putFileIntoStorage(fileId, fd);
                } catch (FileStorageException e) {
                    new RuntimeException(e);
                }
                // save file descriptor to database
                dataSupplier.commit(fd, null);
            }
            multiUploadField.clearUploads();
        }
    });
}</programlisting></para>
              <para>Метод <code>queueUploadComplete()</code> будет вызван компонентом после успешной загрузки всех выбранных файлов во временное хранилище клиентского <link linkend="app_tiers">уровня</link>.   В этот момент вызовом метода <code>getUploadsMap()</code> у компонента можно получить мэп идентификаторов файлов во временном хранилище на имена файлов. Далее по этим данным для каждого файла создается соответствующий   объект <code>FileDescriptor</code>. Объект <code>com.haulmont.cuba.core.entity.FileDescriptor</code> (не путать с <code>java.io.FileDescriptor</code>) является персистентной сущностью, которая однозначно идентифицирует загруженный файл и впоследствии используется для выгрузки файла из системы.</para>
              <para>Метод <code>FileUploadingAPI.putFileIntoStorage()</code> используется для перемещения загружаемого файла из временного хранилища клиентского уровня в <link linkend="file_storage">FileStorage</link>. Параметрами этого метода являются идентификатор файла во временном хранилище и объект <code>FileDescriptor</code>. </para>
              <para>После загрузки файла в <code>FileStorage</code> выполняется сохранение экземпляра <code>FileDescriptor</code> в базе данных посредством вызова <code>DataSupplier.commit()</code>. Возвращаемый этим методом сохраненный экземпляр может быть установлен в атрибут какой-либо сущности предметной области, связанной с данным файлом. В данном же случае <code>FileDescriptor</code> просто хранится в системе и дает доступ к файлу через экран <guimenu>Administration</guimenu> &gt; <guimenu>External Files</guimenu>.</para>
              <para>После обработки файлов необходимо очистить список файлов вызовом <code>clearUploads()</code>  на случай повторной загрузки.</para>
            </listitem>
            <listitem>
              <para>Максимальный размер загружаемого файла определяется свойством приложения <link linkend="cuba.client.maxUploadSizeMb">cuba.client.maxUploadSizeMb</link> и по умолчанию равен 20Мб. При выборе пользователем файла большего размера выдается соответствующее сообщение и загрузка прерывается.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>multiUpload</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_FileUploadField">
          <title>FileUploadField</title>
          <para>Компонент <code>FileUploadField</code> позволяет пользователю загружать файлы на сервер. Компонент представляет собой кнопку, при нажатии на которую на экране отображается стандартное для операционной системы окно, в котором можно выбрать  один файл. Чтобы дать пользователю возможность загружать сразу несколько файлов, используйте компонент <link linkend="gui_FileMultiUploadField">FileMultiUploadField</link>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_upload.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>upload</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_FileUploadField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Рассмотрим пример использования  компонента.</para>
          <itemizedlist>
            <listitem>
              <para>Объявляем компонент в XML-дескрипторе экрана:<programlisting language="xml">&lt;upload id=&quot;uploadField&quot; caption=&quot;msg://upload&quot;/&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>В контроллере экрана инжектируем сам компонент, а также интерфейсы <link linkend="file_upload">FileUploadingAPI</link> и <link linkend="dataSupplier">DataSupplier</link>. Затем в методе <code>init()</code> добавляем компоненту слушатель, который будет реагировать на события успешной загрузки или ошибки:<programlisting language="java">@Inject
protected FileUploadField uploadField;

@Inject
protected FileUploadingAPI fileUploading;

@Inject
protected DataSupplier dataSupplier;

@Override
public void init(Map&lt;String, Object&gt; params) {
    uploadField.addListener(new FileUploadField.ListenerAdapter() {
        @Override
        public void uploadSucceeded(Event event) {
            FileDescriptor fd = uploadField.getFileDescriptor();
            try {
                // save file to FileStorage
                fileUploading.putFileIntoStorage(uploadField.getFileId(), fd);
            } catch (FileStorageException e) {
                throw new RuntimeException(e);
            }
            // save file descriptor to database
            dataSupplier.commit(fd, null);

            showNotification(&quot;File uploaded: &quot; + uploadField.getFileName(), NotificationType.HUMANIZED);
        }

        @Override
        public void uploadFailed(Event event) {
            showNotification(&quot;File upload error&quot;, NotificationType.HUMANIZED);
        }
    });
}</programlisting></para>
              <para>Метод <code>uploadSucceeded()</code> будет вызван компонентом после успешной загрузки файла во временное хранилище клиентского <link linkend="app_tiers">уровня</link>. В этот момент у компонента можно получить объект <code>FileDescriptor</code>, соответствующий загруженному файлу. Объект <code>com.haulmont.cuba.core.entity.FileDescriptor</code> (не путать с <code>java.io.FileDescriptor</code>) является персистентной сущностью, которая однозначно идентифицирует загруженный файл и впоследствии используется для выгрузки файла из системы.</para>
              <para>Метод <code>FileUploadingAPI.putFileIntoStorage()</code> используется для перемещения загружаемого файла из временного хранилища клиентского уровня в <link linkend="file_storage">FileStorage</link>. Параметрами этого метода являются идентификатор файла во временном хранилище и объект <code>FileDescriptor</code>. Оба эти параметра предоставляет <code>FileUploadField</code>.</para>
              <para>После загрузки файла в <code>FileStorage</code> выполняется сохранение экземпляра <code>FileDescriptor</code> в базе данных посредством вызова <code>DataSupplier.commit()</code>. Возвращаемый этим методом сохраненный экземпляр может быть установлен в атрибут какой-либо сущности предметной области, связанной с данным файлом. В данном же случае <code>FileDescriptor</code> просто хранится в системе и дает доступ к файлу через экран <guimenu>Administration</guimenu> &gt; <guimenu>External Files</guimenu>.</para>
              <para>Метод <code>uploadFailed()</code> вызывается компонентом <code>FileUploadField</code> в случае ошибки загрузки файла во временное хранилище клиентского уровня.</para>
            </listitem>
            <listitem>
              <para>Максимальный размер загружаемого файла определяется свойством приложения <link linkend="cuba.client.maxUploadSizeMb">cuba.client.maxUploadSizeMb</link> и по умолчанию равен 20Мб. При выборе пользователем файла большего размера выдается соответствующее сообщение и загрузка прерывается.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>upload</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_Filter">
          <title>Filter</title>
          <para><para>Компонент <code>Filter</code> − универсальное средство фильтрации списков сущностей, извлекаемых из базы данных для отображения в табличном виде.</para><para><code>Filter</code> должен быть связан с <link linkend="datasources">источником данных</link> <code>collectionDatasource</code>, содержащим <link linkend="datasource_query">запрос</link> на JPQL. Принцип действия фильтра основан на модификации этого запроса в соответствии с критериями, заданными пользователем. Таким образом фильтрация осуществляется на уровне БД при выполнении транслированного из JPQL в SQL запроса, и на <structname>Middleware</structname> и клиентский <link linkend="app_tiers">уровень</link> загружаются только отобранные данные.</para></para>
          <section>
            <title>Использование фильтра</title>
            <para>Типичный фильтр имеет следующий вид:</para>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_descr.png"/>
              </imageobject>
            </mediaobject>
            <para>Для того чтобы создать фильтр, нажмите на кнопку <guibutton>Фильтр</guibutton> и выберите  <guilabel>Создать</guilabel>. На экране отобразится  панель редактора фильтра:</para>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_editor.png"/>
              </imageobject>
            </mediaobject>
            <para>В поле <guilabel>Имя</guilabel> следует ввести имя фильтра, это имя будет отображаться в списке доступных фильтров текущего экрана.</para>
            <para>В таблице содержатся условия фильтра. Условия можно поменять местами с помощью кнопок <inlinemediaobject>
                <imageobject>
                  <imagedata fileref="img/gui_filter_cond_down.png"/>
                </imageobject>
              </inlinemediaobject>/<inlinemediaobject>
                <imageobject>
                  <imagedata fileref="img/gui_filter_cond_up.png"/>
                </imageobject>
              </inlinemediaobject> или удалить с помощью кнопки <inlinemediaobject>
                <imageobject>
                  <imagedata fileref="img/gui_filter_remove.png"/>
                </imageobject>
              </inlinemediaobject>.</para>
            <para>С помощью соответствующих флажков можно сделать выбранное в таблице условие скрытым или обязательным для заполнения. Параметр скрытого условия не отображается пользователю, поэтому он  должны быть введен во время редактирования фильтра.</para>
            <para>Фильтр можно сделать <firstterm>глобальным</firstterm> (то есть доступным для всех пользователей) с помощью установки флажка <guilabel>Общий для всех пользователей</guilabel>, или установить текущий фильтр в качестве фильтра по умолчанию с помощью установки флажка <guilabel>По умолчанию</guilabel>.</para>
            <para>Чтобы добавить новое условие, следует нажать кнопку <guibutton>Добавить условие</guibutton> в редакторе фильтра. На экране отобразится окно выбора условий. </para>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_conditions.png"/>
              </imageobject>
            </mediaobject>
            <para>Рассмотрим возможные типы условий:<itemizedlist>
                <listitem>
                  <para><guilabel>Атрибуты</guilabel> - атрибуты данной сущности и связанных с ней сущностей. Отображаются персистентные атрибуты, явно заданные в элементе <sgmltag>property</sgmltag>  XML-описателя фильтра, либо соответствующие правилам, указанным в элементе <sgmltag>properties</sgmltag> (см. ниже).</para>
                </listitem>
                <listitem>
                  <para><guilabel>Специальные условия</guilabel> - условия, заданные разработчиком в элементах <code>custom</code>  XML-описателя фильтра.</para>
                </listitem>
                <listitem>
                  <para><guilabel>Группы</guilabel> - позволяет добавить группировку условий по И или ИЛИ. Все добавленные на верхний уровень (то есть без явной группировки) условия объединяются по И.</para>
                </listitem>
                <listitem>
                  <para><guilabel>Динамический атрибут</guilabel> - позволяет выбрать условие по <link linkend="runtime_properties">динамическому атрибуту</link>, если данная сущность является наследником <code>CategorizedEntity</code> и, соответственно, может иметь динамические атрибуты.</para>
                </listitem>
                <listitem>
                  <para><guilabel>Создать новое</guilabel> - позволяет создать новое произвольное условие на JPQL. Данный пункт доступен пользователю, если у него есть специфическое разрешение <code>cuba.gui.filter.customConditions</code> (см. руководство по <productname>Подсистеме безопасности</productname>).</para>
                </listitem>
              </itemizedlist></para>
          </section>
          <section>
            <title>Описание компонента Filter</title>
            <para>XML-имя компонента: <sgmltag>filter</sgmltag>.</para>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_dia.png"/>
              </imageobject>
            </mediaobject>
            <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
            <para>Пример объявления компонента в XML-дескрипторе экрана:<programlisting language="xml">&lt;dsContext&gt;
    &lt;collectionDatasource id=&quot;carsDs&quot; class=&quot;com.company.sample.entity.Car&quot; view=&quot;carBrowse&quot;&gt;
        &lt;query&gt;
            select c from ref$Car c order by c.createTs
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout spacing=&quot;true&quot;&gt;

    &lt;filter id=&quot;carsFilter&quot; datasource=&quot;carsDs&quot;&gt;
        &lt;properties include=&quot;.*&quot;/&gt;
    &lt;/filter&gt;

    &lt;table id=&quot;carsTable&quot; width=&quot;100%&quot;&gt;
        &lt;buttonsPanel&gt;
            &lt;button action=&quot;carsTable.create&quot;/&gt;
            &lt;button action=&quot;carsTable.edit&quot;/&gt;
            &lt;button action=&quot;carsTable.remove&quot;/&gt;
        &lt;/buttonsPanel&gt;
        &lt;rowsCount/&gt;
        &lt;columns&gt;
            &lt;column id=&quot;vin&quot;/&gt;
            &lt;column id=&quot;model.name&quot;/&gt;
            &lt;column id=&quot;colour.name&quot;/&gt;
        &lt;/columns&gt;
        &lt;rows datasource=&quot;carsDs&quot;/&gt;
    &lt;/table&gt;</programlisting></para>
            <para>Здесь в элементе <code>dsContext</code> определен <link linkend="datasources">источник данных</link> <code>collectionDatasource</code>, который выбирает экземпляры сущности <code>Car</code> с помощью JPQL запроса. Для компонента <code>filter</code>  в его атрибуте <code>datasource</code> указан фильтруемый источник данных. Данные отображаются компонентом <link linkend="gui_Table">Table</link>, связанным с этим же источником. </para>
            <para>Элемент    <sgmltag>filter</sgmltag> может содержать вложенные элементы. Все они описывают условия, доступные пользователю для выбора в диалоге добавления условий:<itemizedlist>
                <listitem id="gui_element_filter_properties">
                  <para><code>properties</code> - позволяет сделать доступными  сразу несколько атрибутов сущности. Данный элемент может иметь следующие атрибуты:<itemizedlist>
                      <listitem id="gui_attr_filter_include">
                        <para><code>include</code> - обязательный атрибут, содержит  регулярное выражение, которому должно соответствовать имя атрибута сущности.</para>
                      </listitem>
                      <listitem id="gui_attr_filter_exclude">
                        <para><code>exclude</code> - содержит регулярное выражение, при соответствии которому атрибут сущности исключается из ранее включенных с помощью <code>include</code>.</para>
                      </listitem>
                    </itemizedlist></para>
                  <para>Например:<programlisting language="xml">&lt;filter id=&quot;transactionsFilter&quot; datasource=&quot;transactionsDs&quot;&gt;
    &lt;properties include=&quot;.*&quot; exclude=&quot;(masterTransaction)|(authCode)&quot;/&gt;
&lt;/filter&gt;</programlisting></para>
                  <para>При использовании элемента  <code>properties</code> автоматически игнорируются следующие атрибуты сущности:<itemizedlist>
                      <listitem>
                        <para>Коллекции (<code>@OneToMany</code>, <code>@ManyToMany</code>).</para>
                      </listitem>
                      <listitem>
                        <para>Атрибуты, не имеющие <link linkend="entity_localization">локализованного названия</link>.</para>
                      </listitem>
                      <listitem>
                        <para>Атрибут <code>version</code>.</para>
                      </listitem>
                    </itemizedlist></para>
                </listitem>
                <listitem id="gui_element_filter_property">
                  <para><code>property</code> - явно включает атрибут сущности по имени. Данный элемент может иметь следующие атрибуты:<itemizedlist>
                      <listitem id="gui_attr_filter_name">
                        <para><code>name</code> - обязательный атрибут, содержит имя включаемого атрибута сущности. Может быть путем (через &quot;.&quot;) по графу сущностей. Например:<programlisting language="xml">&lt;filter id=&quot;transactionsFilter&quot; datasource=&quot;transactionDs&quot; applyTo=&quot;table&quot;&gt;
    &lt;properties include=&quot;.*&quot; exclude=&quot;(masterTransaction)|(authCode)&quot;/&gt;
    &lt;property name=&quot;creditCard.maskedPan&quot; caption=&quot;msg://EmbeddedCreditCard.maskedPan&quot;/&gt;
    &lt;property name=&quot;creditCard.startDate&quot; caption=&quot;msg://EmbeddedCreditCard.startDate&quot;/&gt;
&lt;/filter&gt;</programlisting></para>
                      </listitem>
                      <listitem id="gui_attr_filter_caption">
                        <para><code>caption</code> - локализованное название атрибута сущности для отображения условия фильтра. Как правило, представляет из себя строку с префиксом <code>msg://</code> по правилам <code>MessageTools.<link linkend="messageTools.loadString">loadString</link>()</code>.</para>
                        <para>Если в атрибуте <code>name</code> указан путь (через &quot;.&quot;) по графу сущностей, то атрибут <code>caption</code> является обязательным.</para>
                      </listitem>
                      <listitem>
                        <para id="gui_attr_filter_paramWhere"><sgmltag>paramWhere</sgmltag> − задает выражение на JPQL для  отбора списка значений параметра условия, если параметр является связанной сущностью. Вместо алиаса отбираемой сущности в выражении нужно использовать метку (placeholder) <code> {E}</code>. </para>
                        <para>Например, для фильтра на сущность <code>Car</code> добавляется условие по связанной сущности <code>Model</code>. Тогда можно ограничить список возможных значений параметра условия  только моделями марки <userinput>Audi</userinput>:<programlisting language="xml">&lt;filter id=&quot;carsFilter&quot; datasource=&quot;carsDs&quot;&gt;
   &lt;property name=&quot;model&quot; paramWhere=&quot;{E}.manufacturer = &apos;Audi&apos;&quot;/&gt;
&lt;/filter&gt;</programlisting><mediaobject>
                            <imageobject>
                              <imagedata align="center" fileref="img/gui_filter_paramWhere.png"/>
                            </imageobject>
                          </mediaobject></para>
                        <para>В выражении JPQL можно использовать параметры экрана, атрибуты сессии, а также компоненты экрана, в том числе отображающие другие параметры. Правила задания параметров запроса описаны в <xref linkend="datasource_query"/>. </para>
                        <para>Пример использования параметра сессии и параметра экрана:<programlisting>{E}.createdBy = :session$userLogin and {E}.name like :param$groupName</programlisting></para>
                        <para>Пример использования значения параметра другого условия фильтра:<programlisting>{E}.proc.id = :component$cardsFilter.proc68779</programlisting></para>
                        <para>Имя компонента, отображающего параметр условия, можно узнать, вызвав контекстное меню на строке таблицы условий в редакторе фильтра:</para>
                        <mediaobject>
                          <imageobject>
                            <imagedata align="center" fileref="img/gui_filter_component_name.png"/>
                          </imageobject>
                        </mediaobject>
                      </listitem>
                      <listitem>
                        <para id="gui_attr_filter_paramView"><sgmltag>paramView</sgmltag> − задает <link linkend="views">представление</link>, с которым будет загружаться список значений параметра условия, если параметр является связанной сущностью. Например, <literal>_local</literal>. Если не указано, используется <code>_minimal</code>.</para>
                      </listitem>
                    </itemizedlist></para>
                </listitem>
                <listitem id="gui_element_filter_custom">
                  <para><code>custom</code> - элемент, определяющий произвольное условие. Содержимым элемента должно быть выражение на JPQL (возможно использование <link linkend="jpql_macro">JPQL Macros</link>), которое будет добавлено в условие <code>where</code> запроса источника данных. Параметр условия может быть только один, и если он есть, обозначается символом <literal>?</literal>. </para>
                  <para>Пример фильтра с произвольными условиями:<programlisting language="xml">&lt;filter id=&quot;carsFilter&quot; datasource=&quot;carsDs&quot;&gt;
   &lt;properties include=&quot;.*&quot;/&gt;
   &lt;custom name=&quot;vin&quot; paramClass=&quot;java.lang.String&quot; caption=&quot;msg://vin&quot;&gt;
      {E}.vin like ?
   &lt;/custom&gt;
   &lt;custom name=&quot;colour&quot; paramClass=&quot;com.company.sample.entity.Colour&quot; caption=&quot;msg://colour&quot; inExpr=&quot;true&quot;&gt;
      ({E}.colour.id in (?))
   &lt;/custom&gt;
   &lt;custom name=&quot;repair&quot; paramClass=&quot;java.lang.String&quot; caption=&quot;msg://repair&quot;
           join=&quot;join {E}.repairs cr&quot;&gt;
      cr.description like ?
   &lt;/custom&gt;
   &lt;custom name=&quot;updateTs&quot; caption=&quot;msg://updateTs&quot;&gt;
      @between({E}.updateTs, now-1, now+1, day)
   &lt;/custom&gt;
&lt;/filter&gt;</programlisting></para>
                  <para>Созданные <code>custom</code> условия отображаются в секции <guilabel>Специальные условия</guilabel>  диалога добавления условий:<mediaobject>
                      <imageobject>
                        <imagedata align="center" fileref="img/gui_filter_custom.png"/>
                      </imageobject>
                    </mediaobject></para>
                  <para>Атрибуты элемента <sgmltag>custom</sgmltag>:</para>
                  <itemizedlist>
                    <listitem>
                      <para id="gui_attr_filter_custom_name"><sgmltag>name</sgmltag> − обязательный атрибут - имя условия.</para>
                    </listitem>
                    <listitem>
                      <para id="gui_attr_filter_custom_caption"><sgmltag>caption</sgmltag> − обязательный атрибут - локализованное название условия. Как правило, представляет из себя строку с префиксом <code>msg://</code> по правилам <code>MessageTools.<link linkend="messageTools.loadString">loadString</link>()</code>.</para>
                    </listitem>
                    <listitem>
                      <para id="gui_attr_filter_custom_paramClass"><sgmltag>paramClass</sgmltag>  − Java-класс параметра условия. Если параметр отсутствует, то данный атрибут не обязателен.</para>
                    </listitem>
                    <listitem>
                      <para id="gui_attr_filter_custom_inExpr"><sgmltag>inExpr</sgmltag> − должен быть установлен в <literal>true</literal>, если выражение JPQL содержит условие <code>in (?)</code>. При этом пользователь будет иметь возможность ввести несколько значений параметра данного условия.</para>
                    </listitem>
                    <listitem>
                      <para id="gui_attr_filter_custom_join"><sgmltag>join</sgmltag> − необязательный атрибут для задания строки, которая будет добавлена в секцию <literal>from</literal> запроса источника данных. Это может потребоваться для создания условия по атрибуту связанной коллекции. Значение данного атрибута должно включать в себя предложения <code>join</code> или <code>left join</code>. </para>
                      <para>Например, предположим что сущность <code>Car</code> имеет атрибут <code>repairs</code>, который представляет собой коллекцию экземпляров связанной сущности <code>Repair</code>. Тогда для фильтрации <code>Car</code> по атрибуту <code>description</code> сущности <code>Repair</code> можно написать следующее условие:<programlisting language="xml">&lt;filter id=&quot;carsFilter&quot; datasource=&quot;carsDs&quot;&gt;
    &lt;custom name=&quot;repair&quot; 
            caption=&quot;msg://repair&quot;
            paramClass=&quot;java.lang.String&quot; 
            join=&quot;join {E}.repairs cr&quot;&gt;
      cr.description like ?
   &lt;/custom&gt;</programlisting></para>
                      <para>При использовании такого условия исходный запрос источника данных:<programlisting>select c from sample$Car c order by c.createTs</programlisting>будет трансформирован в следующий:<programlisting>select c from sample$Car c join c.repairs cr 
where (cr.description like :component_carsFilter_YpzKVsCpmF64816 ) 
order by c.createTs</programlisting></para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>paramWhere</sgmltag> − задает выражение на JPQL для  отбора списка значений параметра условия, если параметр является связанной сущностью. См. описание одноименного атрибута элемента <code>property</code>.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>paramView</sgmltag> − задает <link linkend="views">представление</link>, с которым будет загружаться список значений параметра условия, если параметр является связанной сущностью. Например, <literal>_local</literal>. Если не указано, используется <code>_minimal</code>.</para>
                    </listitem>
                  </itemizedlist>
                </listitem>
              </itemizedlist></para>
            <para>Атрибуты <code>filter</code>:<itemizedlist>
                <listitem>
                  <para id="gui_attr_filter_editable"><code>editable</code> - если значение этого атрибута  равно <literal>false</literal>, то кнопка <guibutton>Фильтр</guibutton> скрывается.</para>
                </listitem>
                <listitem>
                  <para id="gui_attr_filter_required"><code>required</code> - если значение этого атрибута  равно <literal>true</literal>, то  в списке фильтров значение <literal>&lt;без фильтрации&gt;</literal> не отображается, и пользователь обязательно должен выбрать один из доступных фильтров. Если для экрана не установлен фильтр по умолчанию, то в списке выбора фильтра автоматически устанавливается первый созданный фильтр.</para>
                </listitem>
                <listitem>
                  <para id="gui_attr_filter_manualApplyRequired"><sgmltag>manualApplyRequired</sgmltag> − определяет, в какой момент будет   применяться фильтр. Если значение атрибута равно <literal>false</literal>, то сразу при открытии экрана будет применяться фильтр по умолчанию. Если фильтр по умолчанию отсутствует, то установка значения <literal>false</literal> для атрибута теряет смысл. Если значение атрибута равно <code>true</code>, то фильтр будет применяться только после нажатия на кнопку <guibutton>Применить</guibutton>.  </para>
                  <para id="gui_attr_filter_manualApplyRequired_1">Данный атрибут имеет приоритет над свойством приложения  <link linkend="cuba.gui.genericFilterManualApplyRequired">cuba.gui.genericFilterManualApplyRequired</link>.</para>
                </listitem>
                <listitem id="gui_attr_filter_useMaxResults">
                  <para><code>useMaxResults</code>  − ограничивает размер страницы загружаемых в источник данных экземпляров сущности. По умолчанию <code>true</code>.</para>
                  <para>Если значение этого атрибута  равно <literal>false</literal>, то  фильтр не будет отображать поле и флажок <guilabel>Показывать N строк</guilabel>. Количество записей в источнике данных (и соответственно, показываемых таблицей) будет ограничено только параметром <code>MaxFetchUI</code> механизма <link linkend="entity_statistics">статистики сущностей</link>, по умолчанию - 10000.</para>
                  <para>Если данный атрибут не указан, или равен <code>true</code>, то флажок и поле <guilabel>Показывать N строк</guilabel> отображается, если у пользователя также есть специфическое разрешение <code>cuba.gui.filter.maxResults</code> (см.  руководство <productname>Подсистема безопасности</productname>). Если  разрешение <code>cuba.gui.filter.maxResults</code> отсутствует, то фильтр будет принудительно отбирать только первые N строк без возможности пользователя отключить это или указать другое N. Число N  определяется параметрами <literal>FetchUI</literal>, <literal>DefaultFetchUI</literal>, получаемыми из механизма <link linkend="entity_statistics">статистики сущностей</link>.
                </para>
                  <para>На рисунке далее показан вид фильтра со значением атрибута <code>useMaxResults=&quot;true&quot;</code>, запретом специфического разрешения <code>cuba.gui.filter.maxResults</code> и параметром <code>DefaultFetchUI=2</code></para>
                  <mediaobject>
                    <imageobject>
                      <imagedata align="center" fileref="img/gui_filter_useMaxRezult.png"/>
                    </imageobject>
                  </mediaobject>
                </listitem>
                <listitem>
                  <para id="gui_attr_filter_folderActionsEnabled"><sgmltag>folderActionsEnabled</sgmltag> − при указании значения <literal>false</literal> позволяет скрыть следующие действия с фильтром: <guilabel>Сохранить как папку поиска</guilabel>, <guilabel>Сохранить как папку приложения</guilabel>. По умолчанию значение атрибута равно <literal>true</literal>, действия <guilabel>Сохранить как папку поиска</guilabel>, <guilabel>Сохранить как папку приложения</guilabel> доступны.</para>
                </listitem>
                <listitem>
                  <para id="gui_attr_filter_applyTo"><sgmltag>applyTo</sgmltag> − необязательный атрибут, содержит идентификатор компонента, с которым связан фильтр. Используется в случае, когда необходимо иметь доступ к <link linkend="gui_Table_presentations">представлениям</link> связанного компонента-таблицы. Например, сохраняя фильтр как <link linkend="search_folder">папку поиска</link> или как <link linkend="application_folder">папку приложения</link>, можно указать, какое представление будет применятся при просмотре этой папки.</para>
                  <mediaobject>
                    <imageobject>
                      <imagedata align="center" fileref="img/gui_filter_apply_to.png"/>
                    </imageobject>
                  </mediaobject>
                </listitem>
              </itemizedlist></para>
            <para>Все атрибуты <sgmltag>filter</sgmltag>:</para>
            <informaltable frame="none" pgwide="0" align="left">
              <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                  <row><entry align="left">
                      <link linkend="gui_attr_filter_applyTo">applyTo</link>
                    </entry><entry>
                      <link linkend="gui_attr_basic_enable">enable</link>
                    </entry><entry align="left">
                      <link linkend="gui_attr_filter_manualApplyRequired">manualApplyRequired</link>
                    </entry><entry>
                      <link linkend="gui_attr_basic_stylename">stylename</link>
                    </entry>editable</row>
                  <row>
                    <entry>
                      <link linkend="gui_attr_basic_datasource">datasource</link>
                    </entry>
                    <entry align="left">
                      <link linkend="gui_attr_filter_folderActionsEnabled">folderActionsEnabled</link>
                    </entry>
                    <entry align="left">
                      <link linkend="gui_attr_basic_margin">margin</link>
                    </entry>
                    <entry>
                      <link linkend="gui_attr_filter_useMaxResults">useMaxResults</link>
                    </entry>
                  </row>
                  <row>
                    <entry align="left">
                      <link linkend="gui_attr_filter_editable">editable</link>
                    </entry>
                    <entry align="left">
                      <link linkend="gui_attr_basic_id">id</link>
                    </entry>
                    <entry>
                      <link linkend="gui_attr_filter_required">required</link>
                    </entry>
                    <entry>
                      <link linkend="gui_attr_basic_visible">visible</link>
                    </entry>
                  </row>
                </tbody></tgroup>
            </informaltable>
            <para>Элементы <sgmltag>filter</sgmltag>:</para>
            <informaltable frame="none" pgwide="0" align="left">
              <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                  <row><entry align="left">
                      <link linkend="gui_element_filter_custom">custom</link>
                    </entry>editable</row>
                  <row>
                    <entry>
                      <link linkend="gui_element_filter_properties">properties</link>
                    </entry>
                  </row>
                  <row>
                    <entry>
                      <link linkend="gui_element_filter_property">property</link>
                    </entry>
                  </row>
                </tbody></tgroup>
            </informaltable>
            <para>Атрибуты элемента <sgmltag>properties</sgmltag>:</para>
            <informaltable frame="none" pgwide="0" align="left">
              <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                  <row><entry align="left">
                      <link linkend="gui_attr_filter_exclude">exclude</link>
                    </entry>editable</row>
                  <row>
                    <entry>
                      <link linkend="gui_attr_filter_include">include</link>
                    </entry>
                  </row>
                </tbody></tgroup>
            </informaltable>
            <para>Атрибуты элемента <sgmltag>property</sgmltag>:</para>
            <informaltable frame="none" pgwide="0" align="left">
              <tgroup cols="2" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                  <row><entry align="left">
                      <link linkend="gui_attr_filter_caption">caption</link>
                    </entry>editable<entry align="left">
                      <link linkend="gui_attr_filter_paramView">paramView</link>
                    </entry></row>
                  <row>
                    <entry>
                      <link linkend="gui_attr_filter_name">name</link>
                    </entry>
                    <entry align="left">
                      <link linkend="gui_attr_filter_paramWhere">paramWhere</link>
                    </entry>
                  </row>
                </tbody></tgroup>
            </informaltable>
            <para>Атрибуты элемента <sgmltag>custom</sgmltag>:</para>
            <informaltable frame="none" pgwide="0" align="left">
              <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                  <row><entry align="left">
                      <link linkend="gui_attr_filter_custom_caption">caption</link>
                    </entry>editable<entry align="left">
                      <link linkend="gui_attr_filter_custom_name">name</link>
                    </entry><entry align="left">
                      <link linkend="gui_attr_filter_paramWhere">paramWhere</link>
                    </entry></row>
                  <row>
                    <entry>
                      <link linkend="gui_attr_filter_custom_inExpr">inExpr</link>
                    </entry>
                    <entry>
                      <link linkend="gui_attr_filter_custom_paramClass">paramClass</link>
                    </entry>
                  </row>
                  <row>
                    <entry align="left">
                      <link linkend="gui_attr_filter_custom_join">join</link>
                    </entry>
                    <entry align="left">
                      <link linkend="gui_attr_filter_paramView">paramView</link>
                    </entry>
                  </row>
                </tbody></tgroup>
            </informaltable>
          </section>
          <section>
            <title>Права пользователей</title>
            <itemizedlist>
              <listitem>
                <para>Для создания/изменения/удаления глобальных (доступных всем пользователям) фильтров пользователь должен иметь разрешение <property>cuba.gui.filter.global</property>.</para>
              </listitem>
              <listitem>
                <para>Для создания/изменения<code> custom</code> условий пользователь должен иметь разрешение <property>cuba.gui.filter.customConditions</property>.</para>
              </listitem>
              <listitem>
                <para>Чтобы иметь возможность изменять максимальное количество строк на странице таблицы с помощью флажка и поля  <guilabel>Show first N rows</guilabel> пользователь должен иметь разрешение <property>cuba.gui.filter.maxResults</property>. См. также атрибут фильтра <link linkend="gui_attr_filter_useMaxResults">useMaxResults</link>.</para>
              </listitem>
            </itemizedlist>
            <para>Информация о том, как настраивать  специфические разрешения, приведена в руководстве <productname>Подсистема безопасности</productname>.</para>
          </section>
          <section>
            <title>Внешние параметры для управления фильтрами</title>
            <para><emphasis role="bold">Общесистемные параметры</emphasis></para>
            <para>Следующие свойства приложения влияют на поведение фильтров:</para>
            <itemizedlist>
              <listitem>
                <para><link linkend="cuba.gui.genericFilterManualApplyRequired">cuba.gui.genericFilterManualApplyRequired</link>  − позволяет отключить автоматическое применение фильтра (то есть загрузку данных) сразу при открытии экрана.</para>
              </listitem>
              <listitem>
                <para><link linkend="cuba.gui.genericFilterChecking">cuba.gui.genericFilterChecking</link> − позволяет отключить проверку заполненности хотя-бы одного условия перед применением фильтра.</para>
              </listitem>
              <listitem>
                <para><link linkend="cuba.gui.genericFilterTreeConditionSelect">cuba.gui.genericFilterTreeConditionSelect</link> − позволяет вместо древовидной структуры выбора условий,  описанной выше, использовать плоский выпадающий список.</para>
              </listitem>
              <listitem>
                <para><link linkend="cuba.allowQueryFromSelected">cuba.allowQueryFromSelected</link> позволяет отключить механизм  <link linkend="sequential_filter_para">последовательного наложения фильтров</link>.</para>
              </listitem>
            </itemizedlist>
            <para><emphasis role="bold">Параметры вызова экрана</emphasis></para>
            <para>При вызове экрана можно указать, какой фильтр и с какими параметрами должен быть применен сразу после открытия экрана. Для этого фильтр должен быть заранее создан, сохранен в базе данных,  и соответствующая запись в таблице <database>SEC_FILTER</database> должна иметь заполненное поле <database>CODE</database>.</para>
            <para>Для указания кода фильтра в экран следует передать параметр с именем, равным идентификатору компонента фильтра в данном экране. Значением параметра должен быть код фильтра, который нужно установить и применить.</para>
            <para>Для установки значений параметров фильтра в экран нужно передать параметры с именами, равными именам параметров, и значения в виде строк.</para>
            <para>Пример описателя пункта главного меню, устанавливающего в открываемом экране <code>sample$Car.browse</code> в компоненте <code>carsFilter</code> фильтр с кодом <userinput>FilterByVIN</userinput>, с подстановкой в параметр условия <code>component$carsFilter.vin79216</code> значения <userinput>TMA</userinput>:<programlisting language="xml">&lt;item id=&quot;sample$Car.browse&quot;&gt;
    &lt;param name=&quot;carsFilter&quot; value=&quot;FilterByVIN&quot;/&gt;
    &lt;param name=&quot;component$carsFilter.vin79216&quot; value=&quot;TMA&quot;/&gt;
&lt;/item&gt;</programlisting></para>
            <para>Следует отметить, что фильтр с установленным полем <database>CODE</database> обладает особыми свойствами:</para>
            <itemizedlist>
              <listitem>
                <para>Его не могут редактировать пользователи.</para>
              </listitem>
              <listitem>
                <para>Название такого фильтра можно отображать на нескольких языках. Для этого в <link linkend="main_message_pack">главном пакете сообщений</link> приложения должна быть строка с ключом, равным коду фильтра.</para>
              </listitem>
            </itemizedlist>
          </section>
          <section>
            <title>Последовательное наложение фильтров</title>
            <para id="sequential_filter_para"><emphasis role="bold">Последовательное наложение фильтров</emphasis></para>
            <para>При включенном свойстве приложения <link linkend="cuba.allowQueryFromSelected">cuba.allowQueryFromSelected</link> в пользовательском интерфейсе компонента можно закреплять последний примененный фильтр и текущие результаты фильтрации. После этого можно выбрать другой фильтр или параметры и применить их на уже выбранных записях.</para>
            <para>Данный подход позволяет решить две проблемы:</para>
            <itemizedlist>
              <listitem>
                <para>Декомпозировать сложные фильтры.</para>
              </listitem>
              <listitem>
                <para>Применять фильтры на записи, отобранные с помощью папок <link linkend="application_folder">приложения</link> или <link linkend="search_folder">поиска</link>.</para>
              </listitem>
            </itemizedlist>
            <para>Чтобы применить этот механизм в пользовательском интерфейсе, выберите и примените один из фильтров. Затем нажмите на кнопку <inlinemediaobject>
                <imageobject>
                  <imagedata fileref="img/gui_filter_add.png"/>
                </imageobject>
              </inlinemediaobject>. Фильтр закрепится в нижней части панели фильтра. Далее можно применить к выбранным записям другой фильтр. Так последовательно можно накладывать друг на друга любое количество фильтров. Также фильтры можно удалять последовательно с помощью кнопки <inlinemediaobject>
                <imageobject>
                  <imagedata fileref="img/gui_filter_remove.png"/>
                </imageobject>
              </inlinemediaobject></para>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_filter_sequential.png"/>
              </imageobject>
            </mediaobject>
            <para>Механизм последовательного наложения фильтров основан на возможности <link linkend="dataService">DataWorker</link> выполнять <link linkend="query_from_selected">последовательные запросы</link>.</para>
            <warning>
              <para>На момент написания данного руководства механизм последовательного наложения фильтров реализован только для блока <structname>Web Client</structname>.</para>
            </warning>
          </section>
        </section>
        <section id="gui_GroupTable">
          <title>GroupTable</title>
          <para>Компонент <code>GroupTable</code> - это таблица с возможностью динамической группировки по любому полю. Для того чтобы сгруппировать таблицу по какой-либо колонке, нужно в заголовке таблицы перетащить эту колонку в позицию слева от элемента <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupTableIcon.png"/>
              </imageobject>
            </inlinemediaobject>. Сгруппированные значения можно разворачивать и сворачивать с помощью кнопок <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupBox_plus.png"/>
              </imageobject>
            </inlinemediaobject>/<inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/gui_groupBox_minus.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_groupTableDragColumn.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>groupTable</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_GroupTable_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован только для блока <structname>Web Client</structname>. В <structname>Desktop Client</structname> ведет себя как обычная таблица.</para>
          <para>Для    <code>GroupTable</code> в атрибуте <code>datasource</code> элемента <code>rows</code> должен быть указан <link linkend="datasources">groupDatasource</link>. В противном случае группировка работать не будет.</para>
          <para>Пример использования:<programlisting language="xml">&lt;dsContext&gt;
   &lt;groupDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot;
                    view=&quot;orderWithCustomer&quot;&gt;
       &lt;query&gt;
           select o from sales$Order o order by o.date
       &lt;/query&gt;
   &lt;/groupDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;groupTable id=&quot;ordersTable&quot; width=&quot;100%&quot;&gt;
        &lt;columns&gt;
            &lt;group&gt;
                &lt;column id=&quot;date&quot;/&gt;
            &lt;/group&gt;
            &lt;column id=&quot;customer.name&quot;/&gt;
            &lt;column id=&quot;amount&quot;/&gt;
        &lt;/columns&gt;
        &lt;rows datasource=&quot;ordersDs&quot;/&gt;
    &lt;/groupTable&gt;</programlisting></para>
          <para id="gui_element_groupTable_group"><sgmltag>group</sgmltag> − необязательный элемент, может в единственном экземпляре находиться внутри <link linkend="gui_element_table_columns">columns</link>. Содержит набор элементов <code>column</code>, по которым будет выполняться первоначальная группировка при открытии экрана.</para>
          <para>При включенном атрибуте <code>aggregatable</code> таблица отображает результаты агрегации по всем строкам в дополнительной строке вверху, а также результаты агрегации по группам. Отображение агрегации по всем строкам можно отключить, установив <code>false</code> в атрибуте <code>showTotalAggregation</code>.</para>
          <para>В остальном функциональность <code>GroupTable</code> аналогична простой таблице <link linkend="gui_Table">Table</link>.</para>
          <para>Атрибуты <sgmltag>groupTable</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_table_allowPopupMenu">allowPopupMenu</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry><entry>
                    <link linkend="gui_attr_table_reorderingAllowed">reorderingAllowed</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="gui_attr_table_columnControlVisible">columnControlVisible</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_sortable">sortable</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_multiselect">multiselect</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_presentations">presentations</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>groupTable</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_table_actions">actions</link>
                  </entry>
                </row>
                <row>buttonsPanel<entry>
                    <link linkend="gui_ButtonsPanel">buttonsPanel</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_element_table_columns">columns</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_table_rows">rows</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_table_rowsCount">rowsCount</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Элементы <sgmltag>columns</sgmltag>:</para>
          <informaltable frame="none" align="left">
            <tgroup cols="1">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_table_columns">column</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_groupTable_group">group</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты  <link linkend="gui_element_table_columns">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_column_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_clickAction">clickAction</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_column_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_collapsed">collapsed</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы  <link linkend="gui_element_table_columns">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_formatter">formatter</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_table_rows">rows</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_Label">
          <title>Label</title>
          <para>Надпись (<code>Label</code>) − текстовый компонент, отображающий  статический текст либо значение атрибута сущности.</para>
          <para>XML-имя компонента: <sgmltag>label</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_label_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>Label</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Пример задания надписи с текстом, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>:<programlisting language="xml">&lt;label value=&quot;msg://orders&quot;/&gt;</programlisting></para>
          <para id="gui_attr_label_value">Атрибут <sgmltag>value</sgmltag> предназначен для задания текста надписи. </para>
          <para>В веб клиенте текст, содержащийся в атрибуте <sgmltag>value</sgmltag>, будет разбит на несколько строк, если по длине он превысит значение атрибута <link linkend="gui_attr_basic_width">width</link>. Поэтому для отображения  многострочной надписи, достаточно указать абсолютное значение атрибута <link linkend="gui_attr_basic_width">width</link>. Если текст надписи слишком длинный, а значение атрибута <link linkend="gui_attr_basic_width">width</link> не определено, то текст будет урезан.<programlisting language="xml">&lt;label 
       value=&quot;Надпись, которая должна быть разбита на несколько строк&quot; 
       width=&quot;200px&quot;/&gt;</programlisting></para>
          <para>Параметры надписи можно задать в контроллере экрана. Для этого необходимо задать компоненту идентификатор, по которому получить ссылку на него в контроллере:<programlisting language="xml">&lt;label id=&quot;dynamicLabel&quot;/&gt;</programlisting><programlisting>@Inject
private Label dynamicLabel;

public void init(Map&lt;String, Object&gt; params) {
    dynamicLabel.setValue(&quot;Some value&quot;);
}</programlisting></para>
          <para>Компонент <code>Label</code> может отображать значение атрибута сущности. Для этого используются атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>. Например:<programlisting language="xml">&lt;dsContext&gt;
   &lt;datasource id=&quot;customerDs&quot; class=&quot;com.sample.sales.entity.Customer&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
...
    &lt;label datasource=&quot;customerDs&quot; property=&quot;name&quot;/&gt;</programlisting></para>
          <para>В данном случае компонент отображает атрибут <code>name</code> сущности <code>Customer</code>, находящейся в источнике данных <code>customerDs</code>.</para>
          <para id="gui_attr_label_htmlEnabled">Атрибут <sgmltag>htmlEnabled</sgmltag> указывает, каким образом будет рассматриваться значение атрибута <link linkend="gui_attr_label_value">value</link>: как <code>html</code>-код, при <code>htmlEnabled=&quot;true&quot;</code>, или как строка. Обратите внимание, что не все <code>html</code>-теги поддерживаются в десктоп-реализации экрана. </para>
          <para>Атрибуты <sgmltag>label</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_label_htmlEnabled">htmlEnabled</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_label_value">value</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>label</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_formatter">formatter</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_Link">
          <title>Link</title>
          <para>Ссылка (<code>Link</code>) − компонент-гиперссылка, позволяющая открывать внешние веб-ресурсы единообразно для веб и десктоп клиента.</para>
          <para>XML-имя компонента: <sgmltag>link</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_link_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Пример XML-описания компонента <code>link</code>: <programlisting language="xml">&lt;link caption=&quot;Link&quot; url=&quot;https://www.cuba-platform.com&quot; target=&quot;_blank&quot;/&gt;</programlisting></para>
          <para>Атрибуты <sgmltag>link</sgmltag>:</para>
          <itemizedlist>
            <listitem>
              <para><code>url</code> - адрес ресурса.</para>
            </listitem>
            <listitem>
              <para><code>target</code> - для веб клиента задает способ открытия страницы, аналогичен атрибуту <code>target</code> HTML-тега <code>&lt;a&gt;</code>.</para>
            </listitem>
          </itemizedlist>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_LinkButton">
          <title>LinkButton</title>
          <para>Кнопка-ссылка (<code>LinkButton</code>) − кнопка, выглядящая как гиперссылка.</para>
          <para>XML-имя компонента: <sgmltag>linkButton</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_linkButton_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент кнопки-ссылки реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Кнопка-ссылка  может содержать  текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="130" contentdepth="127" align="center" fileref="img/gui_linkButtonTypes.png"/>
            </imageobject>
          </mediaobject>
          <para>Кнопка-ссылка отличается от обычной кнопки <code>Button</code> только своим внешним видом. Все свойства и поведение идентичны <link linkend="gui_Button">описанным для Button</link>.</para>
          <para>Пример XML-описания кнопки-ссылки, вызывающей метод <code>someMethod()</code> контроллера,  с надписью (атрибут <link linkend="gui_attr_basic_caption">caption</link>),  всплывающей подсказкой (атрибут <link linkend="gui_attr_basic_description">description</link>) и  пиктограммой (атрибут <link linkend="gui_attr_basic_icon">icon</link>): <programlisting language="xml">&lt;linkButton id=&quot;linkButton&quot; 
            caption=&quot;msg://linkButton&quot; 
            description=&quot;Press me&quot; 
            icon=&quot;icons/save.png&quot; 
            invoke=&quot;someMethod&quot;/&gt;</programlisting></para>
          <para>Атрибуты <sgmltag>linkButton</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_button_action">action</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_button_invoke">invoke</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_LookupField">
          <title>LookupField</title>
          <para>Компонент для выбора значения из выпадающего списка. Выпадающий список реализует фильтрацию значений по мере ввода пользователя и постраничный вывод доступных значений.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_lookupField.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>lookupField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_LookupField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент LookupField реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Простейший вариант использования <code>LookupField</code> - выбор значения перечисления (<code>enum</code>) для атрибута сущности. Например, сущность <code>Role</code> имеет атрибут <code>type</code> типа <code>RoleType</code>, который является перечислением. Тогда для редактирования этого атрибута можно использовать <code>LookupField</code> следующим образом:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;roleDs&quot; class=&quot;com.haulmont.cuba.security.entity.Role&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;lookupField datasource=&quot;roleDs&quot; property=&quot;type&quot;/&gt;</programlisting></para>
              <para>Как видно из примера, в экране описывается <link linkend="datasources">источник данных</link> <literal>roleDs</literal> для сущности <code>Role</code>. В компоненте <code>lookupField</code>  в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название атрибута сущности, значение которого должно быть отображено. В данном случае атрибут является перечислением, и в выпадающем списке будут отображены <link linkend="enum_localization">локализованные названия</link> всех значений этого перечисления.</para>
            </listitem>
            <listitem>
              <para>Аналогично можно использовать <code>LookupField</code> для выбора экземпляра связанной сущности. Для формирования списка опций используется атрибут <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; class=&quot;com.company.sample.entity.Car&quot; view=&quot;_local&quot;/&gt;
    &lt;collectionDatasource id=&quot;coloursDs&quot; class=&quot;com.company.sample.entity.Colour&quot; view=&quot;_local&quot;&gt;
        &lt;query&gt;select c from sample$Colour c&lt;/query&gt;
    &lt;/collectionDatasource&gt;    
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;lookupField datasource=&quot;carDs&quot; property=&quot;colour&quot; optionsDatasource=&quot;coloursDs&quot;/&gt;</programlisting></para>
              <para>В данном случае компонент отобразит отобразит <link linkend="namePattern">имена экземпляров</link> сущности <code>Colour</code>, находящихся в источнике данных <code>colorsDs</code>, а выбранное значение подставится в атрибут <code>colour</code> сущности <code>Car</code>, находящейся в источнике данных <code>carDs</code>.</para>
              <para>С помощью атрибута <link linkend="gui_attr_basic_captionProperty">captionProperty</link> можно указать, какой атрибут сущности использовать вместо имени экземпляра для строковых названий опций. </para>
            </listitem>
            <listitem>
              <para>Список опций компонента может быть задан произвольно с помощью методов <code>setOptionsList()</code> и <code>setOptionsMap()</code>, либо с помощью XML-атрибута <code>optionsDatasource</code>.</para>
              <itemizedlist>
                <listitem>
                  <para>Метод <code>setOptionsList()</code> позволяет программно задать список опций компонента. Для этого объявляем компонент в XML-дескрипторе:</para>
                  <programlisting language="xml">&lt;lookupField id=&quot;numberOfSeatsField&quot; datasource=&quot;modelDs&quot; property=&quot;numberOfSeats&quot;/&gt;</programlisting>
                  <para>Затем инжектируем компонент в контроллер и в методе <code>init()</code> задаем ему список опций:<programlisting>@Inject
protected LookupField numberOfSeatsField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(2);
    list.add(4);
    list.add(5);
    list.add(7);
    numberOfSeatsField.setOptionsList(list);
}</programlisting></para>
                  <para>В выпадающем списке компонента отобразятся числа 2, 4, 5, 7. Выбранное число подставится в атрибут <code>numberOfSeats</code> сущности, находящейся в источнике данных <code>modelDs</code>.</para>
                </listitem>
                <listitem>
                  <para>Метод <code>setOptionsMap()</code> позволяет задать строковые названия и значения опций по отдельности. Например, для описанного в XML-дескрипторе компонента <code>numberOfSeatsField</code> в методе <code>init()</code> контроллера задаем мэп опций:<programlisting language="java">@Inject
protected LookupField numberOfSeatsField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();
    map.put(&quot;two&quot;, 2);
    map.put(&quot;four&quot;, 4);
    map.put(&quot;five&quot;, 5);
    map.put(&quot;seven&quot;, 7);
    numberOfSeatsField.setOptionsMap(map);
}</programlisting></para>
                  <para>В выпадающем списке компонента отобразятся строки <userinput>two</userinput>, <userinput>four</userinput>, <userinput>five</userinput>, <userinput>seven</userinput>. Однако значением компонента будет число, соответствующее выбранной строке. Оно и подставится в атрибут <code>numberOfSeats</code> сущности, находящейся в источнике данных <code>modelDs</code>.</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para id="gui_attr_lookupField_filterMode">С помощью атрибута <sgmltag>filterMode</sgmltag> можно задать тип фильтрации опций при вводе пользователя:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>NO</literal> − нет фильтрации.</para>
                </listitem>
                <listitem>
                  <para><literal>STARTS_WITH</literal> − по началу фразы.</para>
                </listitem>
                <listitem>
                  <para><literal>CONTAINS</literal> − по любому вхождению (используется по умолчанию).</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para>Если у компонента <code>LookupField</code> не установлен атрибут <link linkend="gui_attr_basic_required">required</link>, и если связанный атрибут сущности не объявлен как обязательный, то в списке опций компонента присутствует пустая строка, при выборе которой компонент возвращает значение <code>null</code>. Атрибут <link linkend="gui_attr_nullName">nullName</link> позволяет задать строку, отображаемую в этом случае вместо пустой. Пример использования:<programlisting language="xml">&lt;lookupField datasource=&quot;carDs&quot; property=&quot;colour&quot; optionsDatasource=&quot;coloursDs&quot; nullName=&quot;(none)&quot;/&gt;</programlisting></para>
              <para>В данном случае вместо пустой строки отобразится строка <userinput>(none)</userinput>, при выборе которой в связанный атрибут сущности подставится значение <code>null</code>.</para>
              <para>При программном задании списка опций методом <code>setOptionsList()</code> можно одну из опций передать в метод <code>setNullOption()</code>. Тогда при ее выборе пользователем значением компонента будет <code>null</code>.</para>
            </listitem>
            <listitem>
              <para>Компонент <code>LookupField</code>  способен обрабатывать ввод пользователя при отсутствии подходящей опции в списке. Для этого используются методы <code>setNewOptionAllowed()</code> и <code>setNewOptionHandler()</code>. Например:<programlisting language="java">@Inject
protected LookupField colourField;

@Inject
protected CollectionDatasource&lt;Colour, UUID&gt; coloursDs;

@Override
public void init(Map&lt;String, Object&gt; params) {
    colourField.setNewOptionAllowed(true);
    colourField.setNewOptionHandler(new LookupField.NewOptionHandler() {
        @Override
        public void addNewOption(String caption) {
            Colour colour = new Colour();
            colour.setName(caption);
            coloursDs.addItem(colour);
            colourField.setValue(colour);
        }
    });
}</programlisting></para>
              <para>Обработчик <code>NewOptionHandler</code> вызывается, если пользователь ввел некоторое значение, не совпадающее ни с одной из опций, и нажал <keycap>Enter</keycap>. В данном случае в обработчике создается новый экземпляр сущности <code>Colour</code>, его атрибут <code>name</code> устанавливается в значение, введенное пользователем, этот экземпляр добавляется в источник данных опций и выбирается в компоненте.</para>
              <para id="gui_attr_newOptionHandler">Вместо имплементации интерфейса <code>LookupField.NewOptionHandler</code> для обработки ввода пользователя можно использовать XML-атрибут <code>newOptionHandler</code> с указанным в нем методом контроллера. Данный метод должен иметь два параметра - первый типа <code>LookupField</code>, второй типа <code>String</code>. В них будут переданы соответственно экзампляр компонента и введенное пользователем значение.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>lookupField</sgmltag>: </para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_nullName">nullName</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_newOptionHandler">newOptionHandler</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>lookupField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_LookupPickerField">
          <title>LookupPickerField</title>
          <para>Компонент <code>LookupPickerField</code> позволяет отображать экземпляр сущности в текстовом поле, выбирать экземпляр в выпадающем списке и выполнять действия нажатием на кнопки справа.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_lookupPickerField.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>lookupPickerField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_LookupPickerField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para><code>LookupPickerField</code> является по сути гибридом <link linkend="gui_LookupField">LookupField</link> и <link linkend="gui_PickerField">PickerField</link>, поэтому все описанное для этих интерфейсов верно и для него. Исключением является список действий по умолчанию, добавляемых при определении компонента в XML: для <code>LookupPickerField</code> это действия <code>lookup</code> <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/lookupBtn.png"/>
              </imageobject>
            </inlinemediaobject> и <code>open</code> <inlinemediaobject>
              <imageobject>
                <imagedata fileref="img/openBtn.png"/>
              </imageobject>
            </inlinemediaobject>.</para>
          <para>Пример использования <code>LookupPickerField</code> для выбора значения ссылочного атрибута <code>colour</code> сущности <code>Car</code>:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; class=&quot;com.company.sample.entity.Car&quot; view=&quot;_local&quot;/&gt;
    &lt;collectionDatasource id=&quot;coloursDs&quot; class=&quot;com.company.sample.entity.Colour&quot; view=&quot;_local&quot;&gt;
        &lt;query&gt;select c from sample$Colour c&lt;/query&gt;
    &lt;/collectionDatasource&gt;    
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;lookupPickerField datasource=&quot;carDs&quot; property=&quot;colour&quot; optionsDatasource=&quot;coloursDs&quot;/&gt;</programlisting></para>
          <para>Атрибуты <sgmltag>lookupPickerField</sgmltag>: </para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry>
                    <link linkend="gui_attr_pickerField_metaclass">metaClass</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry>
                    <link linkend="gui_attr_nullName">nullName</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry/>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>lookupPickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_Action">actions</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_MaskedField">
          <title>MaskedField</title>
          <para>Текстовое поле, в которое данные вводятся в определенном формате. <code>MaskedField</code> удобно использовать, например, для ввода телефонных номеров. </para>
          <para>XML-имя компонента: <sgmltag>maskedField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_MaskedField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>MaskedField</code> реализован только для блока <structname>Web Client</structname>.</para>
          <para><code>MaskedField</code> в основном повторяет функциональность <link linkend="gui_TextField">TextField</link>, за исключением того, что ему нельзя установить <code>datatype</code>. То есть <code>MaskedField</code> предназначен для работы только с текстом и строковыми атрибутами сущностей. <code>MaskedField</code> имеет следующие специфические атрибуты:</para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_maskedField_mask"><sgmltag>mask</sgmltag> - задает маску для поля. Чтобы задать маску, используются следующие символы:</para>
              <itemizedlist>
                <listitem>
                  <para><sgmltag>#</sgmltag> - цифра</para>
                </listitem>
                <listitem>
                  <para><sgmltag>U</sgmltag> -  буква верхнего регистра</para>
                </listitem>
                <listitem>
                  <para><sgmltag>L</sgmltag> -  буква нижнего регистра</para>
                </listitem>
                <listitem>
                  <para><sgmltag>?</sgmltag> - буква</para>
                </listitem>
                <listitem>
                  <para><sgmltag>А</sgmltag> - буква или цифра</para>
                </listitem>
                <listitem>
                  <para><sgmltag>*</sgmltag> - любой символ</para>
                </listitem>
                <listitem>
                  <para><sgmltag>H</sgmltag> - hex символ</para>
                </listitem>
                <listitem>
                  <para><sgmltag>~</sgmltag> - знак + или -</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem>
              <para id="gui_attr_maskedField_valueMode"><sgmltag>valueMode</sgmltag> - определяет формат возвращаемого значения (с маской, или без) и может принимать значение <sgmltag>masked</sgmltag> или <sgmltag>clear</sgmltag>.</para>
            </listitem>
          </itemizedlist>
          <para>Пример текстового поля с маской для ввода номеров телефонов: </para>
          <programlisting language="xml">&lt;maskedField id=&quot;phoneNumberField&quot; mask=&quot;(###)###-##-##&quot; valueMode=&quot;masked&quot;/&gt;
&lt;button caption=&quot;msg://showPhoneNumberBtn&quot; invoke=&quot;showPhoneNumber&quot;/&gt;</programlisting>
          <programlisting>@Inject
private MaskedField phoneNumberField;

public void showPhoneNumber(){
    showNotification((String) phoneNumberField.getValue(), NotificationType.HUMANIZED);
}</programlisting>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_MaskedField.png"/>
            </imageobject>
          </mediaobject>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_MaskedField_maskedValueMode.png"/>
            </imageobject>
          </mediaobject>
          <para>Атрибуты <sgmltag>maskedField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="5" colsep="1" rowsep="1" align="left"><colspec colname="c0"/><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_maskedField_mask">mask</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_trim">trim</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_maskedField_valueMode">valueMode</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>maskedField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_OptionsGroup">
          <title>OptionsGroup</title>
          <para>Компонент, который обеспечивает выбор из списка опций, используя группу переключателей для выбора единственного значения или группу флажков для выбора нескольких значений.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_optionsGroup.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>optionsGroup</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_OptionsGroup_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>OptionsGroup</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Простейший вариант использования <code>OptionsGroup</code> - выбор значения перечисления (<code>enum</code>) для атрибута сущности. Например, сущность <code>Role</code> имеет атрибут <code>type</code> типа <code>RoleType</code>, который является перечислением. Тогда для редактирования этого атрибута можно использовать <code>OptionsGroup</code> следующим образом:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;roleDs&quot; class=&quot;com.haulmont.cuba.security.entity.Role&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;optionsGroup datasource=&quot;roleDs&quot; property=&quot;type&quot;/&gt;</programlisting></para>
              <para>Как видно из примера, в экране описывается <link linkend="datasources">источник данных</link> <literal>roleDs</literal> для сущности <code>Role</code>. В компоненте <code>optionsGroup</code>  в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название атрибута сущности, значение которого должно быть отображено.</para>
              <para>В результате компонент примет следующий вид:<mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_optionsGroup_roleType.png"/>
                  </imageobject>
                </mediaobject></para>
            </listitem>
            <listitem>
              <para>Список опций компонента может быть задан произвольно с помощью методов <code>setOptionsList()</code> и <code>setOptionsMap()</code>, либо с помощью XML-атрибута <code>optionsDatasource</code>.</para>
              <itemizedlist>
                <listitem>
                  <para>Метод <code>setOptionsList()</code> позволяет программно задать список опций компонента. Для этого объявляем компонент в XML-дескрипторе:</para>
                  <programlisting language="xml">&lt;optionsGroup id=&quot;numberOfSeatsField&quot;/&gt;</programlisting>
                  <para>Затем инжектируем компонент в контроллер и в методе <code>init()</code> задаем ему список опций:<programlisting language="java">@Inject
protected OptionsGroup numberOfSeatsField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
    list.add(2);
    list.add(4);
    list.add(5);
    list.add(7);
    numberOfSeatsField.setOptionsList(list);
}</programlisting></para>
                  <para>Компонент примет следующий вид:<mediaobject>
                      <imageobject>
                        <imagedata align="center" fileref="img/gui_optionsGroup_integerList.png"/>
                      </imageobject>
                    </mediaobject></para>
                  <para>При этом  метод <code>getValue()</code> компонента в зависимости от выбранной опции будет возвращать  <code>Integer</code> значения 2,4,5,7.</para>
                </listitem>
                <listitem>
                  <para>Метод <code>setOptionsMap()</code> позволяет задать строковые названия и значения опций по отдельности. Например, для описанного в XML-дескрипторе компонента <code>numberOfSeatsField</code> в методе <code>init()</code> контроллера задаем мэп опций:<programlisting language="java">@Inject
protected OptionsGroup numberOfSeatsField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    Map&lt;String, Object&gt; map = new LinkedHashMap&lt;&gt;();
    map.put(&quot;two&quot;, 2);
    map.put(&quot;four&quot;, 4);
    map.put(&quot;five&quot;, 5);
    map.put(&quot;seven&quot;, 7);
    numberOfSeatsField.setOptionsMap(map);
}</programlisting></para>
                  <para>Компонент примет следующий вид:<mediaobject>
                      <imageobject>
                        <imagedata align="center" fileref="img/gui_optionsGroup_integerMap.png"/>
                      </imageobject>
                    </mediaobject></para>
                  <para>При этом  метод <code>getValue()</code> компонента в зависимости от выбранной опции будет возвращать <code>Integer</code> значения 2,4,5,7, а не строки, отображаемые на экране.</para>
                </listitem>
                <listitem>
                  <para>Компонент может брать список опций из источника данных. Для этого используется атрибут <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>. Например:<programlisting language="xml">&lt;dsContext&gt;
    &lt;collectionDatasource id=&quot;coloursDs&quot; class=&quot;com.company.sample.entity.Colour&quot; view=&quot;_local&quot;&gt;
        &lt;query&gt;select c from sample$Colour c&lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;optionsGroup id=&quot;coloursField&quot; optionsDatasource=&quot;coloursDs&quot;/&gt;</programlisting></para>
                  <para>В данном случае компонент <code>coloursField</code> отобразит <link linkend="namePattern">имена экземпляров</link> сущности <code>Colour</code>,  находящихся в источнике данных <code>coloursDs</code>, а его метод <code>getValue()</code> вернет выбранный экземпляр сущности.</para>
                  <para>С помощью атрибута <link linkend="gui_attr_basic_captionProperty">captionProperty</link> можно указать, какой атрибут сущности использовать вместо имени экземпляра для строковых названий опций.</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem id="gui_attr_optionsGroup_multiselect">
              <para>С помощью атрибута <sgmltag>multiselect</sgmltag> можно переключить <code>OptionsGroup</code> в режим множественного выбора. Если <code>multiselect</code> включен, то компонент отображается как группа независимых флажков, а значением компонента является список выбранных опций.</para>
              <para>Например, создадим в XML-дескрипторе экрана компонент:<programlisting language="xml">&lt;optionsGroup id=&quot;roleTypesField&quot; multiselect=&quot;true&quot;/&gt;</programlisting></para>
              <para>И в контроллере зададим для него список опций - значения перечисления <code>RoleType</code>:<programlisting language="java">@Inject
protected OptionsGroup roleTypesField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    roleTypesField.setOptionsList(Arrays.asList(RoleType.values()));
}</programlisting></para>
              <para>Компонент примет следующий вид:<mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_optionsGroup_roleType_multi.png"/>
                  </imageobject>
                </mediaobject></para>
              <para>В данном случае метод <code>getValue()</code> компонента вернет объект типа <code>java.util.List</code>, содержащий значения <code>RoleType.READONLY</code> и <code>RoleType.DENYING</code>.</para>
              <para>Этот пример иллюстрирует также способность компонента <code>OptionsGroup</code> автоматически отображать локализованные значения перечислений, входящих в модель данных приложения.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_optionsGroup_orientation">Атрибут <sgmltag>orientation</sgmltag> задает расположение элементов группы. По умолчанию элементы располагаются по вертикали. Значение <literal>horizontal</literal> задает горизонтальное расположение.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>optionsGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_optionsGroup_orientation">orientation</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_optionsGroup_multiselect">multiselect</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>optionsGroup</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_PasswordField">
          <title>PasswordField</title>
          <para>Текстовое поле, которое вместо символов, введенных пользователем, отображает эхо-символы. </para>
          <para>XML-имя компонента: <code>passwordField</code>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_PasswordField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para><code>PasswordField</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para><code>PasswordField</code> в основном аналогичен компоненту <link linkend="gui_TextField">TextField</link>, за исключением того, что ему нельзя установить <code>datatype</code>. То есть <code>PasswordField</code> предназначен для работы только с текстом и строковыми атрибутами сущностей. </para>
          <para>Пример использования:</para>
          <programlisting language="xml">&lt;passwordField id=&quot;passwordField&quot; caption=&quot;msg://name&quot;/&gt;
&lt;button caption=&quot;msg://buttonsName&quot; invoke=&quot;showPassword&quot;/&gt;</programlisting>
          <programlisting language="java">@Inject
private PasswordField passwordField;

public void showPassword(){
    showNotification((String) passwordField.getValue(), NotificationType.HUMANIZED);
}</programlisting>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_textField_secret.png"/>
            </imageobject>
          </mediaobject>
          <para>Атрибуты <sgmltag>passwordField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/><colspec colname="c5"/>c <tbody>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>editable<entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>passwordField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_PickerField">
          <title>PickerField</title>
          <para>Поле ввода с дополнительными кнопками действий (<code>PickerField</code>) позволяет отображать экземпляр сущности в текстовом поле и выполнять действия нажатием на кнопки справа.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/PickerField.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>pickerField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_pickerField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>PickerField</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Как правило, <code>PickerField</code> используется для работы со ссылочными атрибутами сущностей. При этом компоненту достаточно указать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; class=&quot;com.company.sample.entity.Car&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;pickerField datasource=&quot;carDs&quot; property=&quot;colour&quot;/&gt;</programlisting></para>
              <para>Как видно из примера, в экране описывается <link linkend="datasources">источник данных</link> <code>carDs</code> для некоторой сущности <code>Car</code>, имеющей атрибут <code>colour</code>. В элементе <code>pickerField</code> в атрибуте <code>datasource</code> указывается ссылка на источник данных, а в атрибуте <code>property</code> − название атрибута сущности, значение которого должно быть отображено в компоненте. Атрибут сущности должен являться ссылкой на другую сущность, в приведенном примере это <code>Colour</code>.</para>
            </listitem>
            <listitem id="gui_element_pickerField_actions">
              <para>Для <code>PickerField</code> можно определить произвольное количество <link linkend="gui_Action">действий</link>, отображаемых кнопками справа. Это можно сделать как в XML-дескрипторе с помощью вложенного элемента <code>actions</code>, так и  программно в контроллере методом <code>addAction()</code>. </para>
              <itemizedlist>
                <listitem>
                  <para>Существуют <link linkend="standard_actions">стандартные действия</link>, определенные  перечислением <code>PickerField.ActionType</code>: <code>lookup</code>, <code>clear</code>, <code>open</code>. Они выполняют соответственно выбор связанной сущности, очистку поля и открытие экрана редактирования выбранной связанной сущности. Для стандартных действий в XML не нужно определять никаких атрибутов, кроме идентификатора. Если при объявлении компонента никаких действий в элементе <sgmltag>actions</sgmltag> не задано, загрузчик XML определит для него действия <literal>lookup</literal> и <literal>clear</literal>. Чтобы  добавить к действиям по умолчанию, например, действие <literal>open</literal>, нужно определить элемент <sgmltag>actions</sgmltag> следующим образом:<programlisting language="xml">&lt;pickerField datasource=&quot;carDs&quot; property=&quot;colour&quot;/&gt;
    &lt;actions&gt;
        &lt;action id=&quot;lookup&quot;/&gt;
        &lt;action id=&quot;open&quot;/&gt;
        &lt;action id=&quot;clear&quot;/&gt;
    &lt;/actions&gt;
&lt;/pickerField&gt;</programlisting></para>
                  <para>Элемент <sgmltag>action</sgmltag> не дополняет, а переопределяет набор стандартных действий, поэтому необходимо указывать идентификаторы всех требуемых действий. Компонент примет следующий вид:</para>
                  <mediaobject>
                    <imageobject>
                      <imagedata contentwidth="" align="center" fileref="img/gui_pickerFieldActionsSt.png"/>
                    </imageobject>
                  </mediaobject>
                  <para>Для программного задания стандартных действий служат методы <code>addLookupAction()</code>, <code>addOpenAction()</code> и <code>addClearAction()</code>. Если компонент определен в XML-дескрипторе без вложенного элемента <code>actions</code>, то достаточно добавить недостающие действия:<programlisting language="java">@Inject
protected PickerField colourField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    colourField.addOpenAction();
}    </programlisting></para>
                  <para>Если же компонент создается в контроллере, то никаких действий по умолчанию он не получает, и необходимо добавить все нужные действия явно:<programlisting language="java">@Inject
protected ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
    PickerField colourField = componentsFactory.createComponent(PickerField.NAME);
    colourField.setDatasource(carDs, &quot;colour&quot;);
    colourField.addLookupAction();
    colourField.addOpenAction();
    colourField.addClearAction();
}</programlisting></para>
                  <para>Стандартные действия можно параметризовать. В XML-дескрипторе возможности для этого ограничены: существует только атрибут <code>openType</code>, в котором можно задать режим открытия экрана выбора (для <code>LookupAction</code>) или редактирования (для <code>OpenAction</code>).</para>
                  <para>При программном создании действий можно задать любые свойства объектов <code>PickerField.LookupAction</code>, <code>PickerField.OpenAction</code> и <code>PickerField.ClearAction</code>, возвращаемых методами добавления стандартных действий. Например, так можно задать специфический экран выбора:<programlisting language="java">PickerField.LookupAction lookupAction = customerField.addLookupAction();
lookupAction.setLookupScreen(&quot;customerLookupScreen&quot;);</programlisting></para>
                  <para>Подробнее см. JavaDocs классов <link linkend="standard_actions">стандартных действий</link>.</para>
                </listitem>
                <listitem>
                  <para>Произвольные действия в XML-дескрипторе также определяются во вложенном элементе <code>actions</code>, например:<programlisting language="xml">&lt;pickerField datasource=&quot;carDs&quot; property=&quot;colour&quot;/&gt;
    &lt;actions&gt;
        &lt;action id=&quot;lookup&quot;/&gt;
        &lt;action id=&quot;show&quot; icon=&quot;icons/show.png&quot;
                invoke=&quot;showColour&quot; caption=&quot;&quot;/&gt;
    &lt;/actions&gt;
&lt;/pickerField&gt;</programlisting></para>
                  <para>Программно задать произвольное действие можно следующим образом:<programlisting language="java">@Inject
protected PickerField colourField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    colourField.addAction(new AbstractAction(&quot;show&quot;) {
        @Override
        public void actionPerform(Component component) {
            showColour(colourField.getValue());
        }
        @Override
        public String getCaption() {
            return &quot;&quot;;
        }
        @Override
        public String getIcon() {
            return &quot;icons/show.png&quot;;
        }
    });
}</programlisting></para>
                  <para>Декларативное и программное создание действий подробно описано в  <xref linkend="gui_Action"/>.</para>
                </listitem>
              </itemizedlist>
            </listitem>
            <listitem id="gui_attr_pickerField_metaclass">
              <para>Компонент <code>PickerField</code> можно использовать без непосредственной привязки к данным, то есть без указания <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>. В этом случае для указания типа сущности, с которой должен работать <code>PickerField</code>, используется атрибут <code>metaClass</code>. В нем необходимо указать <link linkend="entity_class_annotations">имя сущности в метаданных</link>, например:<programlisting language="xml">&lt;pickerField id=&quot;colourField&quot; metaClass=&quot;sample$Colour&quot;/&gt;</programlisting></para>
              <para>Экземпляр выбранной сущности можно получить, инжектировав компонент в контроллер и вызвав его метод <code>getValue()</code>.</para>
              <warning>
                <para>Для правильной работы компонента <code>PickerField</code> необходима либо установка атрибута <code>metaClass</code>, либо одновременная установка атрибутов <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>.</para>
              </warning>
            </listitem>
            <listitem>
              <para>В компоненте <code>PickerField</code> можно использовать горячие клавиши: см. <xref linkend="shortcuts"/>.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>pickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_pickerField_metaclass">metaClass</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>pickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_pickerField_actions">actions</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_PopupButton">
          <title>PopupButton</title>
          <para>Кнопка с выпадающим списком действий.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="107" contentdepth="73" align="center" fileref="img/PopupButton.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>popupButton</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_popupButton_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Кнопка с выпадающим списком действий может содержать  текст или пиктограмму (или и то и другое). На рисунке ниже отражены разные виды кнопок.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="154" contentdepth="125" align="center" fileref="img/gui_popupButtonTypes.png"/>
            </imageobject>
          </mediaobject>
          <para>Пример кнопки с выпадающим списком, содержащим два действия: <programlisting language="xml">&lt;popupButton id=&quot;popupButton&quot; caption=&quot;msg://popupButton&quot; description=&quot;Press me&quot;&gt;
   &lt;actions&gt;
      &lt;action id=&quot;popupAction1&quot; caption=&quot;msg://action1&quot; invoke=&quot;someAction1&quot;/&gt;
      &lt;action id=&quot;popupAction2&quot; caption=&quot;msg://action2&quot; invoke=&quot;someAction2&quot;/&gt;
   &lt;/actions&gt;
&lt;/popupButton&gt;</programlisting></para>
          <para>Кнопка имеет надпись, заданную с помощью атрибута <link linkend="gui_attr_basic_caption">caption</link>, и всплывающую подсказку, определенную в атрибуте <link linkend="gui_attr_basic_description">description</link>. Выпадающий список <link linkend="gui_Action">действий</link> задан в элемене <sgmltag>actions</sgmltag>. <code>PopupButton</code> отображает только следующие свойства действий: <code>caption</code>, <code>enable</code>, <code>visible</code>. Свойства <code>description</code>, <code>icon</code>, <code>shortcut</code> игнорируются.</para>
          <para>Атрибуты <sgmltag>popupButton</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>popupButton</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_Action">actions</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_ProgressBar">
          <title>ProgressBar</title>
          <para>Компонент <code>ProgressBar</code> служит для отображения хода выполнения некоторого длительного процесса. </para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_progressBar.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>progressBar</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_progressBar_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Пример использования компонента совместно с механизмом фоновых задач:<programlisting language="xml">&lt;progressBar id=&quot;progressBar&quot; width=&quot;100%&quot;/&gt;</programlisting><programlisting>@Inject
protected ProgressBar progressBar;

@Inject
protected BackgroundWorker backgroundWorker;

private static final int ITERATIONS = 5;

@Override
public void init(Map&lt;String, Object&gt; params) {
    BackgroundTask&lt;Integer, Void&gt; task = new BackgroundTask&lt;Integer, Void&gt;(300, this) {
        @Override
        public Void run(TaskLifeCycle&lt;Integer&gt; taskLifeCycle) throws Exception {
            for (int i = 1; i &lt;= ITERATIONS; i++) {
                TimeUnit.SECONDS.sleep(2); // time consuming task
                taskLifeCycle.publish(i);
            }
            return null;
        }

        @Override
        public void progress(List&lt;Integer&gt; changes) {
            float lastValue = changes.get(changes.size() - 1);
            progressBar.setValue(lastValue / ITERATIONS);
        }
    };

    BackgroundTaskHandler taskHandler = backgroundWorker.handle(task);
    taskHandler.execute();
}</programlisting></para>
          <para>Здесь в методе <code>BackgroundTask.progress()</code>, выполняемом в UI-потоке,  компоненту <code>ProgressBar</code> устанавливается текущее значение. Значением компонента должно быть число типа <code>float</code> от <code>0.0</code> до <code>1.0</code>.</para>
          <para id="gui_attr_progressBar_indeterminate">Если выполняемый процесс не может передавать информацию о прогрессе, то с помощью атрибута <sgmltag>indeterminate</sgmltag> можно задать отображение неопределенного состояния индикатора. Если значение атрибута равно <literal>true</literal>, то индикатор отображает неопределенное состояние. По умолчанию  <literal>false</literal>. Например:<programlisting language="xml">&lt;progressBar id=&quot;progressBar&quot; width=&quot;100%&quot; indeterminate=&quot;true&quot;/&gt;</programlisting></para>
          <para>Атрибуты <sgmltag>progressBar</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_progressBar_indeterminate">indeterminate</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_RelatedEntities">
          <title>Related Entities</title>
          <para><code>Related Entities</code> - компонент в виде кнопки с выпадающим списком, при нажатии показывающим список классов, связанных с сущностью, экземпляры которой отображаются в таблице. Пользователь выбирает интересующий его класс сущности, после чего открывается новый браузер с экземплярами данной сущности, связанными с выбранными экземплярами в начальной таблице.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_relatedEntities.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <code>relatedEntities</code></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_relatedEntities_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>При отборе связанных сущностей для отображения учитываются разрешения пользователя на открытие экранов, чтение сущностей и чтение атрибутов.</para>
          <para>По умолчанию для выбранного в списке класса сущности открывается браузер сущности, определенный по соглашениям (<code>.browse</code>, <code>.lookup</code>). Опционально, экран можно явно задать в компоненте. </para>
          <para>В открытом браузере динамически создается фильтр, который выбирает связанные с выбранными сущностями записи.</para>
          <para>Пример описания компонента в XML-дескрипторе экрана:</para>
          <programlisting language="xml">&lt;table id=&quot;invoiceTable&quot;
       multiselect=&quot;true&quot;
       width=&quot;100%&quot;&gt;
   &lt;actions&gt;
       &lt;action id=&quot;create&quot;/&gt;
       &lt;action id=&quot;edit&quot;/&gt;
       &lt;action id=&quot;remove&quot;/&gt;
   &lt;/actions&gt;
   &lt;buttonsPanel id=&quot;buttonsPanel&quot;&gt;
       &lt;button id=&quot;createBtn&quot;
               action=&quot;invoiceTable.create&quot;/&gt;
       &lt;button id=&quot;editBtn&quot;
               action=&quot;invoiceTable.edit&quot;/&gt;
       &lt;button id=&quot;removeBtn&quot;
               action=&quot;invoiceTable.remove&quot;/&gt;
       &lt;relatedEntities for=&quot;invoiceTable&quot;
                        openType=”NEW_TAB”&gt;
             &lt;property name=&quot;invoiceItems&quot;
                       screen=&quot;sales$InvoiceItem.lookup&quot;
                       filterCaption=&quot;msg://invoiceItems&quot;/&gt;
       &lt;/relatedEntities&gt;
    &lt;/buttonsPanel&gt;</programlisting>
          <para id="gui_attr_related_for_1">Атрибут <code>for</code> является обязательным. В нем указывается идентификатор таблицы.</para>
          <para>Атрибут <code>openType=”NEW_TAB”</code> устанавливает режим открытия браузера (новая вкладка). По умолчанию браузер открывается в текущей вкладке. </para>
          <para id="gui_attr_related_property">Атрибут <code>property</code> позволяет явно задать связанную сущность, которая будет отображаться в выпадающем списке:</para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_related_property_name_1"><code>name</code> - имя атрибута текущей сущности, ссылающегося на связанную сущность</para>
            </listitem>
            <listitem>
              <para id="gui_attr_related_property_screen_1"><code>screen</code> - идентификатор браузера, открывающегося при выборе сущности в списке</para>
            </listitem>
            <listitem>
              <para id="gui_attr_related_property_filterCaption_1"><code>filterCaption</code> - имя динамически формируемого фильтра</para>
            </listitem>
          </itemizedlist>
          <para id="gui_attr_related_exclude_1">Атрибут <code>exclude</code> позволяет исключить определенные связанные сущности из числа отображаемых. В качестве значения указываются ссылочные атрибуты текущей сущности, разделенные запятыми.</para>
          <figure>
            <title>Компонент Related Entities в таблице</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_relatedEntitiesTable.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <figure>
            <title>Браузер связанных сущностей в новой вкладке</title>
            <mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_relatedEntitiesBrowser.png"/>
              </imageobject>
            </mediaobject>
          </figure>
          <para>Все атрибуты <code>relatedEntities</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_related_exclude_1">exclude</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_openType">openType</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_related_for_1">for</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_related_property">property</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <code>property</code>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                </row>
                <row>buttonsPanel<entry>
                    <link linkend="gui_attr_related_property_filterCaption_1">filterCaption</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_related_property_name_1">name</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_related_property_screen_1">screen</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_RichTextArea">
          <title>RichTextArea</title>
          <para>Текстовая область для отображения и ввода форматированного текста.</para>
          <para>XML-имя компонента: <sgmltag>richTextArea</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_RichTextArea_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>RichTextArea</code> реализован только для блока <structname>Web Client</structname>.</para>
          <para><code>RichTextArea</code> в основном повторяет функциональность <code>
              <link linkend="gui_TextField">TextField</link>
            </code>, за исключением того, что ему нельзя установить <code>datatype</code>. То есть <code>RichTextArea</code> предназначен для работы только с текстом и строковыми атрибутами сущностей.</para>
          <para>К тексту, вводимому в компоненте <code>RichTextArea</code>, можно применять средства для форматирования: изменять начертание шрифта, его размер, гарнитуру − с помощью элементов управления, расположенных в верхней части компонента.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="473" align="center" fileref="img/gui_RichTextAreaInfo.png"/>
            </imageobject>
          </mediaobject>
          <para>Атрибуты <sgmltag>richTextArea</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_SearchPickerField">
          <title>SearchPickerField</title>
          <para>Компонент <code>SearchPickerField</code> служит для поиска экземпляров сущностей по вводимой пользователем строке. Пользователю достаточно ввести несколько символов и нажать клавишу <keycap>Enter</keycap>. Если поиск дал  несколько совпадений, найденные значения отображаются  в виде выпадающего списка. Если же критерию поиска соответствует только один экземпляр, он сразу становится значением компонента. <code>SearchPickerField</code> позволяет также выполнять действия нажатием на кнопки справа.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_searchPickerFieldOverlap.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>searchPickerField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_SearchPickerField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Для работы компонента <sgmltag>SearchPickerField</sgmltag> необходимо создать <link linkend="datasources">collectionDatasource</link>, и задать в нем запрос, содержащий условия поиска. Условие обязательно должно содержать параметр с именем <code>custom$searchString</code> - именно в него компонент передает введенную пользователем подстроку при нажатии <keycap>Enter</keycap>. Источник данных с условием поиска должен быть указан в  атрибуте <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link> компонента. Например:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; class=&quot;com.company.sample.entity.Car&quot; view=&quot;_local&quot;/&gt;
    &lt;collectionDatasource id=&quot;coloursDs&quot; class=&quot;com.company.sample.entity.Colour&quot; view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select c from sample$Colour c
            where c.name like :(?i)custom$searchString
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;    
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;searchPickerField datasource=&quot;carDs&quot; property=&quot;colour&quot; optionsDatasource=&quot;coloursDs&quot;/&gt;</programlisting></para>
              <para>В данном случае компонент будет искать экземпляры сущности <code>Colour</code> по вхождению подстроки в ее атрибут <code>name</code>. Префикс <code>(?i)</code> служит для регистро-независимого поиска (см. <xref linkend="datasource_query_case_insensitive"/>). Выбранное значение подставится в атрибут <code>colour</code> сущности <code>Car</code>, находящейся в источнике данных <code>carDs</code>.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_searchPickerField_minSearchStringLength">С помощью атрибута <sgmltag>minSearchStringLength</sgmltag> можно задать минимальное количество символов, которое должен ввести пользователь для поиска значения.</para>
            </listitem>
            <listitem>
              <para>В контроллере экрана для компонента можно реализовать методы, вызываемые в двух случаях:</para>
              <itemizedlist>
                <listitem>
                  <para>если количество введенных символов меньше значения атрибута <code>minSearchStringLength</code>.</para>
                </listitem>
                <listitem>
                  <para>если поиск введенных пользователем символов не дал результатов.</para>
                </listitem>
              </itemizedlist>
              <para>Пример реализации методов для вывода на экран сообщений:<programlisting language="java">@Inject
private SearchPickerField colourField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    colourField.setSearchNotifications(new SearchField.SearchNotifications() {
        @Override
        public void notFoundSuggestions(String filterString) {
            showNotification(&quot;No colours found for search string: &quot; + filterString,
                NotificationType.TRAY);
        }

        @Override
        public void needMinSearchStringLength(String filterString, int minSearchStringLength) {
            showNotification(&quot;Minimum length of search string is &quot; + minSearchStringLength, 
                NotificationType.TRAY);
        }
    });
}</programlisting></para>
            </listitem>
            <listitem>
              <para><code>SearchPickerField</code> реализует интерфейсы <link linkend="gui_LookupField">LookupField</link> и <link linkend="gui_PickerField">PickerField</link>, поэтому все описанное для этих интерфейсов в части работы с сущностями верно и для него. Исключением является список действий по умолчанию, добавляемых при определении компонента в XML: для <code>SearchPickerField</code> это действия <code>lookup</code> <inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="img/lookupBtn.png"/>
                  </imageobject>
                </inlinemediaobject> и <code>open</code> <inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="img/openBtn.png"/>
                  </imageobject>
                </inlinemediaobject>.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>searchPickerField</sgmltag>: </para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_pickerField_metaclass">metaClass</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry>
                    <link linkend="gui_attr_searchPickerField_minSearchStringLength">minSearchStringLength</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_nullName">nullName</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>searchPickerField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_Action">actions</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_Table">
          <title>Table</title>
          <para>Компонент <code>Table</code> позволяет выводить информацию в табличном виде, сортировать данные, управлять колонками и заголовками таблицы, вызывать действия для выбранных строк.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_table.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>table</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_Table_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Пример описания таблицы в XML-дескрипторе экрана:</para>
          <programlisting language="xml">&lt;dsContext&gt;
   &lt;collectionDatasource id=&quot;ordersDs&quot;
                         class=&quot;com.sample.sales.entity.Order&quot;
                         view=&quot;orderWithCustomer&quot;&gt;
       &lt;query&gt;
           select o from sales$Order o order by o.date
       &lt;/query&gt;
   &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;table id=&quot;ordersTable&quot; width=&quot;300px&quot;&gt;
        &lt;columns&gt;
            &lt;column id=&quot;date&quot;/&gt;
            &lt;column id=&quot;customer.name&quot;/&gt;
            &lt;column id=&quot;amount&quot;/&gt;
        &lt;/columns&gt;
        &lt;rows datasource=&quot;ordersDs&quot;/&gt;
    &lt;/table&gt;</programlisting>
          <para>Здесь в элементе <sgmltag>dsContext</sgmltag> определен <link linkend="datasources">источник данных</link> <sgmltag>collectionDatasource</sgmltag>, который выбирает сущности <code>Order</code> с помощью <link linkend="jpql">JPQL</link> запроса

<code>select o from sales$Order o order by o.date</code>. Для компонента <code>table</code> в элементе <code>rows</code> указывается используемый источник данных, а в элементе <code>columns</code> - какие атрибуты сущности, содержащейся в источнике данных, использовать в качестве колонок.</para>
          <para>Элементы <code>table</code>:</para>
          <itemizedlist>
            <listitem id="gui_element_table_rows">
              <para><sgmltag>rows</sgmltag> - обязательный элемент, в атрибуте <code>datasource</code> которого необходимо объявить используемый таблицей <link linkend="datasources">источник данных</link>.</para>
              <para id="gui_attr_table_headerMode">Для строк можно настроить отображение заголовков - задать каждой строке свой значок в дополнительной колонке слева. Для этого в  контроллере экрана необходимо реализовать интерфейс <code>Table.IconProvider</code> и установить его таблице:</para>
              <programlisting language="java">@Inject
protected Table customersTable;

customersTable.setIconProvider(new Table.IconProvider() {
    @Nullable
    @Override
    public String getItemIcon(Entity entity) {
        CustomerGrade grade = ((Customer) entity).getGrade();
        switch (grade) {
            case PREMIUM: return &quot;icons/premium_grade.png&quot;;
            case HIGH: return &quot;icons/high_grade.png&quot;;
            case MEDIUM: return &quot;icons/medium_grade.png&quot;;
            default: return null;
        }
    }
});</programlisting>
            </listitem>
            <listitem id="gui_element_table_columns">
              <para><sgmltag>columns</sgmltag> - обязательный элемент, определяет набор колонок таблицы. </para>
              <para>Каждая колонка описывается во вложенном элементе <code>column</code> со следующими атрибутами:<itemizedlist>
                  <listitem id="gui_attr_table_column_id">
                    <para><sgmltag>id</sgmltag> − обязательный атрибут, содержит название атрибута сущности, выводимого в колонке. Может быть как непосредственным атрибутом сущности, находящейся в источнике данных, так и атрибутом связанной сущности - переход по графу объектов обозначается точкой. Например:<programlisting language="xml">&lt;columns&gt;
    &lt;column id=&quot;date&quot;/&gt;
    &lt;column id=&quot;customer&quot;/&gt;
    &lt;column id=&quot;customer.name&quot;/&gt;
    &lt;column id=&quot;customer.address.country&quot;/&gt;
&lt;/columns&gt;</programlisting></para>
                  </listitem>
                  <listitem id="gui_attr_table_column_caption">
                    <para><sgmltag>caption</sgmltag> − необязательный атрибут, содержит заголовок колонки. Если не задан, будет отображено <link linkend="entity_localization">локализованное название атрибута</link> сущности.</para>
                  </listitem>
                  <listitem id="gui_attr_table_column_collapsed">
                    <para><sgmltag>collapsed</sgmltag> − необязательный атрибут, при указании <code>true</code> колонка будет изначально скрыта. Пользователь может управлять отображением  колонок с помощью меню, доступного по кнопке <inlinemediaobject>
                        <imageobject>
                          <imagedata fileref="img/gui_table_columnControl.png"/>
                        </imageobject>
                      </inlinemediaobject> в правой верхней части таблицы, если атрибут <code>columnControlVisible</code> таблицы не <code>false</code>.   По умолчанию <code>collapsed</code> имеет значение <literal>false</literal>.</para>
                  </listitem>
                  <listitem id="gui_attr_table_column_width">
                    <para><sgmltag>width</sgmltag> − необязательный атрибут, отвечает за изначальную ширину колонки.</para>
                  </listitem>
                  <listitem>
                    <para><code>align</code> - необязательный атрибут, устанавливает выравнивание текста в ячейках данной колонки. Возможные значения: <code>LEFT</code>, <code>RIGHT</code>, <code>CENTER</code>. По умолчанию <code>LEFT</code>.</para>
                  </listitem>
                  <listitem id="gui_attr_table_column_editable">
                    <para><sgmltag>editable</sgmltag> − необязательный атрибут, разрешает/запрещает редактирование данной колонки в редактируемой таблице. Чтобы колонка была редактируемой, атрибут <code>editable</code> всей таблицы (см. ниже) также должен быть установлен в <code>true</code>.</para>
                  </listitem>
                  <listitem id="gui_attr_table_column_maxTextLength">
                    <para><sgmltag>maxTextLength</sgmltag> - необязательный атрибут, позволяет ограничивать количество символов в ячейке. При этом если разница между фактическим и допустимым количеством символов  не превышает порог в 10 символов, &quot;лишние&quot; символы не скрываются. Для просмотра полной  записи надо кликнуть на ее видимую часть. Пример колонки с ограничением в 5 символов:</para>
                    <mediaobject>
                      <imageobject>
                        <imagedata align="center" fileref="img/gui_table_column_maxTextLength.png"/>
                      </imageobject>
                    </mediaobject>
                  </listitem>
                </itemizedlist></para>
              <para>Элемент <code>column</code> может содержать вложенный элемент <link linkend="gui_formatter">formatter</link> для представления значения атрибута в виде, отличном от стандартного для данного <link linkend="datatype">Datatype</link>:<programlisting language="xml">&lt;column id=&quot;date&quot;&gt;
    &lt;formatter class=&quot;com.haulmont.cuba.gui.components.formatters.DateFormatter&quot; format=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
&lt;/column&gt;</programlisting></para>
            </listitem>
            <listitem id="gui_attr_table_rowsCount">
              <para><sgmltag>rowsCount</sgmltag> − необязательный элемент, создающий для таблицы компонент <code>RowsCount</code>, который позволяет загружать в таблицу данные постранично. Размер страницы задается путем ограничения количества записей в источнике данных методом <code>CollectionDatasource.setMaxResults()</code>. Как правило, это делает связанный с источником данных таблицы компонент <link linkend="gui_Filter">Filter</link>, однако при отсутствии универсального фильтра можно вызвать этот метод и напрямую из контроллера экрана.</para>
              <para>Компонент <code>RowsCount</code> может также отобразить общее число записей, возвращаемых текущим запросом в источнике данных, без извлечения этих записей. Для этого при щелчке пользователя на знаке &quot;?&quot; он вызывает метод <code>AbstractCollectionDatasource.getCount()</code>, что приводит к выполнению в БД запроса с такими же, как у текущего запроса условиями, но с агрегатной функцией <code>COUNT(*)</code> вместо результатов. Полученное число отображается вместо знака &quot;?&quot;.</para>
            </listitem>
            <listitem>
              <para id="gui_element_table_actions"><sgmltag>actions</sgmltag> − необязательный элемент для описания <link linkend="gui_Action">действий</link>, связанных с таблицей. Кроме описания произвольных действия поддерживаются следующие <link linkend="standard_actions"> стандартные действия</link>, определяемые перечислением <code>ListActionType</code>: <code>create</code>, <code>edit</code>, <code>remove</code>, <code>refresh</code>, <code>add</code>, <code>exclude</code>, <code>excel</code>.</para>
            </listitem>
            <listitem>
              <para><code>buttonsPanel</code> - необязательный элемент, создающий над таблицей контейнер <link linkend="gui_ButtonsPanel">ButtonsPanel</link> для отображения кнопок действий.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <code>table</code>:</para>
          <itemizedlist>
            <listitem id="gui_attr_table_multiselect">
              <para>Атрибут <code>multiselect</code> позволяет задать режим множественного выделения строк в таблице. Если <code>multiselect</code> равен <code>true</code>, то пользователь может выделить несколько строк с помощью клавиатуры или мыши, удерживая клавиши <keycap>Ctrl</keycap> или <keycap>Shift</keycap>.  По умолчанию режим множественного выделения отключен.</para>
            </listitem>
            <listitem id="gui_attr_table_sortable">
              <para>Атрибут <sgmltag>sortable</sgmltag> разрешает или запрещает сортировку в таблице. По умолчанию имеет значение <literal>true</literal>. Если сортировка разрешена, то при нажатии на название колонки справа от названия появляется значок <inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="img/gui_sortable_down.png"/>
                  </imageobject>
                </inlinemediaobject>/<inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="img/gui_sortable_up.png"/>
                  </imageobject>
                </inlinemediaobject>.</para>
              <para>При включенной с помощью элемента <code>rowsCount</code> (см. выше) страничной загрузке таблицы сортировка производится разными способами в зависимости от того, умещаются ли все записи на одной странице. Если умещаются, то сортировка производится  в памяти, без обращений к БД. Если же страниц больше одной, то сортировка производится на базе данных путем отправки нового запроса с соответствующим <code>ORDER BY</code>. Для правильной работы сортировки на базе данных необходимо, чтобы колонка таблицы ссылалась на какой-либо локальный атрибут сущности, а не на связанную сущность целиком. То есть если в таблице отображаются экземпляры <code>Order</code>, и необходимо вывести колонку с названием связанного <code>Customer</code>, то лучше объявить колонку для атрибута <code>customer.name</code> (как сделано в примере выше), а не просто <code>customer</code>. Последний вариант также будет отображать название покупателя, если в <link linkend="namePattern">имени экземпляра</link> <code>Customer</code> указан атрибут <code>name</code>, но сортировка по такой колонке не будет работать, если записи <code>Order</code> не умещаются на одной странице.</para>
            </listitem>
            <listitem id="gui_attr_table_presentations">
              <para>Атрибут <sgmltag>presentations</sgmltag> управляет механизмом <link linkend="gui_Table_presentations">представлений</link>. Значение по умолчанию равно <literal>false</literal>. Когда значение атрибута равно <literal>true</literal>, то в верхнем правом углу таблицы появляется значок <inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="img/gui_presentation.png"/>
                  </imageobject>
                </inlinemediaobject>. Механизм представлений реализован только для блока <structname>Web Client</structname>.</para>
            </listitem>
            <listitem id="gui_attr_table_columnControlVisible">
              <para>Установка атрибута <sgmltag>columnControlVisible</sgmltag> в <code>false</code> запрещает пользователю скрывать колонки с помощью меню, выпадающего при нажатия на кнопку <inlinemediaobject>
                  <imageobject>
                    <imagedata fileref="img/gui_table_columnControl.png"/>
                  </imageobject>
                </inlinemediaobject>  в правой части шапки таблицы. Флажками в меню отмечаются отображаемые в данный момент  колонки.</para>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_table_columnControl_all.png"/>
                </imageobject>
              </mediaobject>
            </listitem>
            <listitem>
              <para id="gui_attr_table_reorderingAllowed">Установка атрибута <sgmltag>reorderingAllowed</sgmltag> в <code>false</code> запрещает пользователю менять местами колонки, перетаскивая их с помощью мыши. </para>
            </listitem>
            <listitem>
              <para id="gui_attr_table_allowPopupMenu">Атрибут <sgmltag>contextMenuEnabled</sgmltag> разрешает или запрещает показывать контекстное меню. По умолчанию атрибут имеет значение <code>true</code>. В контекстном меню отображаются действия таблицы (если они есть), и пункт <guimenu>Системная информация</guimenu>, содержащий информацию о выбранной сущности (если у пользователя есть разрешение <code>cuba.gui.showInfo</code>, см. руководство по подсистеме безопасности).</para>
            </listitem>
            <listitem>
              <para>Если атрибуту <sgmltag>multiLineCells</sgmltag> таблицы присвоить значение <code>true</code>, то ячейки, содержащие текст с переносами строк, будут отображать его  в несколько строк. В таком режиме в веб клиенте для правильной работы полосы прокрутки все строки текущей страницы таблицы будут загружены веб-браузером сразу, без ленивой загрузки видимой части таблицы. По умолчанию атрибут имеет значение <code>false</code>.</para>
            </listitem>
            <listitem>
              <para>Атрибут <code>aggregatable</code> включает режим агрегации строк таблицы.  Поддерживаются следующие операции:<itemizedlist>
                  <listitem>
                    <para><code>SUM</code> - сумма</para>
                  </listitem>
                  <listitem>
                    <para><code>AVG</code> - среднее значение</para>
                  </listitem>
                  <listitem>
                    <para><code>COUNT</code> - количество</para>
                  </listitem>
                  <listitem>
                    <para><code>MIN</code> - минимальное значение</para>
                  </listitem>
                  <listitem>
                    <para><code>MAX</code> - максимальное значение</para>
                  </listitem>
                </itemizedlist></para>
              <para>Для агрегируемых колонок необходимо указать элемент <code>aggregation</code> с атрибутом <code>type</code>, задающим функцию агрегации. Агрегированные значения столбцов выводятся в дополнительной строке вверху таблицы. Пример описания таблицы с агрегацией:<programlisting language="xml">&lt;table id=&quot;itemsTable&quot; 
       aggregatable=&quot;true&quot;&gt;
    &lt;columns&gt;
        &lt;column id=&quot;product&quot;/&gt;
        &lt;column id=&quot;quantity&quot;/&gt;
        &lt;column id=&quot;amount&quot;&gt;
            &lt;aggregation type=&quot;SUM&quot;/&gt;
        &lt;/column&gt;
    &lt;/columns&gt;
    &lt;rows datasource=&quot;itemsDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
              <para>Для отображения агрегированного значения в виде, отличном от стандартного для данного <link linkend="datatype">Datatype</link>, для него  можно указать <link linkend="gui_formatter">Formatter</link>:<programlisting language="xml" lang="">&lt;column id=&quot;amount&quot;&gt;
    &lt;aggregation type=&quot;SUM&quot;&gt;
        &lt;formatter class=&quot;com.haulmont.sample.MyFormatter&quot;/&gt;
    &lt;/aggregation&gt;
&lt;/column&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Атрибут <code>editable</code> позволяет перевести таблицу в режим in-place редактирования ячеек. В этом режиме в колонках, имеющих атрибут <code>editable = true</code>, отображаются компоненты для редактирования значений атрибутов сущности, находящейся в источнике данных.</para>
              <para>Тип компонента для каждой редактируемой колонки выбирается автоматически на основании типа атрибута сущности. Например, для строковых и числовых атрибутов используется <link linkend="gui_TextField">TextField</link>, для <code>Date</code> - <link linkend="gui_DateField">DateField</link>, для перечислений - <link linkend="gui_LookupField">LookupField</link>, для ссылок на другие сущности - <link linkend="gui_PickerField">PickerField</link>. </para>
              <para>Для редактируемой колонки типа <code>Date</code> можно дополнительно указать атрибуты <code>dateFormat</code> или <code>resolution</code> аналогично описанным для <link linkend="gui_DateField">DateField</link>.</para>
              <para>Для редактируемой колонки, отображающей связанную сущность, можно дополнительно указать атрибуты <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link> и <link linkend="gui_attr_basic_captionProperty">captionProperty</link>. При указании <code>optionsDatasource</code> вместо <link linkend="gui_PickerField">PickerField</link> используется компонент <link linkend="gui_LookupField">LookupField</link>.</para>
              <para>Произвольно настроить отображение ячеек, в том числе для редактирования содержимого, можно с помощью метода <code>Table.addGeneratedColumn()</code>  - см. ниже.</para>
            </listitem>
          </itemizedlist>
          <para>Методы интерфейса <code>Table</code>:</para>
          <itemizedlist>
            <listitem>
              <para><code>getSelected()</code>, <code>getSingleSelected()</code> - возвращают экземпляры сущностей, соответствующие выделенным в таблице строкам. Коллекцию можно получить вызовом метода <code>getSelected()</code>.  Если ничего не выбрано, возвращается пустой набор. Если <code>multiselect</code> отключен, удобно пользоваться методом <code>getSingleSelected()</code>, возвращающим одну выбранную сущность или <code>null</code>, если ничего не выбрано.</para>
            </listitem>
            <listitem>
              <para>Метод <code>addGeneratedColumn()</code> позволяет задать собственное представление данных в колонке. Он принимает два параметра: идентификатор колонки и реализацию интерфейса <code>Table.ColumnGenerator</code>.  Идентификатор может совпадать с одним из идентификаторов, указанных для колонок таблицы в XML-дескрипторе - в этом случае новая колонка вставляется вместо заданной в XML. Если идентификатор не совпадает ни с одной колонкой, создается новая справа.</para>
              <para>Метод <code>generateCell()</code> интерфейса <code>Table.ColumnGenerator</code> вызывается таблицей для каждой строки, и в него передается экземпляр сущности, отображаемой в данной строке. Метод <code>generateCell()</code> должен вернуть визуальный компонент, который и будет отображаться в ячейке.  </para>
              <para>Пример использования:<programlisting language="java">@Inject
protected Table carsTable;

@Inject
protected ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
    carsTable.addGeneratedColumn(&quot;colour&quot;, new Table.ColumnGenerator() {
        @Override
        public Component generateCell(Entity entity) {
            LookupPickerField field = componentsFactory.createComponent(LookupPickerField.NAME);
            field.setDatasource(carsTable.getItemDatasource(entity), &quot;colour&quot;);
            field.setOptionsDatasource(coloursDs);
            field.addLookupAction();
            field.addOpenAction();
            return field;
        }
    });
}</programlisting></para>
              <para>В данном случае в ячейках колонки <code>colour</code> таблицы отображается компонент <link linkend="gui_LookupPickerField">LookupPickerField</link>. Компонент должен сохранять свое значение в атрибут <code>colour</code> сущности, экземпляр которой отображается в данной строке. Для этого у таблицы методом <code>getItemDatasource()</code> запрашивается источник данных для текущего экземпляра сущности, и передается компоненту <code>LookupPickerField</code>.</para>
              <para>Если в метод <code>addGeneratedColumn()</code> передан идентификатор колонки, не объявленной в XML-дескрипторе, то может понадобиться установить заголовок новой колонки следующим образом:<programlisting language="java">carsTable.getColumn(&quot;colour&quot;).setCaption(&quot;Colour&quot;);</programlisting></para>
            </listitem>
            <listitem>
              <para>Метод <code>setStyleProvider()</code> позволяет задать стиль отображения ячеек таблицы. Параметром метода должна быть реализация интерфейса <code>Table.StyleProvider</code>. Метод <code>getStyleName()</code> этого интерфейса вызывается таблицей отдельно для каждой строки и для каждой ячейки. Если метод вызван для строки, то первый параметр содержит экземпляр сущности, отображаемый этой строкой, а второй параметр <code>null</code>. Если же метод вызван для ячейки, то второй параметр содержит имя атрибута, отображаемого этой ячейкой.</para>
              <para>Пример задания стилей:<programlisting language="java">@Inject
protected Table customersTable;

@Override
public void init(Map&lt;String, Object&gt; params) {
    customersTable.setStyleProvider(new Table.StyleProvider() {
        @Nullable
        @Override
        public String getStyleName(Entity entity, @Nullable String property) {
            Customer customer = (Customer) entity;
            if (property == null) {
                // style for row
                if (hasComplaints(customer))
                    return &quot;unsatisfied-customer&quot;;
            } else if (property.equals(&quot;grade&quot;)) {
                // style for column &quot;grade&quot;
                switch (customer.getGrade()) {
                    case PREMIUM: return &quot;premium-grade&quot;;
                    case HIGH: return &quot;high-grade&quot;;
                    case MEDIUM: return &quot;medium-grade&quot;;
                    default: return null;
                }
            }
            return null;
        }
    });
}</programlisting></para>
              <para>Далее нужно определить заданные для строк и ячеек стили в теме приложения. Подробная  информация о создании темы  находится в  <xref linkend="gui_themes"/>. Для веб-клиента новые стили определяются в файле <filename>styles.scss</filename>. Имена стилей, заданные в контроллере, совместно с префиксами, обозначающими строку или колонку таблицы, образуют CSS-селекторы. Например:<programlisting language="css">.v-table-row-unsatisfied-customer {
    font-weight: bold;
}

.v-table-cell-content-premium-grade {
  background-color: red;
}

.v-table-cell-content-high-grade {
  background-color: green;
}

.v-table-cell-content-medium-grade {
  background-color: blue;
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Метод <code>addPrintable()</code> позволяет задать специфическое представление данных колонки при выводе в XLS-файл, осуществляемом <link linkend="standard_actions">стандартным действием</link> <code>excel</code> или напрямую с помощью класса <code>ExcelExporter</code>. Метод принимает идентификатор колонки и реализацию интерфейса  <code>Table.Printable</code> для нее. Например:<programlisting language="java">ordersTable.addPrintable(&quot;customer&quot;, new Table.Printable&lt;Customer, String&gt;() {
    @Override
    public String getValue(Customer customer) {
  return &quot;Name: &quot; + customer.getName;
    }
});</programlisting></para>
              <para>Метод <code>getValue()</code> интерфейса <code>Table.Printable</code> должен возвращать данные, которые будут находиться в ячейке таблицы. Это может быть не только строка - метод может возвращать значения других типов, например, числовые данные или даты, и они будут представлены в XLS-файле соответствующим образом. </para>
              <para>Если форматированный вывод в XLS необходим для генерируемой колонки, нужно использовать реализацию интерфейса  <code>Table.PrintableColumnGenerator</code>, передавая ее методу <code>addGeneratedColumn()</code>. Значение для вывода в ячейку XLS-документа  задается в методе <code>getValue()</code> этого интерфейса:<programlisting language="java">ordersTable.addGeneratedColumn(&quot;product&quot;, new Table.PrintableColumnGenerator&lt;Order, String&gt;() {
    @Override
    public Component generateCell(Order entity) {
  Label label = componentsFactory.createComponent(Label.NAME);
  Product product = order.getProduct();
  label.setValue(product.getName() + &quot;, &quot; + product.getCost());
  return label;
    }

    @Override
    public String getValue(Order entity) {
  Product product = order.getProduct();
  return product.getName() + &quot;, &quot; + product.getCost();
    }
});</programlisting></para>
              <para>Если генерируемой колонке тем или иным способом не задано представления <code>Printable</code>, то в случае, если колонке  соответствует атрибут сущности, будет выведено его значение, в противном случае не будет выведено ничего.</para>
            </listitem>
            <listitem>
              <para>Метод <code>setItemClickAction()</code> позволяет задать <link linkend="gui_Action">действие</link>, выполняемое при двойном клике на строке таблицы. Если такое действие не задано, при двойном клике таблица пытается найти среди своих действий подходящее в следующем порядке:<itemizedlist>
                  <listitem>
                    <para>Действие, назначенное на клавишу <keycap>Enter</keycap> посредством свойства <code>shortcut</code>.</para>
                  </listitem>
                  <listitem>
                    <para>Действие с именем <code>edit</code>.</para>
                  </listitem>
                  <listitem>
                    <para>Действие с именем <code>view</code>.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Если такое действие найдено и имеет свойство enabled = true, оно выполняется.</para>
            </listitem>
            <listitem>
              <para>Метод <code>setEnterPressAction()</code> позволяет задать <link linkend="gui_Action">действие</link>, выполняемое при нажатии клавиши <keycap>Enter</keycap>. Если такое действие не задано, при двойном клике таблица пытается найти среди своих действий подходящее в следующем порядке:<itemizedlist>
                  <listitem>
                    <para>Действие, назначенное методом <code>setItemClickAction()</code>.</para>
                  </listitem>
                  <listitem>
                    <para>Действие, назначенное на клавишу <keycap>Enter</keycap> посредством свойства <code>shortcut</code>.</para>
                  </listitem>
                  <listitem>
                    <para>Действие с именем <code>edit</code>.</para>
                  </listitem>
                  <listitem>
                    <para>Действие с именем <code>view</code>.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Если такое действие найдено и имеет свойство enabled = true, оно выполняется.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>table</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry>
                    <link linkend="gui_attr_table_allowPopupMenu">allowPopupMenu</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_multiselect">multiselect</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_table_columnControlVisible">columnControlVisible</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_presentations">presentations</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_reorderingAllowed">reorderingAllowed</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_margin">margin</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_sortable">sortable</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>table</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_table_actions">actions</link>
                  </entry>
                </row>
                <row>buttonsPanel<entry>
                    <link linkend="gui_ButtonsPanel">buttonsPanel</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_element_table_columns">columns</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_table_rows">rows</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_table_rowsCount">rowsCount</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты  <link linkend="gui_element_table_columns">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_caption">caption</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_clickAction">clickAction</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_collapsed">collapsed</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_maxTextLength">maxTextLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_column_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы  <link linkend="gui_element_table_columns">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_formatter">formatter</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_table_rows">rows</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TextArea">
          <title>TextArea</title>
          <para>Текстовая область  − многострочное текстовое поле для редактирования текста.</para>
          <para>XML-имя компонента: <sgmltag>textArea</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_TextArea_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>TextArea</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para><code>TextArea</code> в основном повторяет функциональность <code>
              <link linkend="gui_TextField">TextField</link>
            </code>, за исключением того, что ему нельзя установить <code>datatype</code>. То есть <code>TextArea</code> предназначен для работы только с текстом и строковыми атрибутами сущностей.</para>
          <para>Компонент <code>TextArea</code> имеет следующие специфические атрибуты:</para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_textArea_cols_rows"><sgmltag>cols</sgmltag> и <sgmltag>rows</sgmltag> задают количество строк и столбцов текста:<programlisting language="xml">&lt;textArea id=&quot;textArea&quot; cols=&quot;20&quot; rows=&quot;5&quot; caption=&quot;msg://name&quot;/&gt;</programlisting></para>
              <mediaobject>
                <imageobject>
                  <imagedata contentwidth="450" contentdepth="96" align="center" fileref="img/gui_textFieldColsRows.png"/>
                </imageobject>
              </mediaobject>
              <para>Значения <code>cols</code> и <code>rows</code> имеют приоритет над значениями <code>width</code> и <code>height</code>.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_textArea_resizable"><sgmltag>resizable</sgmltag> - при задании атрибуту значения <literal>true</literal> и установке количества строк, больших одной, появляется возможность  изменять размеры компонента:</para>
              <programlisting language="xml">&lt;textArea id=&quot;textArea&quot; resizable=&quot;true&quot; caption=&quot;msg://name&quot; rows=&quot;5&quot;/&gt;</programlisting>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_textField_resizable.png"/>
                </imageobject>
              </mediaobject>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>textArea</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="5" colsep="1" rowsep="1" align="left"><colspec colname="c0"/><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_textField_trim">trim</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textArea_resizable">resizable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_textArea_cols_rows">cols</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textArea_cols_rows">rows</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TextField">
          <title>TextField</title>
          <para>Поле для редактирования текста. Может использоваться как для работы с атрибутами сущностей, так и для ввода и отображения произвольной текстовой информации.</para>
          <para>XML-имя компонента: <sgmltag>textField</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_TextField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент текстового поля реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Пример текстового поля с заголовком, взятым из <link linkend="message_packs">пакета локализованных сообщений</link>:<programlisting language="xml">&lt;textField id=&quot;nameField&quot; caption=&quot;msg://name&quot;/&gt;</programlisting></para>
              <para>На рисунке ниже показан вид простого текстового поля.</para>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_textField.png"/>
                </imageobject>
              </mediaobject>
            </listitem>
            <listitem>
              <para>Для создания текстового поля, связанного с данными, необходимо использовать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>.<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;customerDs&quot; class=&quot;com.sample.sales.entity.Customer&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;textField datasource=&quot;customerDs&quot; property=&quot;name&quot; caption=&quot;msg://name&quot;/&gt;</programlisting></para>
              <para>Как видно из примера, в экране описывается <link linkend="datasources">источник данных</link> <literal>customerDs</literal> для некоторой сущности <code>Покупатель (Customer)</code>, имеющей атрибут <code>name</code>. В компоненте текстового поля  в атрибуте <link linkend="gui_attr_basic_datasource">datasource</link> указывается ссылка на источник данных, а в атрибуте <link linkend="gui_attr_basic_property">property</link> − название атрибута сущности, значение которого должно быть отображено в текстовом поле.</para>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_textField_data.png"/>
                </imageobject>
              </mediaobject>
            </listitem>
            <listitem>
              <para id="gui_attr_textField_datatype">Если поле не связано с атрибутом сущности (то есть не указан источник данных и название атрибута), то можно указать тип данных с помощью атрибута <sgmltag>datatype</sgmltag>. Тип данных используется для форматирования значения поля. В качестве значения атрибута может быть указано любое имя типа данных, зарегистрированного в метаданных приложения - см. <xref linkend="datatype"/>. Как правило, в <code>TextField</code> используются следующие типы данных:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>decimal</literal></para>
                </listitem>
                <listitem>
                  <para><literal>double</literal></para>
                </listitem>
                <listitem>
                  <para><literal>int</literal></para>
                </listitem>
                <listitem>
                  <para><literal>long</literal></para>
                </listitem>
              </itemizedlist>
              <para>В качестве примера рассмотрим текстовое поле с типом данных <literal>Integer</literal>. <programlisting language="xml">&lt;textField id=&quot;integerField&quot; datatype=&quot;int&quot; caption=&quot;msg://integerFieldName&quot;/&gt;</programlisting></para>
              <para>Если в таком поле ввести значение, которое невозможно интерпретировать как целое число, то при потере фокуса полем будет выведено сообщение об ошибке и значение поля вернется на предыдущее:</para>
              <mediaobject>
                <imageobject>
                  <imagedata contentwidth="452" contentdepth="133" align="center" fileref="img/gui_textField_int.png"/>
                </imageobject>
              </mediaobject>
            </listitem>
            <listitem>
              <para>Текстовому полю может быть назначен валидатор - класс, реализующий интерфейс <code>Field.Validator</code>. Валидатор позволяет дополнительно к <code>datatype</code> ограничить вводимую пользователем информацию. Например, для создания поля ввода положительных целых чисел нужно создать класс валидатора:<programlisting language="java">public class PositiveIntegerValidator implements Field.Validator {
    @Override
    public void validate(Object value) throws ValidationException {
        Integer i = (Integer) value;
        if (i &lt;= 0)
            throw new ValidationException(&quot;Value must be positive&quot;);
    }
}</programlisting></para>
              <para>и задать его для текстового поля с типом данных <code>int</code> в элементе <link linkend="gui_validator">validator</link>:<programlisting language="xml">&lt;textField id=&quot;integerField&quot; datatype=&quot;int&quot;&gt;
    &lt;validator class=&quot;com.sample.sales.gui.PositiveIntegerValidator&quot;/&gt;
&lt;/textField&gt;</programlisting></para>
              <para>В отличие от проверки вводимой строки на соответствие типу данных, валидация срабатывает не сразу при потере полем фокуса, а только при вызове у поля метода <code>validate()</code>. Это означает, что поле (и связанный с ним атрибут сущности) может некоторое время содержать значение, не удовлетворяющее условиям валидации (в приведенном примере неположительное число). Это не является проблемой, так как обычно поля редактирования с валидацией располагаются в <link linkend="screen_edit">экране редактирования</link>, а он автоматически вызывает валидацию всех своих полей перед коммитом. Если же поле находится не в экране редактирования, то необходимо вызывать метод <code>validate()</code> поля в контроллере явно.</para>
            </listitem>
            <listitem id="gui_attr_textField_maxLength">
              <para>Если текстовое поле связано с атрибутом сущности (через <code>datasource</code> и <code>property</code>), и если для атрибута сущности в <link linkend="entity_attr_annotations">JPA-аннотации</link> <code>@Column</code> указан параметр <code>length</code>, то <code>TextField</code> будет соответственно ограничивать максимальную длину вводимого текста.</para>
              <para>Если текстовое поле не связано с атрибутом, либо для него не определено значение <code>length</code>, либо это значение нужно переопределить, то для ограничения максимальной длины вводимого текста можно использовать атрибут <sgmltag>maxLength</sgmltag>. Значение &quot;-1&quot; означает отсутствие ограничения. Например:<programlisting language="xml">&lt;textField id=&quot;shortTextField&quot; maxLength=&quot;10&quot;/&gt;</programlisting></para>
            </listitem>
            <listitem id="gui_attr_textField_trim">
              <para>По умолчанию текстовое поле отсекает пробелы в начале и конце введенной строки. То есть если пользователь ввел строку  &quot;<userinput> aaa bbb </userinput>&quot; то значением поля, возвращаемым методом <code>getValue()</code> и сохраняемым в связанный атрибут сущности, будет строка &quot;<userinput>aaa bbb</userinput>&quot;. Для того, чтобы отключить отсечение пробелов, используйте атрибут <sgmltag>trim</sgmltag> со значением <code>false</code>.</para>
              <para>Следует иметь в виду, что отсечение пробелов работает только при вводе нового значения. Если в значении связанного атрибута уже присутствуют пробелы, они будут отображаться, пока пользователь не изменит значение поля.</para>
            </listitem>
            <listitem>
              <para>Текстовое поле всегда вместо введенной пустой строки возвращает <code>null</code>. Соответственно, при включенном атрибуте <sgmltag>trim</sgmltag> строка, состоящая из одних пробелов также превратится в <code>null</code>.</para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>textField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_textField_datatype">datatype</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_maxLength">maxLength</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_textField_trim">trim</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>textField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_TimeField">
          <title>TimeField</title>
          <para>Поле для отображения и ввода времени.</para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="142" align="center" fileref="img/gui_timeField.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>timeField</sgmltag>.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_timeField_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент <code>TimeField</code> реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <itemizedlist>
            <listitem>
              <para>Для создания поля даты, связанного с данными, необходимо использовать атрибуты <link linkend="gui_attr_basic_datasource">datasource</link> и <link linkend="gui_attr_basic_property">property</link>:</para>
              <programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;orderDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;/&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;timeField datasource=&quot;orderDs&quot; property=&quot;deliveryTime&quot;/&gt;</programlisting>
              <para>Как видно из примера, в экране описывается источник данных <code>orderDs</code> для некоторой сущности Заказ (<code>Order</code>), имеющей атрибут <code>deliveryTime</code>. В компоненте ввода времени в атрибуте <code>datasource</code> указывается ссылка на источник данных, а в атрибуте <code>property</code> − название атрибута сущности, значение которого должно быть отображено в поле.</para>
              <para>Связанный атрибут сущности должен быть типа <code>java.util.Date</code> или <code>java.sql.Time</code>.</para>
            </listitem>
            <listitem>
              <para>Формат отображения времени определяется <link linkend="datatype">типом данных</link> <code>time</code> и задается в <link linkend="main_message_pack">главном пакете локализованных сообщений</link> в ключе <code>timeFormat</code>.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_timeField_showSeconds">Независимо от упомянутого выше формата отображением секунд можно управлять с помощью атрибута <sgmltag>showSeconds</sgmltag>. По умолчанию секунды отображаются, если формат содержит символы <code>ss</code>.<programlisting language="xml">&lt;timeField datasource=&quot;orderDs&quot; property=&quot;createTs&quot; showSeconds=&quot;true&quot;/&gt;</programlisting><mediaobject>
                  <imageobject>
                    <imagedata contentwidth="235" align="center" fileref="img/gui_timeFieldSec.png"/>
                  </imageobject>
                </mediaobject></para>
            </listitem>
          </itemizedlist>
          <para>Атрибуты <sgmltag>timeField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_timeField_showSeconds">showSeconds</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>timeField</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
        <section id="gui_TokenList">
          <title>TokenList</title>
          <para>Компонент <code>TokenList</code> представляет собой упрощенный вариант работы со списком сущностей: названия экземпляров располагаются в вертикальном или горизонтальном списке, добавление производится из выпадающего списка, удаление - с помощью кнопок, расположенных  рядом с каждым экземпляром.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_tokenList.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>tokenList</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_TokenList_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.</para>
          <para>Пример описания компонента <code>TokenList</code>   в XML-дескрипторе экрана:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;orderDs&quot;
                class=&quot;com.sample.sales.entity.Order&quot;
                view=&quot;order-edit&quot;&gt;
        &lt;collectionDatasource id=&quot;productsDs&quot; property=&quot;products&quot;/&gt;
    &lt;/datasource&gt;
    &lt;collectionDatasource id=&quot;allProductsDs&quot;
                          class=&quot;com.sample.sales.entity.Product&quot;
                          view=&quot;_minimal&quot; &gt;
        &lt;query&gt;select p from sales$Product p order by p.name&lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;tokenList id=&quot;productsList&quot; datasource=&quot;productsDs&quot; inline=&quot;true&quot; width=&quot;500px&quot;&gt;
        &lt;lookup optionsDatasource=&quot;allProductsDs&quot;/&gt;
        &lt;button caption=&quot;msg://add&quot;/&gt;
    &lt;/tokenList&gt;</programlisting></para>
          <para>Здесь в элементе <code>dsContext</code> определен вложенный источник данных <code>productsDs</code>, содержащий коллекцию входящих в состав заказа продуктов. Кроме того, определен  источник данных <code>allProductsDs</code>, содержащий коллекцию всех продуктов, имеющихся в базе данных. Компонент <code>TokenList</code> с идентификатором <code>productsList</code> отображает содержимое источника данных <code>productsDs</code>, а также позволяет изменять эту коллекцию, добавляя в него экземпляры из источника данных <code>allProductsDs</code>.</para>
          <para>Атрибуты <code>tokenList</code>:<itemizedlist>
              <listitem>
                <para id="gui_attr_tokenList_position"><sgmltag>position</sgmltag> - задает позиционирование раскрывающегося списка. Атрибут может принимать два  значения: <code>TOP</code>, <code>BOTTOM</code>. По умолчанию <code>TOP</code>.</para>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_tokenListBottom.png"/>
                  </imageobject>
                </mediaobject>
              </listitem>
              <listitem>
                <para id="gui_attr_tokenList_inline">Атрибут <sgmltag>inline</sgmltag> задает отображение списка выбранных значений: вертикально или горизонтально. Значение <literal>true</literal> соответствует горизонтальному расположению, значение <literal>false</literal> − вертикальному. Так выглядит компонент с горизонтальным расположением значений:</para>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_tokenListInline.png"/>
                  </imageobject>
                </mediaobject>
              </listitem>
              <listitem>
                <para id="gui_attr_tokenList_simple"><sgmltag>simple</sgmltag> -  значение <literal>true</literal> позволяет убрать  компонент выбора, оставляя только кнопку добавления. При нажатии на кнопку добавления сразу показывается экран списка экземпляров сущности, тип которой задан источником данных <code>datasource</code>. Идентификатор экрана выбора определяется по правилам, описанным для <link linkend="standard_actions">стандартного действия</link> <code>PickerField.LookupAction</code>. </para>
              </listitem>
            </itemizedlist></para>
          <para>Элементы <code>tokenList</code>:<itemizedlist>
              <listitem id="gui_element_tokenList_lookup">
                <para><sgmltag>lookup</sgmltag> − описатель компонента выбора значений.</para>
                <para>Атрибуты элемента <code>lookup</code>:</para>
                <para><itemizedlist>
                    <listitem id="gui_attr_tokenList_lookup_lookup">
                      <para>Атрибут <sgmltag>lookup</sgmltag> задает возможность выбора значений через экран выбора сущностей:</para>
                      <mediaobject>
                        <imageobject>
                          <imagedata align="center" fileref="img/gui_tokenListLookup.png"/>
                        </imageobject>
                      </mediaobject>
                    </listitem>
                    <listitem id="gui_attr_tokenList_lookup_lookupScreen">
                      <para>Атрибут <code>lookupScreen</code>  задает идентификатор экрана для выбора значений в режиме <code>lookup=&quot;true&quot;</code>. Если данный атрибут не задан, то идентификатор экрана выбора определяется по правилам, описанным для <link linkend="standard_actions">стандартного действия</link> <code>PickerField.LookupAction</code>. </para>
                    </listitem>
                    <listitem id="gui_attr_tokenList_lookup_openType">
                      <para>Атрибут <sgmltag>openType</sgmltag> можно задать способ открытия экрана выбора, аналогично описанному для <link linkend="standard_actions">стандартного действия</link> <code>PickerField.LookupAction</code>. По умолчанию - <literal>THIS_TAB</literal>.</para>
                    </listitem>
                    <listitem>
                      <para id="gui_attr_tokenList_lookup_multiselect">Если значение атрибута <sgmltag>multiselect</sgmltag> установлено в <code>true</code>, то в мэп параметров экрана выбора в ключе <code>MULTI_SELECT</code> передается  значение <code>true</code>. Этот признак можно использовать для установки в экране режима множественного выбора. Данный ключ определен в перечислении <code>WindowParams</code>, поэтому с ним удобно работать следующим образом:<programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
    if (WindowParams.MULTI_SELECT.getBool(getContext())) {
        usersTable.setMultiSelect(true);
    }
}</programlisting></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="gui_element_tokenList_button">
                <para><sgmltag>button</sgmltag> − описатель кнопки добавления значений. Может содержать атрибуты <link linkend="gui_attr_basic_caption">caption</link> и <link linkend="gui_attr_basic_icon">icon</link>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Все атрибуты <sgmltag>tokenList</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_tokenList_inline">inline</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>required<entry>
                    <link linkend="gui_attr_tokenList_position">position</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_tokenList_simple">simple</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>tokenList</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_element_tokenList_button">button</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_tokenList_lookup">lookup</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Все атрибуты <link linkend="gui_element_tokenList_lookup">lookup</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_lookupScreen">lookupScreen</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_lookupField_filterMode">filterMode</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_multiselect">multiselect</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_lookup">lookup</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_tokenList_lookup_openType">openType</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_tokenList_button">button</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="gui_attr_basic_icon">icon</link>
                  </entry>required</row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_Tree">
          <title>Tree</title>
          <para>Компонент <code>Tree</code> предназначен для отображения иерархической структуры, представленной сущностями, содержащими ссылки на самих себя.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_Tree.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>tree</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_tree_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Для    <code>Tree</code> в атрибуте <code>datasource</code> элемента <code>treechildren</code> должен быть указан <link linkend="datasources">hierarchicalDatasource</link>. Объявление <code>hierarchicalDatasource</code> должно содержать атрибут <code>hierarchyProperty</code> - имя атрибута сущности, являющегося ссылкой на саму себя. </para>
          <para>Пример описания компонента <code>Tree</code> в XML-дескрипторе экрана:<programlisting language="xml">&lt;dsContext&gt;
    &lt;hierarchicalDatasource id=&quot;departmentsDs&quot; class=&quot;com.sample.sales.entity.Department&quot; view=&quot;browse&quot; 
                            hierarchyProperty=&quot;parentDept&quot;&gt;
        &lt;query&gt;
            select d from sales$Department d order by d.createTs
        &lt;/query&gt;
    &lt;/hierarchicalDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;tree id=&quot;departmentsTree&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
        &lt;treechildren datasource=&quot;departmentsDs&quot; captionProperty=&quot;name&quot;/&gt;
    &lt;/tree&gt;</programlisting></para>
          <para id="gui_element_tree_treechildren">В атрибуте <code>captionProperty</code> элемента <sgmltag>treechildren</sgmltag> можно задать имя свойства сущности, отображаемого в дереве. Если этот атрибут не определен, то будет отображаться <link linkend="namePattern">имя экземпляра</link> сущности.</para>
          <para>Атрибуты <sgmltag>tree</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="2" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/>c <tbody>
                <row><entry>
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>tree</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_element_table_actions">actions</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="gui_element_tree_treechildren">treechildren</link>
                  </entry>required</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>treechildren</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>editable</row>
                <row><entry>
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>required</row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TreeTable">
          <title>TreeTable</title>
          <para>Компонент <code>TreeTable</code>   − иерархическая таблица,  отображающая в первой колонке древовидную структуру. Предназначена для работы с сущностями, которые содержат ссылки на самих себя. Это могут быть  например, файловая система или организационная структура предприятия.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_treeTable.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>treeTable</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_TreeTable_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
          <para>Для    <code>TreeTable</code> в атрибуте <code>datasource</code> элемента <code>rows</code> должен быть указан <link linkend="datasources">hierarchicalDatasource</link>. Объявление <code>hierarchicalDatasource</code> должно содержать атрибут <code>hierarchyProperty</code> - имя атрибута сущности, являющегося ссылкой на саму себя. </para>
          <para>Пример описания таблицы в XML-дескрипторе экрана:<programlisting language="xml">&lt;dsContext&gt;
    &lt;hierarchicalDatasource id=&quot;tasksDs&quot; class=&quot;com.sample.sales.entity.Task&quot; view=&quot;browse&quot; 
                            hierarchyProperty=&quot;parentTask&quot;&gt;
        &lt;query&gt;
            select t from sales$Task t
        &lt;/query&gt;
    &lt;/hierarchicalDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;treeTable id=&quot;tasksTable&quot; width=&quot;100%&quot;&gt;
        &lt;columns&gt;
            &lt;column id=&quot;name&quot;/&gt;
            &lt;column id=&quot;dueDate&quot;/&gt;
            &lt;column id=&quot;assignee&quot;/&gt;
        &lt;/columns&gt;
        &lt;rows datasource=&quot;tasksDs&quot;/&gt;
    &lt;/treeTable&gt;</programlisting></para>
          <para>Функциональность <code>TreeTable</code> аналогична простой таблице <link linkend="gui_Table">Table</link>. </para>
          <para>Атрибуты <sgmltag>treeTable</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_table_allowPopupMenu">allowPopupMenu</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry><entry>
                    <link linkend="gui_attr_table_reorderingAllowed">reorderingAllowed</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="gui_attr_table_columnControlVisible">columnControlVisible</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_sortable">sortable</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_multiselect">multiselect</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_presentations">presentations</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>treeTable</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry>
                    <link linkend="gui_element_table_actions">actions</link>
                  </entry>
                </row>
                <row>buttonsPanel<entry>
                    <link linkend="gui_ButtonsPanel">buttonsPanel</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_element_table_columns">columns</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_element_table_rows">rows</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
          <para>Атрибуты  <link linkend="gui_element_table_columns">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_caption">caption</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_dateField_dateFormat">dateFormat</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_dateField_resolution">resolution</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_column_editable">editable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_clickAction">clickAction</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_table_column_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_table_column_collapsed">collapsed</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы  <link linkend="gui_element_table_columns">column</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_formatter">formatter</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <link linkend="gui_element_table_rows">rows</link>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left"><colspec colname="c1"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TwinColumn">
          <title>TwinColumn</title>
          <para>Компонент <code>TwinColumn</code>  представляет собой сдвоенный список для множественного выбора опций. В левом списке содержатся доступные невыбранные значения, в правом списке содержатся выбранные значения. Пользователь выбирает значения, перенося их из левого в правый список и обратно с помощью двойного клика или соответствующих кнопок. Для каждого значения можно задать уникальный стиль отображения и пиктограмму.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/TwinColumn.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>twinColumn</sgmltag></para>
          <mediaobject>
            <imageobject>
              <imagedata contentwidth="173" contentdepth="389" align="center" fileref="img/gui_TwinColumn_dia.png"/>
            </imageobject>
          </mediaobject>
          <para>Компонент реализован только для блока <structname>Web Client</structname>.</para>
          <para>Пример использования компонента <sgmltag>twinColumn</sgmltag> для выбора экземпляров сущности:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; class=&quot;com.company.sample.entity.Car&quot; view=&quot;_local&quot;/&gt;
    &lt;collectionDatasource id=&quot;coloursDs&quot; class=&quot;com.company.sample.entity.Colour&quot; view=&quot;_local&quot;&gt;
        &lt;query&gt;select c from sample$Colour c&lt;/query&gt;
    &lt;/collectionDatasource&gt;    
&lt;/dsContext&gt;
&lt;layout&gt;
    &lt;twinColumn id=&quot;coloursField&quot; optionsDatasource=&quot;coloursDs&quot; addAllBtnEnabled=&quot;true&quot;/&gt;</programlisting></para>
          <para>В данном случае компонент <code>coloursField</code> отобразит <link linkend="namePattern">имена экземпляров</link> сущности <code>Colour</code>,  находящихся в источнике данных <code>coloursDs</code>, а его метод <code>getValue()</code> вернет коллекцию выбранных экземпляров сущности.</para>
          <para>Атрибут <code>addAllBtnEnabled</code> задает отображение кнопок, позволяющих перемещать между списками все опции сразу.</para>
          <para id="gui_attr_twinColumn_columns_rows">Атрибут <sgmltag>columns</sgmltag> используется для задания количества символов в строке, а атрибут <sgmltag>rows</sgmltag> − для задания количества строк текста в каждом списке. </para>
          <para>Для задания внешнего вида опций можно реализовать интерфейс <code>TwinColumn.StyleProvider</code> и возвращать название стиля и путь к пиктограмме в зависимости от конкретного экземпляра сущности, отображаемого в компоненте.</para>
          <para>Список опций компонента <code>TwinColumn</code> может быть задан произвольно с помощью методов <code>setOptionsList()</code> и <code>setOptionsMap()</code>, аналогично описанному для компонента <link linkend="gui_OptionsGroup">OptionsGroup</link>.</para>
          <para>Атрибуты <sgmltag>twinColumn</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_editable">editable</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row><entry>
                    <link linkend="gui_attr_basic_captionProperty">captionProperty</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry><entry align="left">
                    <link linkend="gui_attr_basic_required">required</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>required</row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_twinColumn_columns_rows">columns</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_requiredMessage">requiredMessage</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_datasource">datasource</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_twinColumn_columns_rows">rows</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_description">description</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_property">property</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>twinColumn</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="1" colsep="1" rowsep="1" align="left">
              <colspec colname="c1"/>
              <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_validator">validator</link>
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </informaltable>
        </section>
      </section>
      <section id="gui_layouts">
        <title>Контейнеры</title>
        <para><link linkend="gui_BoxLayout">BoxLayout</link></para>
        <para><link linkend="gui_ButtonsPanel">ButtonsPanel</link></para>
        <para><link linkend="gui_IFrame">IFrame</link></para>
        <para><link linkend="gui_GridLayout">GridLayout</link></para>
        <para><link linkend="gui_GroupBoxLayout">GroupBoxLayout</link></para>
        <para><link linkend="gui_ScrollBoxLayout">ScrollBoxLayout</link></para>
        <para><link linkend="gui_SplitPanel">SplitPanel</link></para>
        <para><link linkend="gui_TabSheet">TabSheet</link></para>
        <section id="gui_BoxLayout">
          <title>BoxLayout</title>
          <para><code>BoxLayout</code> представляет собой контейнер с последовательным размещением компонентов.</para>
          <para>Существует три  типа <code>BoxLayout</code>, определяемых именем XML-элемента:</para>
          <itemizedlist>
            <listitem>
              <para><sgmltag>hbox</sgmltag> − горизонтальное расположение компонентов.</para>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_hbox.png"/>
                </imageobject>
              </mediaobject>
              <programlisting language="xml">&lt;hbox spacing=&quot;true&quot; margin=&quot;true&quot;&gt;
    &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot;/&gt;
    &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot;/&gt;
    &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot;/&gt;
&lt;/hbox&gt;</programlisting>
            </listitem>
            <listitem>
              <para><sgmltag>vbox</sgmltag> − вертикальное расположение компонентов. <sgmltag>vbox</sgmltag> имеет 100% ширину по умолчанию.</para>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_vbox.png"/>
                </imageobject>
              </mediaobject>
              <programlisting language="xml">&lt;vbox spacing=&quot;true&quot; margin=&quot;true&quot;&gt;
    &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot;/&gt;
    &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot;/&gt;
    &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot;/&gt;
&lt;/vbox&gt;</programlisting>
            </listitem>
            <listitem>
              <para><sgmltag>flowBox</sgmltag> − горизонтальное расположение компонентов с переносом вниз. При недостатке места по горизонтали непомещающиеся компоненты будут перенесены &quot;на следующую строку&quot; (поведение аналогично <application>Swing</application> <code>FlowLayout</code>).</para>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_flowbox.png"/>
                </imageobject>
              </mediaobject>
              <programlisting language="xml">&lt;flowBox spacing=&quot;true&quot; margin=&quot;true&quot;&gt;
    &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot;/&gt;
    &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot;/&gt;
    &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot;/&gt;
&lt;/flowBox&gt;</programlisting>
            </listitem>
          </itemizedlist>
          <para>В элементах <code>hbox</code>, <code>vbox</code>, <code>flowBox</code> могут быть использованы следующие XML-атрибуты:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_expand">expand</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_margin">margin</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_spacing">spacing</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_ButtonsPanel">
          <title>ButtonsPanel</title>
          <para><code>ButtonsPanel</code> - контейнер, унифицирующий использование и размещение компонентов (чаще всего кнопок) для управления данными в таблице.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_buttonsPanel.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>buttonsPanel</sgmltag>.</para>
          <para>Пример описания <code>ButtonsPanel</code>  в XML-дескрипторе экрана:<programlisting language="xml">&lt;table id=&quot;customersTable&quot;
       editable=&quot;false&quot; width=&quot;100%&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;create&quot;/&gt;
        &lt;action id=&quot;edit&quot;/&gt;
        &lt;action id=&quot;remove&quot;/&gt;
        &lt;action id=&quot;excel&quot;/&gt;
    &lt;/actions&gt;
    &lt;buttonsPanel&gt;
        &lt;button action=&quot;customersTable.create&quot;/&gt;
        &lt;button action=&quot;customersTable.edit&quot;/&gt;
        &lt;button action=&quot;customersTable.remove&quot;/&gt;
        &lt;button action=&quot;customersTable.excel&quot;/&gt;
    &lt;/buttonsPanel&gt;
    &lt;columns&gt;
        &lt;column id=&quot;name&quot;/&gt;
        &lt;column id=&quot;email&quot;/&gt;
    &lt;/columns&gt;
    &lt;rows datasource=&quot;customersDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
          <para>Элемент <code>buttonsPanel</code> можно разместить как внутри <code>table</code>, так и в  произвольном месте экрана. </para>
          <para>Если <code>buttonsPanel</code> находится внутри <code>table</code>, то она комбинируется с компонентом <link linkend="gui_attr_table_rowsCount">rowsCount</link> таблицы, тем самым оптимально расходуя место по вертикали. Кроме того, в этом случае при открытии экрана выбора методом <code>IFrame.openLookup()</code> (например, из компонента <link linkend="gui_PickerField">PickerField</link>) панель кнопок скрывается.</para>
          <para id="gui_attr_buttonsPanel_alwaysVisible">Атрибут <sgmltag>alwaysVisible</sgmltag> служит для отключения скрытия панели в экране выбора при его открытии методом <code>IFrame.openLookup()</code>. Если значение атрибута равно <literal>true</literal>, то панель с кнопками не скрывается. По умолчанию значение атрибута равно <literal>false</literal>.</para>
          <para>Атрибуты <sgmltag>buttonsPanel</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_buttonsPanel_alwaysVisible">alwaysVisible</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">styleName</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_expand">expand</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_GridLayout">
          <title>GridLayout</title>
          <para><code>GridLayout</code> - контейнер, располагающий компоненты по сетке.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_gridlayout.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>grid</sgmltag>.</para>
          <para>Пример использования контейнера:<programlisting language="xml">&lt;grid spacing=&quot;true&quot;&gt;
    &lt;columns count=&quot;4&quot;/&gt;
    &lt;rows&gt;
        &lt;row&gt;
            &lt;label value=&quot;Date&quot;/&gt;
            &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot;/&gt;
            &lt;label value=&quot;Customer&quot;/&gt;
            &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot;/&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;label value=&quot;Amount&quot;/&gt;
            &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot;/&gt;
        &lt;/row&gt;
    &lt;/rows&gt;
&lt;/grid&gt;</programlisting></para>
          <para>Элементы <code>grid</code>:<itemizedlist>
              <listitem id="gui_attr_grid_columns">
                <para><code>columns</code> - обязательный элемент, описывает колонки сетки. Должен либо иметь атрибут <code>count</code>, либо вложенные элементы <code>column</code> для каждой колонки.</para>
                <para>В простейшем случае достаточно задать число колонок в атрибуте <code>count</code>. Тогда, если ширина всего контейнера явно задана в пикселах или процентах, незанятое место будет распределяться между колонками равными долями.</para>
                <para>Для  распределения незанятого места неравными долями необходимо определить для каждой колонки элемент <code>column</code> и задать для него атрибут <code>flex</code>.</para>
                <para>Пример сетки, в которой вторая и четвертая колонки занимают все лишнее место по горизонтали, причем четвертая колонка забирает себе в три раза больше лишнего места:<programlisting language="xml">&lt;grid spacing=&quot;true&quot; width=&quot;100%&quot;&gt;
    &lt;columns&gt;
        &lt;column/&gt;
        &lt;column flex=&quot;1&quot;/&gt;
        &lt;column/&gt;
        &lt;column flex=&quot;3&quot;/&gt;
    &lt;/columns&gt;    
    &lt;rows&gt;
        &lt;row&gt;
            &lt;label value=&quot;Date&quot;/&gt;
            &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot; width=&quot;100%&quot;/&gt;
            &lt;label value=&quot;Customer&quot;/&gt;
            &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot; width=&quot;100%&quot;/&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;label value=&quot;Amount&quot;/&gt;
            &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot; width=&quot;100%&quot;/&gt;
        &lt;/row&gt;
    &lt;/rows&gt;
&lt;/grid&gt;</programlisting></para>
                <para>Если атрибут <code>flex</code> не указан, или указано значение 0, то ширина данной колонки будет установлена по содержимому, если хотя-бы одна другая колонка имеет ненулевой <code>flex</code>. В приведенном примере первая и третья колонки получат ширину по максимальной длине текста надписей.</para>
                <tip>
                  <para>Для того, чтобы лишнее место вообще образовалось, необходимо установить всему контейнеру ширину в пикселах или процентах. В противном случае ширина колонок будет рассчитана по ширине содержимого, и атрибут <code>flex</code> не будет иметь никакого эффекта.</para>
                </tip>
              </listitem>
              <listitem id="gui_attr_grid_rows">
                <para><sgmltag>rows</sgmltag> − обязательный элемент, содержит последовательность строк. Каждая строка определяется в своем элементе <code>row</code>. </para>
                <para>Элемент <code>row</code> может содержать атрибут <code>flex</code>, аналогичный описанному для <code>column</code>, но влияющий на распределение лишнего места по вертикали при заданной общей высоте сетки.</para>
                <para>Элемент <code>row</code> должен содержать элементы компонентов, отображаемых в ячейках данной строки сетки. Число компонентов в одной строке не должно превышать заданного количества колонок, но может быть меньше.</para>
              </listitem>
            </itemizedlist></para>
          <para id="gui_GridLayout_span">Любой компонент, находящийся в контейнере <code>grid</code>, может иметь атрибуты <code>colspan</code> и <code>rowspan</code>. Эти атрибуты задают соответственно сколько  колонок и строк будет занимать данный компонент. Например, так можно растянуть поле <code>Field3</code> на три колонки:<programlisting language="xml">&lt;grid spacing=&quot;true&quot;&gt;
    &lt;columns count=&quot;4&quot;/&gt;
    &lt;rows&gt;
        &lt;row&gt;
            &lt;label value=&quot;Field1&quot;/&gt;
            &lt;textField/&gt;
            &lt;label value=&quot;Field2&quot;/&gt;
            &lt;textField/&gt;
        &lt;/row&gt;
        &lt;row&gt;
            &lt;label value=&quot;Field3&quot;/&gt;
            &lt;textField colspan=&quot;3&quot; width=&quot;100%&quot;/&gt;
        &lt;/row&gt;
    &lt;/rows&gt;
&lt;/grid&gt;</programlisting></para>
          <para>В результате компоненты будут располагаться следующим образом:<mediaobject>
              <imageobject>
                <imagedata align="center" fileref="img/gui_gridlayout_colspan.png"/>
              </imageobject>
            </mediaobject></para>
          <para>Атрибуты <sgmltag>grid</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_spacing">spacing</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">styleName</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_margin">margin</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Элементы <sgmltag>grid</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_grid_columns">columns</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="gui_attr_grid_rows">rows</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>columns</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_grid_columns">count</link>
                  </entry>editable</row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>column</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry>
                    <link linkend="gui_attr_grid_rows">flex</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Атрибуты <sgmltag>row</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row>
                  <entry>
                    <link linkend="gui_attr_grid_rows">flex</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_GroupBoxLayout">
          <title>GroupBoxLayout</title>
          <para><code>GroupBoxLayout</code> - контейнер, позволяющий выделить рамкой содержащиеся в нем компоненты, и задать им общий заголовок. Кроме того, он умеет сворачивать свое содержимое.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_groupBox.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>groupBox</sgmltag>.</para>
          <para>Пример описание контейнера  в XML-дескрипторе экрана:<programlisting language="xml">&lt;groupBox caption=&quot;Order&quot;&gt;
    &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot; caption=&quot;Date&quot;/&gt;
    &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; 
                 optionsDatasource=&quot;customersDs&quot; caption=&quot;Customer&quot;/&gt;
    &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot; caption=&quot;Amount&quot;/&gt;
&lt;/groupBox&gt;</programlisting></para>
          <para>Атрибуты <code>groupBox</code>:<itemizedlist>
              <listitem>
                <para><code>caption</code> - заголовок группы.</para>
              </listitem>
              <listitem id="gui_attr_groupBox_orientation">
                <para><code>orientation</code> -  задает направление расположения вложенных компонентов − <literal>horizontal</literal> или <literal>vertical</literal>. По умолчанию <literal>vertical</literal>.</para>
              </listitem>
              <listitem id="gui_attr_groupBox_collapsable">
                <para><sgmltag>collapsable</sgmltag> − значение <literal>true</literal> позволяет пользователю скрывать содержимое компонента с помощью значков <inlinemediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_groupBox_minus.png"/>
                    </imageobject>
                  </inlinemediaobject>/<inlinemediaobject>
                    <imageobject>
                      <imagedata fileref="img/gui_groupBox_plus.png"/>
                    </imageobject>
                  </inlinemediaobject>.</para>
              </listitem>
              <listitem id="gui_attr_groupBox_collapsed">
                <para><sgmltag>collapsed</sgmltag> − если указано значение <literal>true</literal>, то содержимое компонента будет свернуто сразу после открытия экрана. Используется совместно с <code>collapsable=&quot;true&quot;</code>. </para>
                <para>Пример свернутого <code>GroupBox</code>:</para>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_groupBox_collapsed.png"/>
                  </imageobject>
                </mediaobject>
              </listitem>
            </itemizedlist></para>
          <para>Контейнер <code>groupBox</code> по умолчанию имеет ширину 100% аналогично <link linkend="gui_BoxLayout">vbox</link>.</para>
          <para>Все атрибуты <sgmltag>groupBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_expand">expand</link>
                  </entry><entry>
                    <link linkend="gui_attr_groupBox_orientation">orientation</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_groupBox_collapsable">collapsable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_spacing">spacing</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_groupBox_collapsed">collapsed</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_IFrame">
          <title>IFrame</title>
          <para>Элемент <sgmltag>iframe</sgmltag> предназначен для включения в экран <link linkend="frame">фрейма</link>.</para>
          <para>Атрибуты:<itemizedlist>
              <listitem>
                <para id="gui_attr_frame_src"><sgmltag>src</sgmltag> − путь к XML-дескриптору фрейма.</para>
              </listitem>
              <listitem>
                <para><sgmltag>screen</sgmltag> - идентификатор фрейма в <link linkend="screens.xml">screens.xml</link> (если фрейм зарегистрирован).</para>
              </listitem>
            </itemizedlist> Должен быть указан один из этих атрибутов. Если указано оба, фрейм будет загружен из явно указанного в <sgmltag>src</sgmltag> файла. </para>
          <para>Другие атрибуты <sgmltag>iframe</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_ScrollBoxLayout">
          <title>ScrollBoxLayout</title>
          <para><code>ScrollBoxLayout</code> − контейнер, который позволяет прокручивать свое содержимое.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_scrollBox.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>scrollBox</sgmltag></para>
          <para>Пример описание контейнера с прокруткой в XML-дескрипторе экрана:<programlisting language="xml">&lt;groupBox caption=&quot;Order&quot; width=&quot;300&quot; height=&quot;170&quot;&gt;
    &lt;scrollBox width=&quot;100%&quot; height=&quot;100%&quot; spacing=&quot;true&quot; margin=&quot;true&quot;&gt;
        &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot; caption=&quot;Date&quot;/&gt;
        &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot; caption=&quot;Customer&quot;/&gt;
        &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot; caption=&quot;Amount&quot;/&gt;
     &lt;/scrollBox&gt;
&lt;/groupBox&gt;</programlisting></para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_scrollBox_orientation">С помощью атрибута <sgmltag>orientation</sgmltag> можно задавать направление расположения вложенных компонентов − <literal>horizontal</literal> или <literal>vertical</literal>. По умолчанию  <literal>vertical</literal>.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_scrollBox_scrollBars">Атрибут <sgmltag>scrollBars</sgmltag> позволяет настраивать полосы прокрутки. Может принимать значения <sgmltag>horizontal</sgmltag>, <sgmltag>vertical</sgmltag> - для прокрутки по горизонтали и вертикали соответственно, <sgmltag>both</sgmltag> - для прокрутки во всех направлениях. Установка значения <sgmltag>none</sgmltag> запрещает прокрутку в любом направлении</para>
            </listitem>
          </itemizedlist>
          <warning>
            <para>Вложенные в <sgmltag>scrollBox</sgmltag> компоненты должны иметь фиксированные размеры или размеры по умолчанию. Нельзя устанавливать <code>height=&quot;100%&quot;</code> или <code>width=&quot;100%&quot;</code>.</para>
            <para>В то же время <sgmltag>scrollBox</sgmltag> не может вычислять свои собственные  размеры по содержимому. Ему нужно либо указать абсолютные размеры, либо растянуть в родительском контейнере, установив <code>height=&quot;100%&quot;</code> и <code>width=&quot;100%&quot;</code>.</para>
          </warning>
          <para>Атрибуты <sgmltag>scrollBox</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="3" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_align">align</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_margin">margin</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_spacing">spacing</link>
                  </entry>editable</row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_scrollBox_orientation">orientation</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_scrollBox_scrollBars">scrollBars</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_SplitPanel">
          <title>SplitPanel</title>
          <para><code>SplitPanel</code> − контейнер, разбитый на две области, размер которых по горизонтали либо вертикали можно менять путем перемещения разделителя. </para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_splitPanel.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>split</sgmltag>.</para>
          <para>Пример описания панели с разделителем  в XML-дескрипторе экрана:<programlisting language="xml">&lt;split orientation=&quot;horizontal&quot; pos=&quot;30&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
   &lt;vbox margin=&quot;true&quot; spacing=&quot;true&quot;&gt;
       &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot; caption=&quot;Date&quot;/&gt;
       &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot; caption=&quot;Customer&quot;/&gt;
   &lt;/vbox&gt;
   &lt;vbox margin=&quot;true&quot; spacing=&quot;true&quot;&gt;
       &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot; caption=&quot;Amount&quot;/&gt;
   &lt;/vbox&gt;
&lt;/split&gt;</programlisting></para>
          <para>Внутри контейнера <code>split</code> обязательно должны находиться два вложенных контейнера или компонента, которые  и будут расположены по обе стороны разделителя.</para>
          <para>Атрибуты <code>split</code>:<itemizedlist>
              <listitem id="gui_attr_split_orientation">
                <para><code>orientation</code> - задает ориентацию расположения компонентов. <code>horizontal</code> - вложенные компоненты располагаются горизонтально, <code>vertical</code> - вертикально.</para>
              </listitem>
              <listitem id="gui_attr_split_pos">
                <para><code>pos</code> - целое число, определяющее процентное соотношение размера первой области по отношению ко второй. Например, <code>pos=&quot;30&quot;</code> означает соотношение областей 30/70. По умолчанию соотношение областей составляет 50/50.</para>
              </listitem>
            </itemizedlist></para>
          <para>Все атрибуты <sgmltag>split</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_split_pos">pos</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_split_orientation">orientation</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
        <section id="gui_TabSheet">
          <title>TabSheet</title>
          <para>Контейнер <code>TabSheet</code> - это панель с вкладками (<sgmltag>tabs</sgmltag>). В один момент времени отображается содержимое только одной вкладки.</para>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_tabsheet.png"/>
            </imageobject>
          </mediaobject>
          <para>XML-имя компонента: <sgmltag>tabSheet</sgmltag>.</para>
          <para>Пример описания панели с вкладками  в XML-дескрипторе экрана:<programlisting language="xml">&lt;tabSheet&gt;
    &lt;tab id=&quot;mainTab&quot; caption=&quot;Tab1&quot; margin=&quot;true&quot; spacing=&quot;true&quot;&gt;
        &lt;dateField datasource=&quot;orderDs&quot; property=&quot;date&quot; caption=&quot;Date&quot;/&gt;
        &lt;lookupField datasource=&quot;orderDs&quot; property=&quot;customer&quot; optionsDatasource=&quot;customersDs&quot; caption=&quot;Customer&quot;/&gt;
    &lt;/tab&gt;
    &lt;tab id=&quot;additionalTab&quot; caption=&quot;Tab2&quot; margin=&quot;true&quot; spacing=&quot;true&quot;&gt;
        &lt;textField datasource=&quot;orderDs&quot; property=&quot;amount&quot; caption=&quot;Amount&quot;/&gt;
    &lt;/tab&gt;
&lt;/tabSheet&gt;</programlisting></para>
          <para>Компонент <sgmltag>tabSheet</sgmltag> должен иметь вложенные элементы   <sgmltag>tab</sgmltag>, описывающие вкладки. Каждая вкладка является контейнером с вертикальным расположением компонентов, аналогичным <link linkend="gui_BoxLayout">vbox</link>.</para>
          <para>Атрибуты элемента <code>tab</code>:<itemizedlist>
              <listitem id="gui_attr_tabsheet_id">
                <para><code>id</code> - идентификатор вкладки. Следует отметить, что вкладка не является компонентом, и данный идентификатор используется только в рамках <code>TabSheet</code> для работы с ней из кода контроллера.</para>
              </listitem>
              <listitem>
                <para><link linkend="gui_attr_basic_caption">caption</link> - заголовок вкладки. </para>
              </listitem>
              <listitem id="gui_attr_tabsheet_lazy">
                <para><sgmltag>lazy</sgmltag> - задает отложенную загрузку содержимого вкладки. </para>
                <para>При открытии экрана lazy-вкладки не загружают свое содержимое, что приводит к созданию меньшего количества компонентов в памяти. Компоненты вкладки загружаются только в тот момент, когда пользователь выбирает данную вкладку. Кроме того, если на lazy-вкладке расположены визуальные компоненты, связанные с <link linkend="datasources">источником данных</link>, содержащим JPQL запрос, то этот запрос также не выполняется. В результате экран открывается быстрее, а данные загружаются только в тот момент, когда пользователь действительно хочет их увидеть, выбирая данную вкладку. </para>
                <para>Следует иметь в виду, что компоненты, расположенные на lazy-вкладке, не существуют в момент открытия экрана. Поэтому их нельзя <link linkend="screen_controller_injection">инжектировать</link> в контроллер, и нельзя получить вызовом <code>getComponent()</code> в методе <code>init()</code> контроллера. Обратиться к компонентам <code>lazy</code>-вкладки можно только после того, как пользователь на нее переключился. Этот момент можно отловить с помощью слушателя <code>TabSheet.TabChangeListener</code>, например:  </para>
                <programlisting language="java">@Inject
private TabSheet tabsheet;

private boolean detailsInitialized, historyInitialized;

@Override
public void init(Map&lt;String, Object&gt; params) {
    tabsheet.addListener(
            new TabSheet.TabChangeListener() {
                @Override
                public void tabChanged(TabSheet.Tab newTab) {
                    if (&quot;detailsTab&quot;.equals(newTab.getName()))
                        initDetails();
                    else if (&quot;historyTab&quot;.equals(newTab.getName()))
                        initHistory();
                }
            }
    );
}

private void initDetails() {
    if (detailsInitialized)
        return;

    // use getComponentNN(&quot;comp_id&quot;) here to get tab&apos;s components
    
    detailsInitialized = true;
}

private void initHistory() {
    if (historyInitialized)
        return;

    // use getComponentNN(&quot;comp_id&quot;) here to get tab&apos;s components
    
    historyInitialized = true;
}</programlisting>
                <para>По умолчанию вкладки не являются <code>lazy</code>, а значит, загружают свое содержимое в момент открытия экрана.</para>
              </listitem>
              <listitem id="gui_attr_tabsheet_detachable">
                <para><code>detachable</code> - значение <code>true</code> в десктоп-реализации экрана дает возможность отсоединять вкладку в отдельное окно. Это позволяет, например, размещать части UI приложения на разных мониторах. Отделяемая вкладка имеет специальную кнопку в заголовке:</para>
                <mediaobject>
                  <imageobject>
                    <imagedata align="center" fileref="img/gui_tabsheetDetachable.png"/>
                  </imageobject>
                </mediaobject>
              </listitem>
            </itemizedlist></para>
          <para>Атрибуты <sgmltag>tabSheet</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_height">height</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_visible">visible</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_basic_id">id</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_basic_width">width</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_stylename">stylename</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
          <para>Все атрибуты элемента  <sgmltag>tab</sgmltag>:</para>
          <informaltable frame="none" pgwide="0" align="left">
            <tgroup cols="4" colsep="1" rowsep="1" align="left"><colspec colname="c1"/><colspec colname="c2"/><colspec colname="c3"/><colspec colname="c4"/>c <tbody>
                <row><entry align="left">
                    <link linkend="gui_attr_basic_caption">caption</link>
                  </entry>editable<entry align="left">
                    <link linkend="gui_attr_basic_expand">expand</link>
                  </entry><entry>
                    <link linkend="gui_attr_basic_margin">margin</link>
                  </entry></row>
                <row>
                  <entry>
                    <link linkend="gui_attr_tabsheet_detachable">detachable</link>
                  </entry>
                  <entry align="left">
                    <link linkend="gui_attr_tabsheet_id">id</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_basic_spacing">spacing</link>
                  </entry>
                </row>
                <row>
                  <entry align="left">
                    <link linkend="gui_attr_basic_enable">enable</link>
                  </entry>
                  <entry>
                    <link linkend="gui_attr_tabsheet_lazy">lazy</link>
                  </entry>
                </row>
              </tbody></tgroup>
          </informaltable>
        </section>
      </section>
      <section id="gui_misc">
        <title>Разное</title>
        <para>В данном разделе рассматриваются различные элементы универсального пользовательского интерфейса, имеющие отношение к визуальным компонентам.</para>
        <section id="gui_formatter">
          <title>Formatter</title>
          <para>Formatter предназначен для преобразования некоторого значения в строку.</para>
          <warning>
            <para>Formatter предназначен для использования с read-only компонентами, такими как <link linkend="gui_Label">Label</link>, колонка <link linkend="gui_Table">Table</link> и тому подобными. Для форматирования значения в редактируемых компонентах, например <link linkend="gui_TextField">TextField</link>, используйте механизм <code>
                <link linkend="datatype">Datatype</link>
              </code>.</para>
          </warning>
          <para>В XML-дескрипторе экрана formatter для компонента может быть задан во вложенном  элементе <sgmltag>formatter</sgmltag>. Элемент имеет единственный атрибут:</para>
          <itemizedlist>
            <listitem>
              <para><sgmltag>class</sgmltag> − имя класса, реализующего интерфейс <code>com.haulmont.cuba.gui.components.Formatter</code></para>
            </listitem>
          </itemizedlist>
          <para>Если конструктор класса formatter принимает параметр типа <code>org.dom4j.Element</code>, то ему будет передан элемент XML, описывающий данный <code>formatter</code>. Это можно использовать для параметризации экземпляра formatter&apos;а, например, строкой форматирования. В частности, имеющиеся в платформе классы <code>DateFormatter</code> и <code>NumberFormatter</code> могут брать строку форматирования из атрибута <sgmltag>format</sgmltag>. Пример использования:<programlisting language="xml">&lt;column id=&quot;date&quot;&gt;
    &lt;formatter class=&quot;com.haulmont.cuba.gui.components.formatters.DateFormatter&quot; format=&quot;yyyy-MM-dd HH:mm:ss&quot;/&gt;
&lt;/column&gt;</programlisting></para>
          <para>Кроме того, класс <code>DateFormatter</code> распознает также атрибут <sgmltag>type</sgmltag>, который может принимать значения <literal>DATE</literal> или <literal>DATETIME</literal>. В этом случае форматирование производится с помощью механизма <code>
              <link linkend="datatype">Datatype</link>
            </code> по строке формата <code>dateFormat</code> или <code>dateTimeFormat</code> соответственно. Например:<programlisting language="xml">&lt;column id=&quot;endDate&quot;&gt;
    &lt;formatter class=&quot;com.haulmont.cuba.gui.components.formatters.DateFormatter&quot; type=&quot;DATE&quot;/&gt;
&lt;/column&gt;</programlisting></para>
          <tip>
            <para>Если formatter реализован внутренним классом, то он должен быть объявлен с модификатором <code>static</code>, а его имя для загрузки отделяется символом &quot;$&quot;, например:</para>
            <para><code>&lt;formatter class=&quot;com.sample.sales.gui.OrderBrowse$CurrencyFormatter&quot;/&gt;</code></para>
          </tip>
          <para>Formatter можно назначить компоненту не только в XML-дескрипторе экрана, но и программно, передавая экземпляр formatter&apos;а в метод <code>setFormatter()</code> компонента.</para>
          <para>Пример объявления собственного formatter&apos;а и использования его для форматирования значения колонки таблицы:<programlisting language="java">public class CurrencyFormatter implements Formatter&lt;BigDecimal&gt; {

    protected GeneralConfiguration generalConfiguration;
    protected Currency currentCurrency;

    public CurrencyFormatter(GeneralConfiguration generalConfiguration) {
        this.generalConfiguration = generalConfiguration;
        currentCurrency = generalConfiguration.getCurrency();
    }

    @Override
    public String format(BigDecimal value) {
        return currentCurrency.format(value);
    }
}</programlisting><programlisting language="java">protected void initTableColumns() {
    Formatter&lt;BigDecimal&gt; currencyFormatter = new CurrencyFormatter(generalConfiguration);
    table.getColumn(&quot;totalPrice&quot;).setFormatter(currencyFormatter);
}</programlisting></para>
        </section>
        <section id="gui_Table_presentations">
          <title>Presentation </title>
          <para>Механизм представлений позволяет пользователям системы управлять настройками отображения компонентов.</para>
          <para><emphasis role="bold">Возможности</emphasis>:</para>
          <itemizedlist>
            <listitem>
              <para>Сохранение представлений под уникальными именами</para>
            </listitem>
            <listitem>
              <para>Редактирование и удаление представлений</para>
            </listitem>
            <listitem>
              <para>Быстрое переключение между представлениями</para>
            </listitem>
            <listitem>
              <para>Задание представления по умолчанию, которое будет применяться при открытии экрана с компонентом</para>
            </listitem>
            <listitem>
              <para>Автосохранение настроек отображения в активном представлении</para>
            </listitem>
            <listitem>
              <para>Глобальные представления, которые доступны всем пользователям системы</para>
            </listitem>
          </itemizedlist>
          <para><emphasis role="bold">Классы и интерфейсы</emphasis></para>
          <para>Для применения представлений класс компонента должен реализовывать интерфейс <code>com.haulmont.cuba.gui.components.Component.HasPresentations</code>. В платформе такими компонентами являются:</para>
          <itemizedlist>
            <listitem>
              <para><link linkend="gui_Table">Table</link></para>
            </listitem>
            <listitem>
              <para><link linkend="gui_GroupTable">GroupTable</link></para>
            </listitem>
            <listitem>
              <para><link linkend="gui_TreeTable">TreeTable</link></para>
            </listitem>
          </itemizedlist>
          <para><code>Presentation</code> − POJO объект представления.</para>
          <para><code>Presentations</code> содержит список представлений компонента и набор методов по работе с ними. Основные методы:</para>
          <itemizedlist>
            <listitem>
              <para><code>getCurrent()</code> − возвращает текущее активное представление или <code>null</code>, если представление не выбрано</para>
            </listitem>
            <listitem>
              <para><code>setCurrent(Presentation p)</code> − устанавливает активное представление</para>
            </listitem>
            <listitem>
              <para><code>getSettings(Presentation p)</code> − возвращает XML-элемент настроек отображения для указанного представления</para>
            </listitem>
            <listitem>
              <para><code>setSettings(Presentation p, Element e)</code> − модифицирует настройки отображения для указанного представления</para>
            </listitem>
            <listitem>
              <para><code>getPresentation(Object id)</code> − возвращает представление по его идентификатору</para>
            </listitem>
            <listitem>
              <para><code>getPresentations()</code> − возвращает список идентификаторов представлений для данного компонента</para>
            </listitem>
            <listitem>
              <para><code>commit()</code> − сохраняет представления в базу данных</para>
            </listitem>
          </itemizedlist>
          <para><code>PresentationsImpl</code> − реализация интерфейса <code>Presentations</code>.</para>
          <para><code>PresentationsChangeListener</code> − интерфейс слушателя изменений представлений.</para>
          <para>Для создания, изменения, удаления глобальных представлений пользователь должен иметь права <property>cuba.gui.presentations.global</property>. Подробнее см. руководство <productname>Платформа CUBA. Подсистема безопасности</productname>.</para>
        </section>
        <section id="gui_Timer">
          <title>Timer</title>
          <para>Таймер − это невизуальный компонент, позволяющий выполнять некоторый код  контроллера экрана через определенные промежутки времени. Срабатывание таймера происходит в потоке обработки событий пользовательского интерфейса, что позволяет обновлять экран без каких-либо ограничений.  Таймер прекращает работу при закрытии  экрана, для которого он был создан.</para>
          <para>Компонент реализован для блоков <structname>Web Client</structname> и <structname>Desktop Client</structname>.  Для веб клиента реализация таймеров основана на опросе сервера из веб-браузера, для десктоп клиента - на <code>javax.swing.Timer</code>.</para>
          <para>Основной способ создания таймеров - декларативно в XML-дескрипторе экрана в элементе <sgmltag>timers</sgmltag>, располагающемся между элементами <sgmltag>dsContext</sgmltag> и <sgmltag>layout</sgmltag>. </para>
          <para>Для описания таймера используется элемент <sgmltag>timer</sgmltag>.</para>
          <itemizedlist>
            <listitem>
              <para id="gui_attr_timer_delay">Атрибут <sgmltag>delay</sgmltag> является обязательным атрибутом, в нем задается интервал срабатывания таймера в миллисекундах.</para>
            </listitem>
            <listitem>
              <para><sgmltag>autostart</sgmltag> - необязательный атрибут, при установке которого в <code>true</code> таймер стартует сразу после открытия экрана. По умолчанию <code>false</code>, что означает что для старта таймера необходимо вызвать его метод <code>start()</code>.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_timer_repeating"><sgmltag>repeating</sgmltag> − необязательный атрибут, включает многократное срабатывание таймера. Если значение атрибута равно <literal>true</literal>, то таймер выполняется циклически, через равные промежутки времени, заданные в атрибуте <sgmltag>delay</sgmltag>. В противном случае таймер выполняется один раз через <sgmltag>delay</sgmltag> миллисекунд после старта таймера.</para>
            </listitem>
            <listitem>
              <para id="gui_attr_timer_onTimer"><sgmltag>onTimer</sgmltag> − необязательный атрибут, содержащий имя метода, вызываемого при срабатывании таймера. Метод-обработчик должен быть определен в контроллере экрана с модификатором <code>public</code> и иметь один параметр типа  <code>com.haulmont.cuba.gui.components.Timer</code>. </para>
            </listitem>
          </itemizedlist>
          <para>Пример использования таймера для периодического обновления содержимого таблицы:</para>
          <programlisting language="xml">&lt;window ...
    &lt;dsContext&gt;
        &lt;collectionDatasource id=&quot;bookInstanceDs&quot; ...
    &lt;/dsContext&gt;
    &lt;timers&gt;
        &lt;timer delay=&quot;3000&quot; autostart=&quot;true&quot; repeating=&quot;true&quot; onTimer=&quot;refreshData&quot;/&gt;
    &lt;/timers&gt;
    &lt;layout ...</programlisting>
          <programlisting language="java">@Inject
private CollectionDatasource bookInstanceDs;

public void refreshData(Timer timer) {
    bookInstanceDs.refresh();
}</programlisting>
          <para>Таймер можно инжектировать в поле контроллера, либо получить методом <code>Window.getTimer()</code>. Управлять активностью таймера можно с помощью его методов <code>start()</code> и <code>stop()</code>. Для уже активного таймера вызов <code>start()</code> игнорируется. После остановки таймера методом <code>stop()</code> его можно снова запустить методом <code>start()</code>.</para>
          <para>Задать обработчик событий от таймера можно с помощью реализации интерфейса <code>Timer.TimerListener</code>:</para>
          <programlisting language="xml">&lt;timers&gt;
    &lt;timer id=&quot;helloTimer&quot; delay=&quot;5000&quot;/&gt;
&lt;/timers&gt;</programlisting>
          <programlisting language="java">@Inject
private Timer helloTimer;

@Override
public void init(Map&lt;String, Object&gt; params) {
    helloTimer.addTimerListener(new Timer.TimerListener() {
        @Override
        public void onTimer(Timer timer) {
            showNotification(&quot;Hello&quot;, NotificationType.HUMANIZED);
        }

        @Override
        public void onStopTimer(Timer timer) {
            showNotification(&quot;Timer is stopped&quot;, NotificationType.HUMANIZED);
        }
    });
    helloTimer.start();
}</programlisting>
          <para>Таймер можно также создавать в коде контроллера приложения следующим образом:</para>
          <programlisting language="java">@Inject
private ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
    Timer helloTimer = componentsFactory.createTimer();
    helloTimer.setDelay(5000);
    helloTimer.setRepeating(true);
    helloTimer.addTimerListener(new Timer.TimerListener() {
        @Override
        public void onTimer(Timer timer) {
            showNotification(&quot;Hello&quot;, NotificationType.HUMANIZED);
        }

        @Override
        public void onStopTimer(Timer timer) {
            showNotification(&quot;Timer is stopped&quot;, NotificationType.HUMANIZED);
        }
    });
    helloTimer.start();

    addTimer(helloTimer);
}</programlisting>
        </section>
        <section id="gui_validator">
          <title>Validator</title>
          <para>Валидатор предназначен для проверки значения, введенного в визуальном компоненте.</para>
          <warning>
            <para>Следует отличать валидацию от проверки типа данных. Если для некоторого компонента, например <link linkend="gui_TextField">TextField</link>, задан тип, отличный от строкового (это происходит при связывании с атрибутом сущности или назначении <code>datatype</code>), то компонент не позволяет ввести значение, не удовлетворяющее этому типу - при потере фокуса или нажатии <keycap>Enter</keycap> компонент отобразит предыдущее значение.</para>
            <para>Валидация же срабатывает не сразу при вводе или потере компонентом фокуса, а только при вызове у компонента метода <code>validate()</code>. Это означает, что компонент (и связанный с ним атрибут сущности) может некоторое время содержать значение, не удовлетворяющее условиям валидации. Это не является проблемой, так как обычно компоненты ввода с валидацией располагаются в <link linkend="screen_edit">экране редактирования</link>, а он автоматически вызывает валидацию всех своих компонентов перед коммитом. Если же компонент находится не в экране редактирования, то необходимо вызывать его метод <code>validate()</code> в контроллере явно.</para>
          </warning>
          <para>В XML-дескрипторе экрана валидатор для компонента может быть задан во вложенном  элементе <sgmltag>validator</sgmltag>. Атрибуты элемента <sgmltag>validator</sgmltag>:</para>
          <itemizedlist>
            <listitem>
              <para><sgmltag>script</sgmltag> − путь к скрипту Groovy, осуществляющему валидацию.</para>
            </listitem>
            <listitem>
              <para><sgmltag>class</sgmltag> − имя класса Java, реализующего интерфейс <code>Field.Validator</code>.</para>
            </listitem>
            <listitem>
              <para>Groovy-валидатор и стандартные классы Java-валидаторов, расположенные в пакете <code>com.haulmont.cuba.gui.components.validators</code> поддерживают атрибут <sgmltag>message</sgmltag> − сообщение, выводимое пользователю в случае ошибки валидации. Атрибут должен содержать ключ сообщения в пакете, например, <literal>message=&quot;msg://infoTextField.validationMsg&quot;</literal></para>
            </listitem>
          </itemizedlist>
          <para>Выбор механизма валидации осуществляется следующим образом:</para>
          <itemizedlist>
            <listitem>
              <para>Если не указано значение атрибута <sgmltag>script</sgmltag>, и сам элемент <sgmltag>validator</sgmltag> не содержит текста выражения Groovy, то в качестве валидатора используется класс, указанный в атрибуте <sgmltag>class</sgmltag>.</para>
            </listitem>
            <listitem>
              <para>Если элемент <sgmltag>validator</sgmltag> содержит текст, то он будет использован как выражение Groovy и выполнен с помощью <link linkend="scripting">Scripting</link>.</para>
            </listitem>
            <listitem>
              <para>В противном случае с помощью <link linkend="scripting">Scripting</link> будет выполнен скрипт Groovy, указанный в атрибуте <sgmltag>script</sgmltag>.</para>
            </listitem>
          </itemizedlist>
          <para>В выражение или скрипт Groovy будет передана одна переменная <code>value</code>, содержащая значение, введенное в визуальном компоненте. Выражение или скрипт должны вернуть <literal>boolean</literal> значение: <literal>true</literal> − valid, <literal>false</literal> − not valid.</para>
          <para>Если в качестве валидатора используется класс Java, то он должен иметь либо дефолтный конструктор без параметров, либо конструктор со следующим набором параметров:<itemizedlist>
              <listitem>
                <para><code>org.dom4j.Element</code>, <code>String</code> - в этот конструктор будут переданы XML-элемент валидатора и имя пакета сообщений экрана.</para>
              </listitem>
              <listitem>
                <para><code>org.dom4j.Element</code> - в этот конструктор будет передан XML-элемент валидатора.</para>
              </listitem>
            </itemizedlist></para>
          <tip>
            <para>Если валидатор реализован внутренним классом, то он должен быть объявлен с модификатором <code>static</code>, а его имя для загрузки отделяется символом &quot;$&quot;, например:</para>
            <para><code>&lt;validator class=&quot;com.sample.sales.gui.AddressEdit$ZipValidator&quot;/&gt;</code></para>
          </tip>
          <para>Платформа уже содержит несколько реализаций наиболее часто используемых валидаторов (см. пакет <code>com.haulmont.cuba.gui.components.validators</code>), которые можно применять в  проектах:</para>
          <itemizedlist>
            <listitem>
              <para><code>DateValidator</code></para>
            </listitem>
            <listitem>
              <para><code>DoubleValidator</code></para>
            </listitem>
            <listitem>
              <para><code>EmailValidator</code></para>
            </listitem>
            <listitem>
              <para><code>IntegerValidator</code></para>
            </listitem>
            <listitem>
              <para><code>LongValidator</code></para>
            </listitem>
            <listitem>
              <para><code>PatternValidator</code></para>
            </listitem>
            <listitem>
              <para><code>ScriptValidator</code></para>
            </listitem>
          </itemizedlist>
          <para>Валидатор-класс можно назначить компоненту не только в XML-дескрипторе экрана, но и программно, передавая экземпляр валидатора в метод <code>addValidator()</code> компонента.</para>
          <para>Пример создания класса валидатора почтового индекса:<programlisting language="java">public class ZipValidator implements Field.Validator {
    @Override
    public void validate(Object value) throws ValidationException {
        if (value != null &amp;&amp; ((String) value).length() != 6)
            throw new ValidationException(&quot;Zip must be of 6 characters length&quot;);
    }
}</programlisting></para>
          <para>Использование валидатора почтового индекса и стандартного валидатора по шаблону в полях компонента <link linkend="gui_FieldGroup">FieldGroup</link>:<programlisting language="xml">&lt;fieldGroup ...&gt;
    &lt;field id=&quot;zip&quot; required=&quot;true&quot;&gt;
         &lt;validator class=&quot;com.sample.sales.gui.ZipValidator&quot;/&gt;
    &lt;/field&gt;
    &lt;field id=&quot;imei&quot;&gt;
        &lt;validator class=&quot;com.haulmont.cuba.gui.components.validators.PatternValidator&quot;
               pattern=&quot;\d{15}&quot;
               message=&quot;msg://general.imeiValidationFailed&quot;/&gt;
    &lt;/field&gt;
&lt;/fieldGroup&gt;</programlisting></para>
          <para>Пример программного задания валидатора:<programlisting language="java">if (Boolean.TRUE.equals(parameter.getRequired())) {
    tokenList.addValidator(new Field.Validator() {
        @Override
        public void validate(Object value) throws ValidationException {
            if (value instanceof Collection &amp;&amp; CollectionUtils.isEmpty((Collection) value)) {
                throw new ValidationException(getMessage(&quot;error.paramIsRequiredButEmpty&quot;));
            }
        }
    });
}</programlisting></para>
        </section>
      </section>
      <section id="gui_attributes">
        <title>XML-атрибуты компонентов</title>
        <variablelist>
          <varlistentry id="gui_attr_basic_align">
            <term>align</term>
            <listitem>
              <para>Атрибут, задающий расположение компонента относительно вышестоящего контейнера.</para>
              <para>Возможные значения:</para>
              <itemizedlist>
                <listitem>
                  <para><literal>TOP_RIGHT</literal></para>
                </listitem>
                <listitem>
                  <para><literal>TOP_LEFT</literal></para>
                </listitem>
                <listitem>
                  <para><literal>TOP_CENTER</literal></para>
                </listitem>
                <listitem>
                  <para><literal>MIDDLE_RIGHT</literal></para>
                </listitem>
                <listitem>
                  <para><literal>MIDDLE_LEFT</literal></para>
                </listitem>
                <listitem>
                  <para><literal>MIDDLE_CENTER</literal></para>
                </listitem>
                <listitem>
                  <para><literal>BOTTOM_RIGHT</literal></para>
                </listitem>
                <listitem>
                  <para><literal>BOTTOM_LEFT</literal></para>
                </listitem>
                <listitem>
                  <para><literal>BOTTOM_CENTER</literal></para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_caption">
            <term>caption</term>
            <listitem>
              <para>Атрибут, устанавливающий заголовок для визуального компонента.</para>
              <para>Значением атрибута должна быть либо  строка сообщения, либо ключ в <link linkend="message_packs">пакете сообщений</link>. В случае ключа значение должно начинаться с префикса <literal>msg://</literal></para>
              <para>Способы задания ключа:</para>
              <itemizedlist>
                <listitem>
                  <para>Короткий ключ − при этом сообщение ищется в пакете, заданном для данного экрана:</para>
                  <programlisting>caption=&quot;msg://infoFieldCaption&quot;</programlisting>
                </listitem>
                <listitem>
                  <para>Полный ключ, с заданием пакета:</para>
                  <programlisting>caption=&quot;msg://com.haulmont.refapp.gui.app/infoFieldCaption&quot;</programlisting>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_captionProperty">
            <term>captionProperty</term>
            <listitem>
              <para>Задает имя атрибута сущности, отображаемого компонентом. Используется только для сущностей, находящихся в источнике данных (например заданном для <link linkend="gui_LookupField">LookupField</link> свойством <link linkend="gui_attr_basic_optionsDatasource">optionsDatasource</link>).</para>
              <para>Если <code>captionProperty</code> не задан, будет отображаться <link linkend="namePattern">имя экземпляров</link>, содержащихся в источнике данных.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_clickAction">
            <term>clickAction</term>
            <listitem>
              <para>Атрибут содержит описание действия, которое будет выполнено при клике в ячейке или в поле (для компонента <link linkend="gui_FieldGroup">FieldGroup</link>). Возможны два типа действий:</para>
              <itemizedlist>
                <listitem>
                  <para><code>open</code> − открывает для сущности, отображаемой в ячейке, экран редактирования с указанным именем, например: <code>clickAction=&quot;open:sec$User.edit&quot;</code>. Имя сущности отображается в виде ссылки:</para>
                  <mediaobject>
                    <imageobject>
                      <imagedata align="center" fileref="img/gui_clickAction_open.png"/>
                    </imageobject>
                  </mediaobject>
                </listitem>
                <listitem>
                  <para><code>invoke</code> − вызывает метод контроллера экрана с указанным именем, например: <code>clickAction=&quot;invoke:onClick&quot;</code>. Метод должен иметь единственный параметр типа <code>Object</code>, в который будет передан экземпляр сущности, отображаемой в ячейке.</para>
                </listitem>
              </itemizedlist>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_colspan">
            <term>colspan</term>
            <listitem>
              <para>Указывает, сколько <link linkend="gui_GridLayout_span">колонок сетки</link> должен занять компонент (по умолчанию 1).</para>
              <para>Данный атрибут может быть назначен любому компоненту, находящемуся непосредственно внутри контейнера <link linkend="gui_GridLayout">GridLayout</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_datasource">
            <term>datasource</term>
            <listitem>
              <para>Предназначен для задания <link linkend="datasources">источника данных</link>, описанного в секции <sgmltag>dsContext</sgmltag> XML-дескриптора экрана.</para>
              <para>При указании атрибута <code>datasource</code> для компонента, реализующего интерфейс <code>DatasourceComponent</code>, необходимо также задать атрибут <link linkend="gui_attr_basic_property">property</link>. </para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_description">
            <term>description</term>
            <listitem>
              <para>Атрибут, задающий текст подсказки для компонента.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_editable">
            <term>editable</term>
            <listitem>
              <para>Атрибут, указывающий на возможность редактирования содержимого компонента (не путать с <link linkend="gui_attr_basic_enable">enable</link>).</para>
              <para>Возможные значения − <literal>true</literal>, <literal>false</literal>. По умолчанию <literal>true</literal>.</para>
              <para>На возможность редактирования содержимого для компонента, связанного с данными (наследника <code>DatasourceComponent</code> или <code>ListComponent</code>), влияет также подсистема безопасности. Если по данным подсистемы безопасности данный компонент должен быть недоступен для редактирования, значение атрибута <sgmltag>editable</sgmltag> не принимается во внимание.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_enable">
            <term>enable</term>
            <listitem>
              <para>Атрибут компонента, устанавливающий его состояние: доступен, недоступен.</para>
              <para>Если компонент недоступен, то он не принимает фокус ввода. Недоступность контейнера приводит к тому, что все его компоненты также становятся недоступными.

Возможные значения − <literal>true</literal>, <literal>false</literal>.

По умолчанию  все компоненты доступны.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_expand">
            <term>expand</term>
            <listitem>
              <para>Атрибут контейнера для управления его внутренней компоновкой.</para>
              <para>Задает компонент внутри контейнера, который необходимо расширить на все доступное пространство в направлении размещения компонентов. Для контейнера с вертикальным размещением устанавливает компоненту 100% высоту, для контейнера с горизонтальным размещением - 100% ширину. Кроме того, при изменении размера контейнера изменять размер будет именно этот компонент.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_height">
            <term>height</term>
            <listitem>
              <para>Атрибут, устанавливающий высоту компонента.</para>
              <para>Может быть задана в пикселях либо в процентах от высоты вышестоящего контейнера. Например: <literal>100px</literal>, <literal>100%</literal>, <literal>50</literal>. Если единица измерения не указана, подразумевается высота в пикселях.</para>
              <para>Установка значения в <literal>%</literal> означает, что компонент по высоте займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.</para>
              <para>При выборе значения <code>AUTO</code> или <code>-1px</code> для компонента устанавливается высота по умолчанию, для контейнера  высота определяется по содержимому, то есть суммарной высотой вложенных компонентов.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_icon">
            <term>icon</term>
            <listitem>
              <para>Атрибут, устанавливающий пиктограмму для визуального компонента.</para>
              <para>Значением атрибута должен быть путь к файлу пиктограммы относительно каталога <link linkend="gui_themes">темы</link>. Например:</para>
              <programlisting>icon=&quot;icons/create.png&quot;</programlisting>
              <para>Если пиктограмма должна быть выбрана в зависимости от языка пользователя, можно указать путь к ней в пакете сообщений, а в атрибуте <sgmltag>icon</sgmltag> − ключ сообщения, например:</para>
              <programlisting>icon=&quot;msg://addIcon&quot;</programlisting>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_id">
            <term>id</term>
            <listitem>
              <para>Идентификатор компонента.</para>
              <para>Рекомендуется формировать значение по правилам Java-идентификаторов и использовать camelСase, например, <code>userGrid</code>, <code>filterPanel</code>.

Может быть указан для любого компонента и должен быть уникальным в пределах экрана.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_margin">
            <term>margin</term>
            <listitem>
              <para>Атрибут <sgmltag>margin</sgmltag> устанавливает наличие отступа между внешними границами и содержимым контейнера.</para>
              <para>Может иметь 2 вида значений:</para>
              <itemizedlist>
                <listitem>
                  <para><sgmltag>margin</sgmltag>=<literal>&quot;true&quot;</literal> − установить отступ со всех сторон сразу</para>
                </listitem>
                <listitem>
                  <para><sgmltag>margin</sgmltag>=<literal>&quot;true;false;true;false;&quot;</literal> −  установить отступ только сверху и снизу (формат значения &quot;сверху,справа,снизу,слева&quot;)</para>
                </listitem>
              </itemizedlist>
              <para>По умолчанию отступы отсутствуют.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_nullName">
            <term>nullName</term>
            <listitem>
              <para>Идентификатор опции, выбор которой будет равносилен установке значения в <code>null</code>.</para>
              <para>Атрибут используется для компонентов <link linkend="gui_LookupField">LookupField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>, <link linkend="gui_SearchPickerField">SearchPickerField</link>.</para>
              <para>Пример для компонента <link linkend="gui_LookupField">LookupField</link>, установка значения атрибута в <link linkend="screen_xml_glossentry">XML-дескрипторе</link>:</para>
              <programlisting language="xml">&lt;lookupField datasource=&quot;orderDs&quot; 
             property=&quot;customer&quot; 
             nullName=&quot;(none)&quot; 
             optionsDatasource=&quot;customersDs&quot; width=&quot;200px&quot;/&gt;</programlisting>
              <para>Пример для компонента <link linkend="gui_LookupField">LookupField</link>, установка значения атрибута в <link linkend="screen_controller_glossentry">контроллере</link>: <programlisting language="xml">&lt;lookupField id=&quot;customerLookupField&quot; optionsDatasource=&quot;customersDs&quot; 
             width=&quot;200px&quot; datasource=&quot;orderDs&quot; property=&quot;customer&quot;/&gt;</programlisting><programlisting language="java">customerLookupField.setNullOption(&quot;&lt;null&gt;&quot;);</programlisting></para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_optionsDatasource">
            <term>optionsDatasource</term>
            <listitem>
              <para>Задает имя <link linkend="datasources">источника данных</link>, используемого для формирования списка опций.</para>
              <para>Совместно с <sgmltag>optionsDatasource</sgmltag> может использоваться атрибут <link linkend="gui_attr_basic_captionProperty">captionProperty</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_property">
            <term>property</term>
            <listitem>
              <para>Атрибут компонента, реализующего интерфейс <code>DatasourceComponent</code>.</para>
              <para>Предназначен для задания имени атрибута сущности, значение которого будет отображаться или редактироваться данным визуальным компонентом.</para>
              <para>Используется всегда совместно с атрибутом <link linkend="gui_attr_basic_datasource">datasource</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_required">
            <term>required</term>
            <listitem>
              <para>Атрибут визуального компонента, реализующего интерфейс <code>Field</code>. Указывает, что в данное поле обязательно должно быть введено значение.</para>
              <para>Возможные значения атрибута − <literal>true</literal>, <literal>false</literal>. По умолчанию <literal>false</literal>.</para>
              <para>Совместно с <sgmltag>required</sgmltag> может использоваться атрибут <sgmltag>requiredMessage</sgmltag>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_requiredMessage">
            <term>requiredMessage</term>
            <listitem>
              <para>XML-атрибут, используемый совместно с атрибутом <link linkend="gui_attr_basic_required">required</link>. Позволяет установить сообщение, выводимое пользователю в случае нарушения требования <link linkend="gui_attr_basic_required">required</link>.</para>
              <para>Атрибут должен содержать ключ сообщения в пакете, например: <sgmltag>requiredMessage</sgmltag>=&quot;<literal>msg://infoTextField.requiredMessage</literal>&quot;</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_rowspan">
            <term>rowspan</term>
            <listitem>
              <para>Указывает, сколько <link linkend="gui_GridLayout_span">строк сетки</link> должен занять компонент (по умолчанию 1).</para>
              <para>Данный атрибут может быть назначен любому компоненту, находящемуся непосредственно внутри контейнера <link linkend="gui_GridLayout">GridLayout</link>.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_spacing">
            <term>spacing</term>
            <listitem>
              <para>Атрибут <sgmltag>spacing</sgmltag> устанавливает наличие отступов между компонентами внутри контейнера.</para>
              <para>Возможные значения − <literal>true</literal>, <literal>false</literal>.</para>
              <para>По умолчанию отступы отсутствуют.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_stylename">
            <term>stylename</term>
            <listitem>
              <para>Атрибут, задающий имя стиля компонента.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_visible">
            <term>visible</term>
            <listitem>
              <para>Атрибут, устанавливающий видимость компонента. Возможные значения − <literal>true</literal>, <literal>false</literal>. </para>
              <para>Если контейнер невидим, не видны и все его компоненты. По умолчанию все компоненты видимы.</para>
            </listitem>
          </varlistentry>
          <varlistentry id="gui_attr_basic_width">
            <term>width</term>
            <listitem>
              <para>Атрибут, устанавливающий ширину компонента.</para>
              <para>Значение может быть задано в пикселях или в процентах от ширины вышестоящего контейнера. Например: <literal>100px</literal>, <literal>100%</literal>, <literal>50</literal>. Если единица измерения не указана, подразумевается ширина в пикселях. Простановка значения в <literal>%</literal> означает, что компонент по ширине займет соответствующую часть пространства, предоставляемого контейнером более высокого уровня.</para>
              <para>При выборе значения <code>AUTO</code> или <code>-1px</code> для компонента устанавливается ширина по умолчанию, для контейнера ширина определяется по содержимому, то есть суммарной шириной вложенных компонентов.</para>
            </listitem>
          </varlistentry>
        </variablelist>
      </section>
    </section>
    <section id="datasources">
      <title>Источники данных</title>
      <para>Источники данных обеспечивают работу связанных с данными (data-aware) компонентов.</para>
      <para>Визуальные компоненты сами не обращаются к <structname>Middleware</structname>, а получают экземпляры сущностей  из связанных источников данных. При этом один источник данных может обслуживать несколько визуальных компонентов, если им нужен один и тот же экземпляр или набор экземпляров.</para>
      <para>Связь визуального компонента и источника данных проявляется в следующем:<itemizedlist>
          <listitem>
            <para>При изменении пользователем значения в компоненте новое значение проставляется в атрибуте сущности, находящейся в источнике.</para>
          </listitem>
          <listitem>
            <para>При изменении атрибута сущности из кода новое значение проставляется и отображается в визуальном компоненте. </para>
          </listitem>
          <listitem>
            <para>Для слежения за вводом пользователя можно использовать как <link linkend="datasource_listeners">слушатель источника данных</link>, так и слушатель значения визуального компонента - они срабатывают друг за другом. </para>
          </listitem>
          <listitem>
            <para>При необходимости прочитать или записать значение атрибута сущности в коде предпочтительнее использовать источник данных, а не компонент. Рассмотрим пример чтения атрибута:<programlisting language="java">@Inject
private FieldGroup fieldGroup;
@Inject
private Datasource&lt;Order&gt; orderDs;

public void init(Map&lt;String, Object&gt; params) {
    Customer customer;
    // Get customer from component
    customer = (Customer) fieldGroup.getFieldValue(&quot;customer&quot;);
    // Get customer from datasource
    customer = orderDs.getItem().getCustomer();
}</programlisting></para>
            <para>Как видно из примера, работа со значениями атрибутов сущностей через компонент требует приведения типа и, в случае <link linkend="gui_FieldGroup">FieldGroup</link>, указания имени атрибута в виде строки. В то же время, получив методом <code>getItem()</code> из источника данных хранящийся в нем экземпляр, можно напрямую читать и изменять значения его атрибутов.</para>
          </listitem>
        </itemizedlist><warning>
          <para>Как правило, визуальный компонент привязывается к атрибуту, непосредственно принадлежащему сущности, находящейся в источнике данных. В приведенном выше примере компонент привязан к атрибуту <code>customer</code> сущности <code>Order</code>. </para>
          <para>Можно также привязать компонент к атрибуту связанной сущности, например к <code>customer.name</code>. В этом случае компонент будет корректно отображать значение атрибута <code>name</code>, но при его изменении пользователем слушатели источника данных вызваны не будут, и изменения не будут сохранены. Поэтому привязывать компонент к атрибутам второго и более порядка имеет смысл только для отображения, например в <link linkend="gui_Label">Label</link>, колонке <link linkend="gui_Table">Table</link> или установив для <link linkend="gui_TextField">TextField</link> свойство <code>editable = false</code>.</para>
        </warning></para>
      <para>Источники данных также отслеживают изменения содержащихся в них сущностей, и могут отправлять измененные экземпляры обратно на <structname>Middleware</structname> для сохранения в базе данных.</para>
      <para>Рассмотрим основные интерфейсы источников.</para>
      <figure>
        <title>Интерфейсы источников данных</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/Datasources.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <itemizedlist>
        <listitem>
          <para><code>Datasource</code> − простейший источник данных, предназначенный для работы с одним экземпляром сущности. Экземпляр устанавливается методом <code>setItem()</code> и  доступен через <code>getItem()</code>. </para>
          <para>Стандартной реализацией такого источника является класс <code>DatasourceImpl</code>, который используется, например, как главный источник данных в <link linkend="screen_edit">экранах редактирования</link> сущностей.</para>
        </listitem>
        <listitem>
          <para><code>CollectionDatasource</code> − источник данных, предназначенный для работы с коллекцией экземпляров сущности. Коллекция загружается при вызове метода <code>refresh()</code>, ключи экземпляров доступны через метод <code>getItemIds()</code>. Метод <code>setItem()</code> устанавливает, а <code>getItem()</code> возвращает  &quot;текущий&quot; экземпляр коллекции, т.е., например, соответствующий выбранной в данный момент строке таблицы.</para>
          <para>Способ загрузки коллекции сущностей определяется реализацией. Наиболее типичный - загрузка с <structname>Middleware</structname> через <code>
              <link linkend="dataService">DataService</link>
            </code>, при этом для формирования JPQL запроса используются методы <code>setQuery()</code>, <code>setQueryFilter()</code>.</para>
          <para>Стандартной реализацией такого источника является класс <code>CollectionDatasourceImpl</code>, который используется в экранах, отображающих списки сущностей.</para>
          <itemizedlist>
            <listitem>
              <para><code>GroupDatasource</code> − подвид <code>CollectionDatasource</code>, предназначенный для работы с компонентом <code>
                  <link linkend="gui_GroupTable">GroupTable</link>
                </code>.</para>
              <para>Стандартной реализацией является класс <code>GroupDatasourceImpl</code>.</para>
            </listitem>
            <listitem>
              <para><code>HierarchicalDatasource</code> − подвид <code>CollectionDatasource</code>, предназначенный для работы с компонентами <code>
                  <link linkend="gui_Tree">Tree</link>
                </code> и  <code>
                  <link linkend="gui_TreeTable">TreeTable</link>
                </code>.</para>
              <para>Стандартной реализацией является класс <code>HierarchicalDatasourceImpl</code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><code>NestedDatasource</code> - источник данных, предназначенный для работы с экземплярами, загруженными в атрибуте другой сущности. При этом источник, содержащий сущность-хозяина, доступен методом <code>getMaster()</code>, а <link linkend="metaProperty">мета-свойство</link>, соответствующее атрибуту хозяина, содержащему экземпляры данного источника, доступно через метод <code>getProperty()</code>.</para>
          <para>Например,  в источнике <code>dsOrder</code> установлен экземпляр сущности <code>Order</code>, содержащий ссылку на экземпляр <code>Customer</code>. Тогда для связи экземпляра <code>Customer</code> с визуальными компонентами достаточно создать <code>NestedDatasource</code>, у которого хозяином является <code>dsOrder</code>, а мета-свойство указывает на атрибут <code>Order.customer</code>.</para>
          <itemizedlist>
            <listitem>
              <para><code>PropertyDatasource</code> - подвид <code>NestedDatasource</code>, предназначенный для работы с одним экземпляром или коллекцией связанных сущностей, не являющихся встроенными (embedded).</para>
              <para>Стандартные реализации: для работы с одним экземпляром - <code>PropertyDatasourceImpl</code>, для работы с коллекцией - <code>CollectionPropertyDatasourceImpl</code>, <code>GroupPropertyDatasourceImpl</code>, <code>HierarchicalPropertyDatasourceImpl</code>. Последние реализуют также интерфейс <code>CollectionDatasource</code>, однако некоторые его нерелевантные методы, связанные с загрузкой, например, <code>setQuery()</code>, выбрасывают <code>UnsupportedOperationException</code>.</para>
            </listitem>
            <listitem>
              <para><code>EmbeddedDatasource</code> - подвид <code>NestedDatasource</code>, содержащий экземпляр встроенной сущности.</para>
              <para>Стандартной реализацией является класс <code>EmbeddedDatasourceImpl</code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para><code>RuntimePropsDatasource</code> − специфический источник, предназначенный для работы с <link linkend="runtime_properties">динамическими атрибутами</link> сущностей.</para>
        </listitem>
      </itemizedlist>
      <para>Как правило, источники данных объявляются декларативно в секции <sgmltag>dsContext</sgmltag> <link linkend="screen_xml">дескриптора экрана</link>.</para>
      <section>
        <title>Создание источников данных</title>
        <para>Объекты источников данных могут быть созданы как декларативно - путем объявления в XML-дескрипторе экрана, так и программно в контроллере. Обычно используются стандартные реализации интерфейсов источников, однако при необходимости можно создать собственный класс, унаследовав его от стандартного.</para>
        <section>
          <title>Декларативное создание</title>
          <para>Как правило, источники данных объявляются декларативно в элементе <sgmltag>dsContext</sgmltag> дескриптора экрана. В зависимости от взаимного расположения элементов объявлений создаются источники двух разновидностей:<itemizedlist>
              <listitem>
                <para>если элемент расположен непосредственно в <sgmltag>dsContext</sgmltag>, создается обычный <code>Datasource</code> или <code>CollectionDatasource</code>, который содержит независимо загруженную сущность или коллекцию;</para>
              </listitem>
              <listitem>
                <para>если элемент расположен внутри элемента другого источника, создается <code>NestedDatasource</code>, при этом  внешний источник становится его хозяином. </para>
              </listitem>
            </itemizedlist></para>
          <para>Пример объявления источников данных:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; class=&quot;com.haulmont.sample.entity.Car&quot; view=&quot;carEdit&quot;&gt;
        &lt;collectionDatasource id=&quot;allocationsDs&quot; property=&quot;driverAllocations&quot;/&gt;
        &lt;collectionDatasource id=&quot;repairsDs&quot; property=&quot;repairs&quot;/&gt;
    &lt;/datasource&gt;

    &lt;collectionDatasource id=&quot;colorsDs&quot; class=&quot;com.haulmont.sample.entity.Color&quot; view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select c from sample$Color c order by c.name
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;</programlisting></para>
          <para>Здесь источник <code>carDs</code> содержит один экземпляр сущности <code>Car</code>, а вложенные в него <code>allocationsDs</code> и <code>repairsDs</code> содержат коллекции связанных сущностей из атрибутов <code>Car.driverAllocations</code> и <code>Car.repairs</code> соответственно. Экземпляр <code>Car</code> вместе со связанными сущностями проставляется в источник данных извне. Если данный экран является <link linkend="screen_edit">экраном редактирования</link>, то это происходит автоматически при открытии экрана. Источник данных <code>colorsDs</code> содержит коллекцию экземпляров сущности <code>Color</code>, загружаемую самим источником по указанному JPQL-<link linkend="datasource_query">запросу</link> с <link linkend="views">представлением</link> <code>_local</code>.</para>
          <para>Рассмотрим схему XML. </para>
          <para><sgmltag>dsContext</sgmltag> - корневой элемент.</para>
          <para>Элементы <sgmltag>dsContext</sgmltag>:<itemizedlist>
              <listitem>
                <para><sgmltag>datasource</sgmltag> - определяет источник данных, содержащий единственный экземпляр сущности. </para>
                <para>Атрибуты:<itemizedlist>
                    <listitem>
                      <para><sgmltag>id</sgmltag> - идентификатор источника, должен быть уникальным  для данного <code>DsContext</code>.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>class</sgmltag> - Java класс сущности, которая будет содержаться в данном источнике</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>view</sgmltag> - имя <link linkend="views">представления</link> сущности. Если источник сам загружает экземпляры, то это представление будет использовано при загрузке. В противном случае это представление сигнализирует внешним механизмам о том, как нужно загрузить сущность для данного источника.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>allowCommit</sgmltag> - при установке значения <code>false</code> метод <code>isModified()</code> данного источника всегда возвращает <code>false</code>, а метод <code>commit()</code> ничего не делает. Таким образом, изменения содержащихся в источнике сущностей игнорируются. По умолчанию <code>true</code>, т.е. изменения отслеживаются и могут быть сохранены.</para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>datasourceClass</sgmltag> - нестандартный класс реализации источника данных, если необходим.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><sgmltag>collectionDatasource</sgmltag> - определяет источник данных, содержащий коллекцию экземпляров.</para>
                <para>Атрибуты <sgmltag>collectionDatasource</sgmltag>:<itemizedlist>
                    <listitem>
                      <para><sgmltag>refreshMode</sgmltag> - режим обновления источника, по умолчанию <code>ALWAYS</code>. В режиме <code>NEVER</code> при вызове <code>refresh()</code> источник не производит загрузку данных, а только переходит в состояние <code>Datasource.State.VALID</code>, оповещает слушателей и сортирует имеющиеся в нем экземпляры. Режим <code>NEVER</code> удобен, если необходимо программно заполнить <code>CollectionDatasource</code> предварительно загруженными или созданными сущностями. Например:<programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
    Set&lt;Customer&gt; entities = (Set&lt;Customer&gt;) params.get(&quot;customers&quot;);
    for (Customer entity : entities) {
        customersDs.includeItem(entity);
    }
    customersDs.refresh();
}</programlisting></para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>softDeletion</sgmltag> - значение <code>false</code> отключает режим <link linkend="soft_deletion">мягкого удаления</link> при загрузке сущностей, т.е. будут загружены также и удаленные экземпляры. По умолчанию <code>true</code>.</para>
                    </listitem>
                  </itemizedlist></para>
                <para>Элементы <sgmltag>collectionDatasource</sgmltag>:<itemizedlist>
                    <listitem>
                      <para><sgmltag>query</sgmltag> - <link linkend="datasource_query">запрос</link> для загрузки сущностей</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><sgmltag>groupDatasource</sgmltag> - полностью аналогичен <sgmltag>collectionDatasource</sgmltag>, но создает реализацию источника данных, пригодную для использования совместно с компонентом <code>
                    <link linkend="gui_GroupTable">GroupTable</link>
                  </code>.</para>
              </listitem>
              <listitem>
                <para><sgmltag>hierarchicalDatasource</sgmltag> - аналогичен <sgmltag>collectionDatasource</sgmltag>, и создает реализацию источника данных, пригодную для использования совместно с компонентами <code>
                    <link linkend="gui_Tree">Tree</link>
                  </code> и <code>
                    <link linkend="gui_TreeTable">TreeTable</link>
                  </code>.</para>
                <para>Специфическим атрибутом является <sgmltag>hierarchyProperty</sgmltag>, задающий имя атрибута сущности, по которому строится иерархия.</para>
              </listitem>
            </itemizedlist></para>
          <para>Класс реализации источника выбирается неявно на основе имени элемента XML и, как было сказано выше, взаимного расположения элементов. Однако если необходимо применить нестандартный источник данных, его класс может быть явно указан в атрибуте <code>datasourceClass</code>. </para>
        </section>
        <section>
          <title>Программное создание</title>
          <para>При необходимости создать источник данных в Java коде рекомендуется воспользоваться специальным классом <code>DsBuilder</code>. </para>
          <para>Экземпляр <code>DsBuilder</code> параметризуется цепочкой вызовов его методов в стиле текучего (fluent) интерфейса. Если установлены параметры <code>master</code> и <code>property</code>, то в результате будет создан <code>NestedDatasource</code>, в противном случае - <code>Datasource</code> или <code>CollectionDatasource</code>.</para>
          <para>Пример:<programlisting language="java">CollectionDatasource ds = new DsBuilder(getDsContext())
        .setJavaClass(Order.class)
        .setViewName(View.LOCAL)
        .setId(&quot;ordersDs&quot;)
        .buildCollectionDatasource();</programlisting></para>
        </section>
        <section>
          <title>Собственные классы реализации</title>
          <para>Как правило, нестандартная реализация источника данных требуется для изменения процесса загрузки коллекции сущностей. При создании класса такого источника рекомендуется унаследовать его от <code>CollectionDatasourceImpl</code>, либо от <code>GroupDatasourceImpl</code> или <code>HierarchicalDatasourceImpl</code>, и переопределить метод <code>loadData()</code>.</para>
          <para>Пример:<programlisting language="java">public class MyDatasource extends CollectionDatasourceImpl&lt;SomeEntity, UUID&gt; {

    private SomeService someService = AppBeans.get(SomeService.NAME);

    @Override
    protected void loadData(Map&lt;String, Object&gt; params) {
        detachListener(data.values());
        data.clear();

        for (SomeEntity entity : someService.getEntities()) {
            data.put(entity.getId(), entity);
            attachListener(entity);
        }
    }
}</programlisting></para>
          <para>Здесь <code>data</code> - поле базового класса, хранящее коллекцию загруженных экземпляров. Методы базового класса <code>detachListener()</code> и <code>attachListener()</code> управляют назначением на загруженные сущности слушателя, который оповещает источник данных об изменениях в полях экземпляров.</para>
          <para>Для создания нестандартного источника данных декларативным способом необходимо указать класс в атрибуте <sgmltag>datasourceClass</sgmltag> элемента XML. При программном создании через <code>DsBuilder</code> класс источника указывается вызовом <code>setDsClass()</code>.</para>
        </section>
      </section>
      <section id="datasource_query">
        <title>Запросы в CollectionDatasourceImpl</title>
        <para>Класс <code> CollectionDatasourceImpl</code> и его наследники <code>GroupDatasourceImpl</code>, <code>HierarchicalDatasourceImpl</code> являются стандартной реализацией источников данных, работающих с коллекциями независимых экземпляров сущностей. Эти источники загружают данные через <code>DataService</code>, отправляя на <structname>Middleware</structname> запрос на языке JPQL. Далее рассматриваются особенности формирования таких запросов.</para>
        <section id="datasource_query_results">
          <title>Возвращаемые значения</title>
          <para>Запрос должен возвращать сущности того типа, который указан при создании источника данных. Тип сущности при декларативном создании указывается в атрибуте <sgmltag>class</sgmltag> элемента XML, при создании через <code>DsBuilder</code> - в методе <code>setJavaClass()</code> или <code>setMetaClass()</code>.</para>
          <para>Кроме того, тип объекта в предложении <code>from</code> запроса должен соответствовать типу источника. Это необходимо для проведения автоматических трансформаций запроса при наложении ограничений безопасности и др.</para>
          <para>Например, запрос источника данных типа <code>Customer</code> может выглядеть следующим образом:<programlisting language="sql">select c from sales$Customer c</programlisting></para>
          <para>Примеры недопустимых для источника типа <code>Customer</code> запросов:<programlisting language="sql">select c.id, c.name from sales$Customer c /* неверно - возвращает отдельные поля, а не весь объект Customer */

select o.customer from sales$Order o /* неверно - тип from (Order) отличается от типа результата (Customer) */</programlisting></para>
        </section>
        <section id="datasource_query_params">
          <title>Параметры запроса</title>
          <para>JPQL-запрос в источнике данных может содержать параметры нескольких видов. Вид параметра определяется по префиксу имени параметра. Префиксом является часть имени до знака &quot;$&quot;. Интерпретация имени после &quot;$&quot; рассматривается ниже.</para>
          <itemizedlist>
            <listitem>
              <para>Префикс <code>ds</code>. </para>
              <para>Значением параметра являются данные другого источника данных, зарегистрированного в этом же <code>DsContext</code>. Например:<programlisting language="xml">&lt;collectionDatasource id=&quot;customersDs&quot; class=&quot;com.sample.sales.entity.Customer&quot; view=&quot;_local&quot;&gt;
    &lt;query&gt;
        select c from sales$Customer c
    &lt;/query&gt;
&lt;/collectionDatasource&gt;

&lt;collectionDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;&gt;
    &lt;query&gt;
        select o from sales$Order o where o.customer.id = :ds$customersDs
    &lt;/query&gt;
&lt;/collectionDatasource&gt;</programlisting></para>
              <para>В данном случае параметром запроса источника данных <code>ordersDs</code> будет текущий экземпляр сущности, находящийся в источнике данных <code>customersDs</code>. </para>
              <para>При использовании параметров с префиксом <code>ds</code> между источниками данных автоматически создаются зависимости, приводящие к обновлению источника если меняется значение его параметра. В приведенном примере если изменяется выбранный Покупатель, автоматически обновляется список его Заказов. </para>
              <para>Обратите внимание, что в примере запроса с параметром  левой частью оператора сравнения является значение идентификатора <code>o.customer.id</code>, а правой - экземпляр <code>Customer</code>, содержащийся в источнике <code>customersDs</code>. Такое сравнение допустимо, так как при выполнении запроса на <structname>Middleware</structname> реализация интерфейса <link linkend="query">
                  <code>Query</code>
                </link>, присваивая значения параметрам запроса, автоматически подставляет ID сущности вместо переданного экземпляра сущности.</para>
              <para>В имени параметра после префикса и имени источника может быть также указан путь по графу сущностей к атрибуту, из которого нужно взять значение, например: <programlisting language="xml">&lt;query&gt;
    select o from sales$Order o where o.customer.id = :ds$customersDs.id
&lt;/query&gt;</programlisting></para>
              <para>или<programlisting language="xml">&lt;query&gt;
    select o from sales$Order o where o.tagName = :ds$customersDs.group.tagName
&lt;/query&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Префикс <code>custom</code>. </para>
              <para>Значение параметра будет взято из объекта <code>Map&lt;String, Object&gt;</code>, переданного в метод <code>refresh()</code> источника данных. Например:<programlisting language="xml">&lt;collectionDatasource id=&quot;ordersDs&quot; class=&quot;com.sample.sales.entity.Order&quot; view=&quot;_local&quot;&gt;
    &lt;query&gt;
        select o from sales$Order o where o.number = :custom$number
    &lt;/query&gt;
&lt;/collectionDatasource&gt;</programlisting><programlisting language="java">Map&lt;String, Object&gt; params = new HashMap&lt;&gt;();
params.put(&quot;number&quot;, &quot;1&quot;);
ordersDs.refresh(params);</programlisting></para>
              <para>Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом <code>ds</code>. Путь по графу сущностей в имени параметра в данном случае не поддерживается. </para>
            </listitem>
            <listitem>
              <para>Префикс <code>param</code>. </para>
              <para>Значение параметра будет взято из объекта <code>Map&lt;String, Object&gt;</code>, переданного при открытии экрана в метод <code>init()</code> <link linkend="screen_controller">контроллера</link>. </para>
              <para>Приведение экземпляра при необходимости к его идентификатору осуществляется аналогично параметрам с префиксом <code>ds</code>. Поддерживается путь к атрибуту по графу сущностей в имени параметра. </para>
            </listitem>
            <listitem>
              <para>Префикс <code>component</code>. </para>
              <para>Значением параметра будет текущее значение визуального компонента, путь к которому указан в имени параметра. Например:<programlisting language="xml">&lt;query&gt;
    select o from sales$Order o where o.number = :component$filter.orderNumberField
&lt;/query&gt;</programlisting></para>
              <para>Путь к компоненту должен включать все вложенные <link linkend="frame">фреймы</link>.
</para>
              <para>Приведение экземпляра при необходимости к его идентификатору аналогично параметрам <code>ds</code>.
Поддерживается путь к атрибуту по графу сущностей в имени параметра как продолжение пути к компоненту. </para>
            </listitem>
            <listitem>
              <para>Префикс <code>session</code>. </para>
              <para>Значением параметра будет значение атрибута <link linkend="userSession">пользовательской сессии</link>, указанного в имени параметра.</para>
              <para>Значение извлекается методом <code>UserSession.getAttribute()</code>, поэтому поддерживаются также  предопределенные имена атрибутов сессии: <itemizedlist>
                  <listitem>
                    <para><code>userId</code> - ID текущего зарегистрированного или замещенного пользователя;</para>
                  </listitem>
                  <listitem>
                    <para><code>userLogin</code> - логин текущего зарегистрированного или замещенного пользователя в нижнем регистре.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Пример:<programlisting language="xml">&lt;query&gt;
    select o from sales$Order o where o.createdBy = :session$userLogin
&lt;/query&gt;</programlisting></para>
              <para>Приведение экземпляра при необходимости к его идентификатору аналогично параметрам <code>ds</code>.
Путь по графу сущностей в имени параметра в данном случае не поддерживается. </para>
            </listitem>
          </itemizedlist>
          <warning>
            <para>Если значение параметра не найдено по правилам, задаваемым префиксом, для данного параметра устанавливается значение <code>null</code>. То есть если, например,  в запросе указан параметр с именем <code>param$some_name</code>, а в мэп параметров экрана нет ключа <code>some_name</code>, то для параметра <code>param$some_name</code> устанавливается значение <code>null</code>.</para>
          </warning>
        </section>
        <section id="datasource_query_filter">
          <title>Фильтр запроса</title>
          <para>Запрос источника данных может быть модифицирован во время работы приложения, в зависимости от вводимых пользователем условий, что позволяет эффективно фильтровать данные на уровне выборки из БД.</para>
          <para>Простейший способ обеспечения такой возможности - подключение к источнику данных специального визуального компонента <link linkend="gui_Filter">Filter</link>.</para>
          <para>Если по какой-то причине применение универсального фильтра нежелательно, можно встроить в текст запроса специальную разметку на XML, позволяющую сформировать итоговый запрос в зависимости от значений, введенных пользователем в произвольные визуальные компоненты экрана.</para>
          <para>В таком фильтре могут быть использованы следующие элементы:<itemizedlist>
              <listitem>
                <para><sgmltag>filter</sgmltag> - корневой элемент фильтра. Может непосредственно содержать  только одно условие.<itemizedlist>
                    <listitem>
                      <para><sgmltag>and</sgmltag>, <sgmltag>or</sgmltag> - логические условия, могут содержать любое количество других условий и предложений. </para>
                    </listitem>
                    <listitem>
                      <para><sgmltag>c</sgmltag> - предложение на JPQL, которое добавляется в секцию <code>where</code>. Содержит только текст и опционально атрибут <sgmltag>join</sgmltag>, значение которого будет добавлено в соответствующее место запроса, если добавляется данное предложение <code>where</code>. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
          <para>Условия и предложения добавляются в итоговый запрос, только если присутствующие внутри них параметры получили значения, т.е. не равны <code>null</code>. </para>
          <para>Пример:<programlisting language="xml">&lt;query&gt;
    select distinct d from app$GeneralDoc d
    &lt;filter&gt;
        &lt;or&gt;
            &lt;and&gt;
                &lt;c join=&quot;, app$DocRole dr&quot;&gt;dr.doc.id = d.id and d.processState = :custom$state&lt;/c&gt;
                &lt;c&gt;d.barCode like :component$barCodeFilterField&lt;/c&gt;
            &lt;/and&gt;
            &lt;c join=&quot;, app$DocRole dr&quot;&gt;dr.doc.id = d.id and dr.user.id = :custom$initiator&lt;/c&gt;
        &lt;/or&gt;
    &lt;/filter&gt;
&lt;/query&gt;</programlisting></para>
          <para>В данном случае если в метод <code>refresh()</code> источника данных переданы параметры <code>state</code> и <code>initiator</code>, а в визуальном компоненте <code>barCodeFilterField</code> установлено некоторое значение, то итоговый запрос примет вид:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr 
where 
  (
    (dr.doc.id = d.id and d.processState = :custom$state) 
    and 
    (d.barCode like :component$barCodeFilterField)
  ) 
  or 
  (dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
          <para>Если же, к примеру, компонент <code>barCodeFilterField</code> пуст, а в <code>refresh()</code> передан только параметр <code>initiator</code>, то запрос получится следующим:<programlisting>select distinct d from app$GeneralDoc d, app$DocRole dr 
where   
  (dr.doc.id = d.id and dr.user.id = :custom$initiator)</programlisting></para>
        </section>
        <section id="datasource_query_case_insensitive">
          <title>Поиск подстроки без учета регистра</title>
          <para>В источниках данных можно использовать особенность выполнения JPQL-запросов, описанную для интерфейса <code>
              <link linkend="query">Query</link>
            </code> уровня <structname>Middleware</structname>: для удобного формирования условия поиска без учета регистра символов и по любой части строки можно использовать префикс <code>(?i)</code>. Однако, в связи с тем,  что значение параметра обычно передается неявно, имеются следующие отличия: <itemizedlist>
              <listitem>
                <para>Префикс <code>(?i)</code> нужно указывать не в значении, а перед именем параметра.</para>
              </listitem>
              <listitem>
                <para>Значение параметра будет автоматически переведено в нижний регистр.</para>
              </listitem>
              <listitem>
                <para>Если в значении параметра  отсутствуют символы <code>%</code>, то они будут добавлены в начало и конец.</para>
              </listitem>
            </itemizedlist></para>
          <para>Для примера рассмотрим обработку следующего запроса:<programlisting>select c from sales$Customer c where c.name like :(?i)component$customerNameField</programlisting></para>
          <para>В данном случае значение параметра, взятое из компонента <code>customerNameField</code>, будет переведено в нижний регистр и обрамлено символами <code>%</code>, а затем в базе данных будет выполнен SQL запрос с условием вида <code>lower(C.NAME) like ?</code></para>
          <para>Следует иметь в виду, что при таком поиске индекс, созданный в БД по полю <code>NAME</code>, не используется. </para>
        </section>
      </section>
      <section id="datasource_listeners">
        <title>Слушатели источников данных</title>
        <para>Слушатели <link linkend="datasources">источников данных</link> (datasource listeners)  позволяют получать оповещения об изменении состояния источников данных и экземпляров сущностей, в них находящихся.</para>
        <para>Для регистрации слушателей используются методы <code>Datasource.addListener()</code>, <code>Datasource.removeListener()</code>. Пример регистрации слушателя в <link linkend="screen_controller">контроллере экрана</link>:<programlisting language="java">@Inject
private Datasource&lt;Customer&gt; customerDs;
...
public void init(Map&lt;String, Object&gt; params) {
    ...
    customerDs.addListener(new DatasourceListener&lt;Customer&gt;() {
        // listener methods implementation
    });
}</programlisting></para>
        <para>Существует два интерфейса слушателей источников данных: <code>DatasourceListener</code> и <code>CollectionDatasourceListener</code>. Первый можно использовать для регистрации в любых источниках данных, второй - только в реализующих <code>CollectionDatasource</code>. Как правило, на практике требуется получать не все оповещения от слушателя, а только некоторые. Поэтому удобно вместо реализации самих интерфейсов слушателей использовать классы-адаптеры <code>DsListenerAdapter</code> и <code>CollectionDsListenerAdapter</code>, содержащие пустые реализации всех методов соответствующих интерфейсов.</para>
        <para>Рассмотрим методы <code>DatasourceListener</code>:<itemizedlist>
            <listitem>
              <para><code>valueChanged()</code> - объявление этого метода наследуется от базового интерфейса <code>ValueListener</code>. Данный метод слушателя вызывается, если изменилось значение какого-либо атрибута сущности, находящейся в данный момент в источнике. В метод передается сам измененный экземпляр, имя измененного атрибута, старое и новое значение.</para>
              <para>Оповещение <code>valueChanged()</code> можно использовать для действий в ответ на изменение пользователем сущности из UI, то есть редактирования полей ввода.
В следующем примере гипотетический метод <code>updateSettings()</code> будет вызван при изменении значения атрибута <code>active</code>, и в него будет передано новое значение этого атрибута: <programlisting language="java">@Inject
private Datasource&lt;Customer&gt; customerDs;

public void init(Map&lt;String, Object&gt; params) {
    ...
    customerDs.addListener(new DsListenerAdapter&lt;Customer&gt;() {
        @Override
        public void valueChanged(Customer source, String property, Object prevValue, Object value) {
            if (&quot;active&quot;.equals(property)) {
                boolean active = BooleanUtils.isTrue((Boolean) value); // converting null to false
                updateSettings(active);
            }
        }
    });
}</programlisting></para>
            </listitem>
            <listitem><para><code>itemChanged()</code> - вызывается при смене выбранного экземпляра, возвращаемого методом <code>getItem()</code>.</para><para>Для <code>Datasource</code> это происходит при установке другого экземпляра (или <code>null</code>) методом <code>setItem()</code>.</para><para>Для <code>CollectionDatasource</code> данное оповещение вызывается, когда в связанном визуальном компоненте меняется выделенный элемент. Например, это может быть выделенная строка таблицы, элемент дерева, или выделенный элемент выпадающего списка.</para>Пример использования оповещения <code>itemChanged()</code>для управления состоянием действия таблицы:<programlisting language="java">@Inject
protected CollectionDatasource&lt;Customer, UUID&gt; customersDs;

@Named(&quot;customersTable.remove&quot;)
protected RemoveAction removeAction;

public void init(Map&lt;String, Object&gt; params) {
    ...
    customersDs.addListener(new DsListenerAdapter&lt;Customer&gt;() {
        @Override
        public void itemChanged(Datasource&lt;Customer&gt; ds, Customer prevItem, Customer item) {
            removeAction.setEnabled(canCustomerBeDeleted(item));
        }
    });
}</programlisting></listitem>
            <listitem>
              <para><code>stateChanged()</code> - вызывается при изменении состояния источника данных. Источник данных может находиться в одном из трех состояний, соответствующих перечислению <code>Datasource.State</code>:<itemizedlist>
                  <listitem>
                    <para><code>NOT_INITIALIZED</code> - источник только что создан.</para>
                  </listitem>
                  <listitem>
                    <para><code>INVALID</code> - создан весь <code>
                        <link linkend="dsContext">DsContext</link>
                      </code>, к которому относится данный источник.</para>
                  </listitem>
                  <listitem>
                    <para><code>VALID</code> - источник данных в рабочем состоянии: <code>Datasource</code> содержит экземпляр сущности или <code>null</code>, <code>CollectionDatasource</code> - коллекцию экземпляров или пустую коллекцию.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Получение оповещения об изменении состояния источника может быть актуально для сложных <link linkend="screen_edit">редакторов</link>, состоящих из нескольких <link linkend="frame">фреймов</link>, где сложно отследить момент проставления редактируемой сущности в источник. В этом случае можно использовать оповещение <code>stateChanged()</code> для отложенной инициализации некоторых элементов экрана: <programlisting language="java">@Inject
protected CollectionPropertyDatasourceImpl&lt;CategoryAttribute, UUID&gt; categoryAttrsDs;

categoryAttrsDs.addListener(new DsListenerAdapter&lt;CategoryAttribute&gt;() {
    @Override
    public void stateChanged(Datasource ds, Datasource.State prevState, Datasource.State state) {
        if (state != Datasource.State.VALID) return;
        initDataTypeColumn();
        initDefaultValueColumn();
    }
});</programlisting></para>
            </listitem>
          </itemizedlist></para>
        <para>Интерфейс <code>CollectionDatasourceListener</code> добавляет еще один метод: <itemizedlist>
            <listitem>
              <para><code>collectionChanged()</code> - вызывается при изменении коллекции сущностей, хранящейся в источнике данных. В метод передается тип изменения: <code>REFRESH</code>,
<code> CLEAR</code>,
<code> ADD</code>,
<code> REMOVE</code>,
<code> UPDATE</code>.</para>
              <para>Пример слушателя, вызывающего пересчет стоимости поездки при изменении адреса остановки (сущность <code>Stop</code>) или количества остановок:<programlisting language="java">protected class StopDsListener extends CollectionDsListenerAdapter&lt;Stop&gt; {
    @Override
    public void valueChanged(Stop source, String property, Object prevValue, Object value) {
        // existing stop address changed
        if (&quot;address&quot;.equals(property)) {
            fireRouteChanged();
        }
    }

    @Override
    public void collectionChanged(CollectionDatasource ds, Operation operation) {
        // stop was added or removed
        fireRouteChanged();
    }
    
    private void fireRouteChanged() {
        // journey route has changed, need to recalculate price, journey time, pickup time delay etc.
    }
}</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section id="dsContext">
        <title>DsContext</title>
        <para>Все созданные декларативно источники данных  регистрируются в объекте <code>DsContext</code> экрана. Ссылку на <code>DsContext</code> можно получить методом <code>getDsContext()</code> контроллера экрана, либо инжекцией в поле класса.</para>
        <para><code>DsContext</code> решает следующие задачи:<orderedlist>
            <listitem>
              <para>Позволяет организовать зависимости между источниками данных, когда при навигации по одному источнику (т.е. при изменении &quot;текущего&quot; экземпляра методом <code>setItem()</code>) обновляется связанный источник. Такие зависимости дают возможность в экранах легко организовывать master-detail связи между визуальными компонентами.</para>
              <para>Зависимости между источниками организуются с помощью <link linkend="datasource_query">параметров запросов</link> с префиксом <code>ds$</code>.</para>
            </listitem>
            <listitem>
              <para>Позволяет собрать все измененные экземпляры сущностей и отправить их на <structname>Middleware</structname> в одном вызове <code>DataService.commit()</code>, т.е. сохранить в базе данных в одной транзакции. </para>
              <para>В качестве примера предположим, что некоторый экран позволяет редактировать экземпляр сущности <code>Order</code> и коллекцию принадлежащих ему экземпляров <code>OrderLine</code>. Экземпляр <code>Order</code> находится в <code>Datasource</code>, коллекция <code>OrderLine</code> - во вложенном <code>CollectionDatasource</code>, созданном по атрибуту <code>Order.lines</code>. Допустим, пользователь изменил какой-то атрибут <code>Order</code> и создал новый экземпляр <code>OrderLine</code>. Тогда при коммите экрана в <code>
                  <link linkend="dataService">DataService</link>
                </code> будут одновременно отправлены два экземпляра - измененный <code>Order</code> и новый <code>OrderLine</code>. Далее, они вместе попадут в один <link linkend="entityManager">персистентный контекст</link> и при коммите транзакции сохранятся в БД. Разумеется, экземпляр <code>OrderLine</code> содержится также в коллекции <code>Order.lines</code>, но если не передавать его в персистентный контекст независимо, то потребуется установка каскадности сохранения между <code>Order</code> и <code>OrderLines</code> на уровне ORM. Жесткие отношения каскадности на уровне ORM иногда вызывают нежелательные последствия в неожиданных местах, поэтому лучше их избегать, что и обеспечивает описываемый механизм <code>DsContext</code>.</para>
              <para>В результате коммита <code>DsContext</code> получает от  <structname>Middleware</structname> набор сохраненных экземпляров (в случае оптимистической блокировки у них, как минимум, увеличено значение атрибута <code>version</code>), и устанавливает эти экземпляры в источниках данных взамен устаревших. Это позволяет сразу после коммита работать со свежими экземплярами без необходимости лишнего обновления источников данных, связанного с запросами к <structname>Middleware</structname> и базе данных.</para>
            </listitem>
            <listitem>
              <para>Объявляет слушателя <code>DsContext.CommitListener</code>, позволяющего получать оповещения перед коммитом измененных экземпляров и после него. Перед коммитом можно дополнить коллекцию отправляемых в <code>
                  <link linkend="dataService">DataService</link>
                </code> на <structname>Middleware</structname> экземпляров, тем самым обеспечив сохранение в той же транзакции произвольных сущностей. После коммита можно получить коллекцию вернувшихся из <code>DataService</code> сохраненных экземпляров.</para>
              <para>Данный механизм необходим, если некоторые сущности, с которыми работает экран, находятся не под управлением источников данных, а создаются и изменяются непосредственно в коде контроллера. Например, визуальный компонент <code>
                  <link linkend="gui_FileUploadField">FileUploadField</link>
                </code> после загрузки файла создает новый экземпляр сущности <code>FileDescriptor</code>, который можно сохранить вместе с другими сущностями экрана именно таким способом - добавив в <code>CommitContext</code> в методе <code>DsContext.CommitListener.beforeCommit()</code>.</para>
              <para><code>DsContext.CommitListener</code> имеет адаптер <code>DsContext.CommitListenerAdapter</code>, который удобно использовать при необходимости определить только один метод.</para>
              <para>В следующем примере новый экземпляр <code>Customer</code> будет отправлен на <structname>Middleware</structname> и сохранен в БД вместе с остальными измененными сущностями экрана при его коммите:<programlisting language="java">protected Customer customer;

protected void createNewCustomer() {
    customer = new Customer();
    customer.setName(&quot;John Doe&quot;);
}

public void init(Map&lt;String, Object&gt; params) {
    getDsContext().addListener(new DsContext.CommitListenerAdapter() {
        @Override
        public void beforeCommit(CommitContext context) {
            if (customer != null)
                context.getCommitInstances().add(customer);
        }
    });
}</programlisting></para>
            </listitem>
          </orderedlist></para>
      </section>
      <section id="dataSupplier">
        <title>DataSupplier</title>
        <para><code>DataSupplier</code> - интерфейс, через который код  универсального пользовательского интерфейса (в том числе и источники данных) обращается к <structname>Middleware</structname> для загрузки и сохранения сущностей. Он расширяет интерфейс <code>
            <link linkend="dataService">DataService</link>
          </code> и добавляет следующие полезные прикладному коду методы:<itemizedlist>
            <listitem>
              <para><code>reload()</code> - перезагрузить экземпляр сущности с требуемым <link linkend="views">view</link> и другими параметрами</para>
            </listitem>
            <listitem>
              <para><code>commit()</code> - сохранить в БД один экземпляр сущности</para>
            </listitem>
            <listitem>
              <para><code>remove()</code> - удалить из БД один экземпляр сущности.</para>
            </listitem>
          </itemizedlist></para>
        <para>Ссылку на <code>DataSupplier</code> можно получить либо <link linkend="screen_controller_injection">инжекцией</link> в контроллер экрана, либо через экземпляры <code>DsContext</code> или <code>Datasource</code>.</para>
      </section>
    </section>
    <section id="gui_Action">
      <title>Действия. Интерфейс Action</title>
      <para><code>Action</code> − интерфейс, абстрагирующий действие (другими словами, некоторую функцию) от визуального компонента. Он особенно полезен в случаях, когда одно и то же действие может быть вызвано из разных визуальных компонентов. Кроме того, данный интерфейс позволяет снабдить действие дополнительными свойствами, такими как название, признаки доступности и видимости, и другими.</para>
      <para>Рассмотрим методы интерфейса <code>Action</code>:<itemizedlist>
          <listitem>
            <para><code>actionPerform()</code> - вызывается визуальным компонентом, связанным с данным действием. В метод передается экземпляр вызвавшего компонента.</para>
          </listitem>
          <listitem>
            <para><code>getId()</code> - возвращает идентификатор данного действия. Идентификатор обычно устанавливается конструктором класса, реализующего <code>Action</code>, и не меняется на протяжении жизни созданного объекта действия.</para>
          </listitem>
          <listitem>
            <para>методы получения и установки свойств <code>caption</code>, <code>description</code>, <code>shortcut</code>, <code>icon</code>, <code>enabled</code>, <code>visible</code>. Все эти свойства обычно используется связанными визуальными компонентами для установки собственных одноименных свойств.</para>
          </listitem>
          <listitem>
            <para><code>addPropertyChangeListener()</code>, <code>removePropertyChangeListener()</code> - подключение слушателей, реагирующих на изменение вышеупомянутых свойств. Слушатель получает уведомление типа <code>java.beans.PropertyChangeEvent</code>, в котором  содержится имя измененного свойства, его старое и новое значение.</para>
          </listitem>
          <listitem>
            <para><code>refreshState()</code> - метод, который может быть реализован в конкретном классе действия для инициализации вышеупомянутых свойств в соответствии с какими-либо внешними факторами, например правами пользователя. Вызывается обычно в конструкторах имплементирующих классов или из связанных визуальных компонентов.</para>
          </listitem>
          <listitem>
            <para><code>addOwner()</code>, <code>removeOwner()</code>, <code>getOwner()</code>, <code>getOwners()</code> - методы для управления связью действия с визуальными компонентами.</para>
          </listitem>
        </itemizedlist></para>
      <para>Для реализации действий рекомендуется использовать <link linkend="declarative_actions">декларативное создание</link> действий, либо наследоваться от класса <link linkend="abstractAction">AbstractAction</link>. Кроме того, существует набор <link linkend="standard_actions">стандартных действий</link>, применимых для работы с таблицами и компонентами выбора. От стандартных действий также можно наследоваться для модификации их поведения или перехвата событий.</para>
      <para>Визуальные компоненты, связанные с действием, могут быть двух типов:<itemizedlist>
          <listitem>
            <para>Визуальный компонент, содержащий одно действие, реализует интерфейс <code>Component.ActionOwner</code>. Это <link linkend="gui_Button">Button</link> и <link linkend="gui_LinkButton">LinkButton</link>.</para>
            <para>Связь компонента с действием осуществляется путем вызова метода <code>ActionOwner.setAction()</code> компонента. В этот момент компонент заменяет свои свойства на соответствующие свойства действия (подробнее см. описание компонентов). </para>
          </listitem>
          <listitem>
            <para>Визуальный компонент, содержащий несколько действий, реализует интерфейс <code>Component.ActionsHolder</code>. Это <code>Window</code>, <code>IFrame</code>, <link linkend="gui_Table">Table</link> и ее наследники, <link linkend="gui_Tree">Tree</link>, <link linkend="gui_PopupButton">PopupButton</link>, <link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>.</para>
            <para>Действия добавляются компоненту вызовом метода <code>ActionsHolder.addAction()</code>. Реализация этого метода в компоненте проверяет, нет ли уже в нем действия с таким же идентификатором. Если есть, то имеющееся действие будет заменено на новое переданное. Поэтому можно, например, декларировать стандартное действие в дескрипторе экрана, а затем в контроллере создать новое с переопределенными методами и добавить компоненту.</para>
          </listitem>
        </itemizedlist></para>
      <section id="declarative_actions">
        <title>Декларативное создание действий</title>
        <para>В XML-дескрипторе экрана для любого компонента, реализующего интерфейс <code>Component.ActionsHolder</code>, в том числе для всего экрана или фрейма, может быть задан набор <link linkend="gui_Action">действий</link>. Делается это в элементе <code>actions</code>, который содержит вложенные элементы <code>action</code>.</para>
        <para>Элемент <code>action</code> может иметь следующие атрибуты:<itemizedlist>
            <listitem>
              <para><code>id</code> − идентификатор, должен быть уникален в рамках данного компонента <code>ActionsHolder</code>.</para>
            </listitem>
            <listitem>
              <para><code>caption</code> - название действия.</para>
            </listitem>
            <listitem>
              <para><code>description</code> - описание действия.</para>
            </listitem>
            <listitem>
              <para><code>enable</code> - признак доступности действия (<code>true</code> / <code>false</code>).</para>
            </listitem>
            <listitem>
              <para><code>icon</code> - значок действия.</para>
            </listitem>
            <listitem>
              <para><code>invoke</code> -  имя вызываемого метода контроллера. Метод должен быть <code>public</code>, не возвращать результата и либо не иметь аргументов, либо иметь один аргумент типа <code>Component</code>. Если метод имеет аргумент <code>Component</code>, то при вызове в него будет передан экземпляр визуального компонента, запустившего данное действие.</para>
            </listitem>
            <listitem>
              <para><code>shortcut</code> -  комбинация клавиш для вызова. Возможные модификаторы - <code>ALT</code>, <code>CTRL</code>, <code>SHIFT</code> - отделяются символом &quot;-&quot;. Например:
<keycap>ALT-CTRL-C</keycap>.</para>
            </listitem>
            <listitem>
              <para><code>visible</code> - признак видимости действия (<code>true</code> / <code>false</code>).</para>
            </listitem>
          </itemizedlist></para>
        <para>Рассмотрим примеры декларативного объявления действий.<itemizedlist>
            <listitem>
              <para>Объявление действий на уровне экрана:<programlisting language="xml">&lt;window ...&gt;
    &lt;dsContext/&gt;

    &lt;actions&gt;
        &lt;action id=&quot;sayHelloAction&quot; caption=&quot;msg://sayHello&quot; shortcut=&quot;ALT-T&quot; invoke=&quot;sayHello&quot;/&gt;
    &lt;/actions&gt;

    &lt;layout&gt;
        &lt;button action=&quot;sayHelloAction&quot;/&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting><programlisting language="java">// controller

public void sayHello(Component component) {
    showNotification(&quot;Hello!&quot;, NotificationType.TRAY);
}</programlisting>Здесь объявляется действие с идентификатором <code>sayHelloAction</code> и  названием из <link linkend="message_packs">пакета сообщений</link>. С этим действием связывается кнопка, заголовок которой будет установлен в название действия. Действие вызовет метод <code>sayHello()</code> контроллера при нажатии на кнопку, а также при нажатии комбинации клавиш <keycap>ALT-T</keycap>, если в данный момент экран принимает фокус ввода.</para>
            </listitem>
            <listitem>
              <para>Объявление действий для <link linkend="gui_PopupButton">PopupButton</link>:<programlisting language="xml">&lt;popupButton caption=&quot;Say something&quot;&gt;
   &lt;actions&gt;
      &lt;action id=&quot;helloAction&quot; caption=&quot;Say hello&quot; invoke=&quot;sayHello&quot;/&gt;
      &lt;action id=&quot;goodbyeAction&quot; caption=&quot;Say goodbye&quot; invoke=&quot;sayGoodbye&quot;/&gt;
   &lt;/actions&gt;
&lt;/popupButton&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Объявление действий для <link linkend="gui_Table">Table</link>:<programlisting language="xml">&lt;table id=&quot;usersTable&quot; width=&quot;100%&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;create&quot;/&gt;
        &lt;action id=&quot;edit&quot;/&gt;
        &lt;action id=&quot;copy&quot; caption=&quot;msg://copy&quot; icon=&quot;icons/copy.png&quot;
                invoke=&quot;copy&quot; trackSelection=&quot;true&quot;/&gt;
        &lt;action id=&quot;changePassw&quot; caption=&quot;msg://changePassw&quot; icon=&quot;icons/change-pass.png&quot; 
                invoke=&quot;changePassword&quot; trackSelection=&quot;true&quot;/&gt;
    &lt;/actions&gt;
    &lt;buttonsPanel&gt;
        &lt;button action=&quot;usersTable.create&quot;/&gt;
        &lt;button action=&quot;usersTable.edit&quot;/&gt;
        &lt;button action=&quot;usersTable.copy&quot;/&gt;
        &lt;button action=&quot;usersTable.changePassw&quot;/&gt;
    &lt;/buttonsPanel&gt;
    &lt;rowsCount/&gt;
    &lt;columns&gt;
        &lt;column id=&quot;login&quot;/&gt;
        ...
    &lt;/columns&gt;
    &lt;rows datasource=&quot;usersDs&quot;/&gt;
&lt;/table&gt;</programlisting>Здесь помимо <link linkend="standard_actions">стандартных действий</link> таблицы <code>create</code> и  <code>edit</code>  объявлены  действия <code>copy</code> и <code>changePassw</code>, вызывающие соответствующие методы контроллера. Для этих действий указан также атрибут <code>trackSelection=&quot;true&quot;</code>, в результате чего действие и связанная с ним кнопка становятся недоступными, если в таблице не выбрана ни одна строка. Это удобно, если действие предназначено для выполнения над текущей выбранной строкой таблицы. </para>
              <para>Для действий <code>create</code> и <code>edit</code> можно указать дополнительный атрибут <code>openType</code> для указания режима открытия экрана редактирования, как описано для метода <code>setOpenType()</code> класса <link linkend="createAction">CreateAction</link>.</para>
            </listitem>
            <listitem>
              <para>Объявление действий для <link linkend="gui_PickerField">PickerField</link>:<programlisting language="xml">&lt;pickerField id=&quot;colourField&quot; datasource=&quot;carDs&quot; property=&quot;colour&quot;/&gt;
    &lt;actions&gt;
        &lt;action id=&quot;lookup&quot;/&gt;
        &lt;action id=&quot;show&quot; icon=&quot;icons/show.png&quot;
                invoke=&quot;showColour&quot; caption=&quot;&quot; description=&quot;Show colour&quot;/&gt;
    &lt;/actions&gt;
&lt;/pickerField&gt;</programlisting>В данном примере для  компонента <code>PickerField</code> объявлено <link linkend="standard_actions">стандартное действие</link> <code>lookup</code> и действие <code>show</code>, вызывающее метод <code>showColour()</code> контроллера. Так как в кнопках <code>PickerField</code>, отображающих действия, используются значки, а не надписи, атрибут <code>caption</code> явно установлен в пустую строку, иначе названием действия и заголовком кнопки стал бы идентификатор действия. Атрибут <code>description</code> позволяет отображать всплывающую подсказку при наведении мыши на кнопку действия.</para>
            </listitem>
          </itemizedlist></para>
        <para>Ссылки на любые декларативно объявленные действия можно получить в контроллере экрана либо непосредственно путем <link linkend="screen_controller_injection">инжекции</link>, либо из компонентов, реализующих интерфейс <code>Component.ActionsHolder</code>. Это может понадобиться для программной установки свойств действия. Например:<programlisting language="java">@Named(&quot;carsTable.create&quot;)
private CreateAction createAction;

@Named(&quot;carsTable.copy&quot;)
private Action copyAction;

@Inject
private PickerField colourField;

@Override
public void init(Map&lt;String, Object&gt; params) {
    Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
    values.put(&quot;type&quot;, CarType.PASSENGER);
    createAction.setInitialValues(values);

    copyAction.setEnabled(false);

    Action showAction = colourField.getAction(&quot;show&quot;);
    showAction.setEnabled(false);
}</programlisting></para>
      </section>
      <section id="standard_actions">
        <title>Стандартные действия</title>
        <para>Стандартные <link linkend="gui_Action">действия</link> - это классы, имплементирующие интерфейс <code>Action</code>, и предназначенные для решения типовых задач, таких как вызов экрана редактирования для сущности, выбранной в таблице. Стандартные действия имеют строго определенные идентификаторы, поэтому для декларативного объявления некоторого стандартного действия достаточно указать его идентификатор. </para>
        <para>Существует два вида стандартных действий:<itemizedlist>
            <listitem>
              <para><link linkend="list_actions">Действия с коллекцией</link> сущностей, отображаемой в  таблице или дереве.</para>
            </listitem>
            <listitem>
              <para><link linkend="picker_actions">Действия поля выбора</link> экземпляра сущности.</para>
            </listitem>
          </itemizedlist></para>
        <section id="list_actions">
          <title>Стандартные действия с коллекцией</title>
          <para>Для наследников <code>ListComponent</code> (это <link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link> и <link linkend="gui_Tree">Tree</link>)  набор стандартных действий определен в перечислении <code>ListActionType</code>, классы их реализации находятся в пакете <code>com.haulmont.cuba.gui.components.actions</code>. </para>
          <para>Рассмотрим их подробнее.<itemizedlist>
              <listitem id="createAction">
                <para role=""><emphasis role="bold">CreateAction</emphasis> - действие с идентификатором <emphasis role="bold">create</emphasis>. Предназначено для создания нового экземляра сущности и открытия экрана редактирования для этого экземпляра. Если экран редактирования успешно закоммитил новый экземпляр в базу данных, то <code>CreateAction</code> добавляет этот новый экземпляр в источник данных таблицы и делает его выбранным. </para>
                <para>В классе <code>CreateAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setOpenType()</code> - позволяет задать режим открытия экрана редактирования новой сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                      <para>Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, <code>DIALOG</code>), при декларативном создании действия <code>create</code> в элементе <code>action</code> можно указать атрибут <code>openType</code> с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:<programlisting language="xml">&lt;table id=&quot;usersTable&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;create&quot; openType=&quot;DIALOG&quot;/&gt;</programlisting></para>
                    </listitem>
                    <listitem>
                      <para><code>setWindowId()</code> - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран <code>{имя_сущности}.edit</code>, например <code>sales$Customer.edit</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>setWindowParams()</code> - позволяет задать параметры экрана редактирования, передаваемые в его метод <code>init()</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>setInitialValues()</code> - позволяет задать начальные значения атрибутов создаваемой сущности. Принимает объект  <code>Map</code>, в котором ключами являются имена атрибутов, а значениями - значения атрибутов. Например:<programlisting language="java">Map&lt;String, Object&gt; values = new HashMap&lt;&gt;();
values.put(&quot;type&quot;, CarType.PASSENGER);
carCreateAction.setInitialValues(values);</programlisting></para>
                      <para>Пример использования <code>setInitialValues()</code> приведен также в разделе <link linkend="init_values_in_CreateAction">рецептов разработки</link>.</para>
                    </listitem>
                    <listitem>
                      <para><code>afterCommit()</code> -  вызывается действием после того, как экран редактирования успешно закоммитил новую сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                    <listitem>
                      <para><code>afterWindowClosed()</code> -  вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена новая сущность или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="editAction">
                <para><emphasis role="bold">EditAction</emphasis> - действие с идентификатором <emphasis role="bold">edit</emphasis>. Открывает экран редактирования для выбранного экземпляра сущности. Если экран редактирования успешно закоммитил  экземпляр в базу данных, то <code>EditAction</code> обновляет этот экземпляр в источнике данных таблицы.</para>
                <para>В классе <code>EditAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setOpenType()</code> - позволяет задать режим открытия экрана редактирования  сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                      <para>Так как довольно часто требуется открывать экраны редактирования в другом режиме (как правило, <code>DIALOG</code>), при декларативном создании действия <code>edit</code> в элементе <code>action</code> можно указать атрибут <code>openType</code> с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:<programlisting language="xml">&lt;table id=&quot;usersTable&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;edit&quot; openType=&quot;DIALOG&quot;/&gt;</programlisting></para>
                    </listitem>
                    <listitem>
                      <para><code>setWindowId()</code> - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран <code>{имя_сущности}.edit</code>, например <code>sales$Customer.edit</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>setWindowParams()</code> - позволяет задать параметры экрана редактирования, передаваемые в его метод <code>init()</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>afterCommit()</code> -  вызывается действием после того, как экран редактирования успешно закоммитил  сущность и был закрыт. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                    <listitem>
                      <para><code>afterWindowClosed()</code> -  вызывается действием в последнюю очередь после закрытия экрана редактирования, независимо от того, была ли закоммичена редактируемая сущность. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="removeAction">
                <para><emphasis role="bold">RemoveAction</emphasis> - действие с идентификатором <emphasis role="bold">remove</emphasis>. Предназначено для удаления выбранного экземпляра сущности.</para>
                <para>В классе <code>RemoveAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setAutocommit()</code> - позволяет управлять моментом удаления сущности из базы данных. По умолчанию после срабатывания действия и удаления сущности из источника данных у источника вызывается метод <code>commit()</code>, в результате чего сущность удаляется  из базы данных. Cвойство <code>autocommit</code> можно установить в <code>false</code> либо  методом <code>setAutocommit()</code>, либо соответствующим параметром конструктора. В результате после удаления сущности из источника данных для подтверждения удаления потребуется явно вызвать метод <code>commit()</code> источника данных.</para>
                      <para>Значение <code>autocommit</code> не влияет на работу источников данных в режиме <code>Datasource.CommitMode.PARENT</code>, то есть тех, которые обеспечивают редактирование <link linkend="composition_annotation">композиционных</link> сущностей.</para>
                    </listitem>
                    <listitem>
                      <para><code>setConfirmationMessage()</code> - позволяет задать текст сообщения в диалоге подтверждения удаления. </para>
                    </listitem>
                    <listitem>
                      <para><code>setConfirmationTitle()</code> - позволяет задать заголовок диалога подтверждения удаления.</para>
                    </listitem>
                    <listitem>
                      <para><code>afterRemove()</code> -  вызывается действием после успешного удаления сущности. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="refreshAction">
                <para><emphasis role="bold">RefreshAction</emphasis> - действие с идентификатором <emphasis role="bold">refresh</emphasis>. Предназначено для обновления (перезагрузки) коллекции сущностей. При срабатывании вызывает метод <code>refresh()</code> <link linkend="datasources">источника данных</link>, с которым связан компонент.</para>
                <para>В классе <code>RefreshAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setRefreshParams()</code> - позволяет задать параметры, передаваемые в метод <code>CollectionDatasource.refresh()</code>, для использования внутри <link linkend="datasource_query">запроса</link>. По умолчанию никакие параметры не передаются.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="addAction">
                <para><emphasis role="bold">AddAction</emphasis> - действие с идентификатором <emphasis role="bold">add</emphasis>. Предназначено для выбора существующего экземпляра сущности и добавления его в коллекцию. При срабатывании открывает <link linkend="screen_lookup">экран выбора</link> сущностей.</para>
                <para>В классе <code>AddAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setOpenType()</code> - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                      <para>Так как довольно часто требуется открывать экраны выбора в другом режиме (как правило, <code>DIALOG</code>), при декларативном создании действия <code>add</code> в элементе <code>action</code> можно указать атрибут <code>openType</code> с нужным значением. Это избавляет от необходимости получать ссылку на действие в контроллере и программно устанавливать данное свойство. Например:<programlisting language="xml">&lt;table id=&quot;usersTable&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;add&quot; openType=&quot;DIALOG&quot;/&gt;</programlisting></para>
                    </listitem>
                    <listitem>
                      <para><code>setWindowId()</code> - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран <code>{имя_сущности}.lookup</code>, например <code>sales$Customer.lookup</code>. Если такого экрана не существует, то делается попытка открыть экран <code>{имя_сущности}.browse</code>, например <code>sales$Customer.browse</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>setWindowParams()</code> - позволяет задать параметры экрана выбора, передаваемые в его метод <code>init()</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>setHandler()</code> - позволяет задать объект, реализующий интерфейс <code>Window.Lookup.Handler</code>, передаваемый в экран выбора. По умолчанию используется объект класса <code>AddAction.DefaultHandler</code>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="excludeAction">
                <para><emphasis role="bold">ExcludeAction</emphasis> - действие с идентификатором <emphasis role="bold">exclude</emphasis>. Позволяет исключать экземпляры сущности из коллекции, не удаляя их из базы данных.  Класс данного действия является наследником <code>RemoveAction</code>, однако при срабатывании вызывает у <code>CollectionDatasource</code> не <code>removeItem()</code>, а <code>excludeItem()</code>. Кроме того, для вложенных источников данных <code>ExcludeAction</code> разрывает связь с родительской сущностью, поэтому с помощью данного действия можно организовать редактирование ассоциации one-to-many. </para>
                <para>В классе <code>ExcludeAction</code> в дополнение к <code>RemoveAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setConfirm()</code> - показывать ли диалог подтверждения удаления. Это свойство можно также установить через конструктор действия. По умолчанию установлено в <code>false</code>.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="excelAction">
                <para><emphasis role="bold">ExcelAction</emphasis> - действие с идентификатором <emphasis role="bold">excel</emphasis>. Предназначено для экспорта данных таблицы в формат XLS и выгрузки соответствующего файла. Данное действие можно связать только с компонентами <link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link> и <link linkend="gui_TreeTable">TreeTable</link>.</para>
                <para>При программном создании действия можно задать следующие параметры конструктора:<itemizedlist>
                    <listitem>
                      <para><code>display</code> - реализация интерфейса <code>ExportDisplay</code> для выгрузки файла. По умолчанию используется стандартная реализация.</para>
                    </listitem>
                    <listitem>
                      <para><code>parameterized</code> - при установке в <code>true</code> действие отображает специальное окно с идентификатором <code>excelExport</code>, позволяющее пользователю выбрать колонки таблицы для экспорта.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
          <para>Пример использования стандартных действий в таблице:<programlisting language="xml">&lt;table id=&quot;usersTable&quot; width=&quot;100%&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;create&quot;/&gt;
        &lt;action id=&quot;edit&quot;/&gt;
        &lt;action id=&quot;remove&quot;/&gt;
        &lt;action id=&quot;refresh&quot;/&gt;
    &lt;/actions&gt;
    &lt;buttonsPanel&gt;
        &lt;button action=&quot;usersTable.create&quot;/&gt;
        &lt;button action=&quot;usersTable.edit&quot;/&gt;
        &lt;button action=&quot;usersTable.remove&quot;/&gt;
        &lt;button action=&quot;usersTable.refresh&quot;/&gt;
    &lt;/buttonsPanel&gt;
    &lt;rowsCount/&gt;
    &lt;columns&gt;
        &lt;column id=&quot;login&quot;/&gt;
        ...
    &lt;/columns&gt;
    &lt;rows datasource=&quot;usersDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
        </section>
        <section id="picker_actions">
          <title>Стандартные действия поля выбора</title>
          <para>Для компонентов <link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link> и <link linkend="gui_SearchPickerField">SearchPickerField</link>  набор стандартных действий определен в перечислении <code>PickerField.ActionType</code>. Реализации являются внутренними классами интерфейса <code>PickerField</code>.</para>
          <para>Рассмотрим их подробнее.<itemizedlist>
              <listitem id="lookupAction">
                <para><emphasis role="bold">LookupAction</emphasis> - действие с идентификатором <emphasis role="bold">lookup</emphasis>. Предназначено для выбора  экземпляра сущности и установки его в качестве значения компонента. При срабатывании открывает <link linkend="screen_lookup">экран выбора</link> сущностей.</para>
                <para>В классе <code>LookupAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setLookupScreenOpenType()</code> - позволяет задать режим открытия экрана выбора сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                    </listitem>
                    <listitem>
                      <para><code>setLookupScreenDialogParams</code>() - позволяет задать свойства дилогового окна при  открытия экрана выбора сущности в режиме <code>DIALOG</code> (см. предыдущий метод). На другие режимы влияния не оказывает. </para>
                    </listitem>
                    <listitem>
                      <para><code>setLookupScreen()</code> - позволяет задать идентификатор экрана выбора сущности. По умолчанию используется экран <code>{имя_сущности}.lookup</code>, например <code>sales$Customer.lookup</code>. Если такого экрана не существует, то делается попытка открыть экран <code>{имя_сущности}.browse</code>, например <code>sales$Customer.browse</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>setLookupScreenParams()</code> - позволяет задать параметры экрана выбора, передаваемые в его метод <code>init()</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>afterSelect()</code> -  вызывается действием после того, как выбранный экземпляр установлен в качестве значения компонента. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                    <listitem>
                      <para><code>afterCloseLookup()</code> -  вызывается действием в последнюю очередь после закрытия экрана выбора, независимо от того, был сделан выбор или нет. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem id="clearAction">
                <para><emphasis role="bold">ClearAction</emphasis> - действие с идентификатором <emphasis role="bold">clear</emphasis>. Предназначено для очистки (то есть установки в <code>null</code>) текущего значения компонента.</para>
              </listitem>
              <listitem id="openAction">
                <para><emphasis role="bold">OpenAction</emphasis> - действие с идентификатором <emphasis role="bold">open</emphasis>. Предназначено для  открытия экрана редактирования экземпляра сущности, являющегося текущим значением компонента. </para>
                <para>В классе <code>OpenAction</code> определены следующие специфические методы:<itemizedlist>
                    <listitem>
                      <para><code>setEditScreenOpenType()</code> - позволяет задать режим открытия экрана редактирования сущности. По умолчанию экран открывается в режиме <code>THIS_TAB</code>. </para>
                    </listitem>
                    <listitem>
                      <para><code>setEditScreenDialogParams()</code> - позволяет задать свойства дилогового окна при  открытия экрана редактирования в режиме <code>DIALOG</code> (см. предыдущий метод). На другие режимы влияния не оказывает. </para>
                    </listitem>
                    <listitem>
                      <para><code>setEditScreen()</code> - позволяет задать идентификатор экрана редактирования сущности. По умолчанию используется экран <code>{имя_сущности}.edit</code>, например <code>sales$Customer.edit</code>. </para>
                    </listitem>
                    <listitem>
                      <para><code>setEditScreenParams()</code> - позволяет задать параметры экрана редактирования, передаваемые в его метод <code>init()</code>.</para>
                    </listitem>
                    <listitem>
                      <para><code>afterWindowClosed()</code> -  вызывается действием после закрытия экрана редактирования. Данный метод не имеет реализации и может быть переопределен в наследниках для реакции на это событие. </para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
            </itemizedlist></para>
          <para>Пример использования стандартных действий в компоненте выбора:<programlisting language="xml">&lt;searchPickerField optionsDatasource=&quot;coloursDs&quot;
                   datasource=&quot;carDs&quot; property=&quot;colour&quot;&gt;
    &lt;actions&gt;
        &lt;action id=&quot;clear&quot;/&gt;
        &lt;action id=&quot;lookup&quot;/&gt;
        &lt;action id=&quot;open&quot;/&gt;
    &lt;/actions&gt;
&lt;/searchPickerField&gt;</programlisting></para>
        </section>
      </section>
      <section id="abstractAction">
        <title>AbstractAction</title>
        <para><code>AbstractAction</code> - базовый класс реализации <link linkend="gui_Action">действий</link>. От него рекомендуется наследовать собственные нестандартные действия, если возможностей <link linkend="declarative_actions">декларативного создания действий</link> не хватает. </para>
        <para>При создании конкретного класса действия необходимо определить метод <code>actionPerform()</code> и передать в конструктор <code>AbstractAction</code> идентификатор действия. Можно также переопределить любые методы получения свойств действия: <code>getCaption()</code>, <code>getDescription()</code>, <code>getIcon()</code>, <code>getShortcut()</code>, <code>isEnabled()</code>, <code>isVisible()</code>. Стандартные реализации этих методов возвращают значения, установленные соответствующими set-методами. Исключение составляет метод <code>getCaption()</code>: если название действия  явно не установлено методом <code>setCaption()</code>, то он обращается в <link linkend="message_packs">пакет локализованных сообщений</link> с именем, соответствующим пакету класса действия, и возвращает сообщение с ключом, равным идентификатору действия. Если сообщения с таким ключом нет, то возвращается сам ключ, то есть идентификатор действия. </para>
        <para>Примеры использования:<itemizedlist>
            <listitem>
              <para>Действие кнопки:<programlisting language="java">@Inject
private Button helloBtn;

@Override
public void init(Map&lt;String, Object&gt; params) {
    helloBtn.setAction(new AbstractAction(&quot;hello&quot;) {
        @Override
        public void actionPerform(Component component) {
            showNotification(&quot;Hello!&quot;, NotificationType.TRAY);
        }
    });
}</programlisting>В данном случае кнопка <code>helloBtn</code> получит в качестве заголовка строку, находящуюся в пакете сообщений с ключом <code>hello</code>. Для того, чтобы получить название кнопки каким-либо иным способом, можно переопределить метод <code>getCaption()</code> действия.</para>
            </listitem>
            <listitem>
              <para>Действие кнопки программно создаваемого <link linkend="gui_PickerField">PickerField</link>:<programlisting language="java">@Inject
private ComponentsFactory componentsFactory;

@Inject
private BoxLayout box;

@Override
public void init(Map&lt;String, Object&gt; params) {
    PickerField pickerField = componentsFactory.createComponent(PickerField.NAME);

    pickerField.addAction(new AbstractAction(&quot;hello&quot;) {
        @Override
        public String getCaption() {
            return null;
        }

        @Override
        public String getDescription() {
            return getMessage(&quot;helloDescription&quot;);
        }

        @Override
        public String getIcon() {
            return &quot;icons/hello.png&quot;;
        }

        @Override
        public void actionPerform(Component component) {
            showNotification(&quot;Hello!&quot;, NotificationType.TRAY);
        }
    });

    box.add(pickerField);
}</programlisting>Здесь анонимный класс-наследник <code>AbstractAction</code> используется для задания действия кнопки поля выбора. Заголовок кнопки не отображается, вместо него используется значок и описание, всплывающее  при наведении курсора мыши.</para>
            </listitem>
            <listitem>
              <para>Действие таблицы:<programlisting language="java">@Inject
private Table table;

@Override
public void init(Map&lt;String, Object&gt; params) {
    table.addAction(new HelloAction());
}

private class HelloAction extends AbstractAction {

    public AddRoleAction() {
        super(&quot;hello&quot;);
    }

    public void actionPerform(Component component) {
        showNotification(&quot;Hello All!&quot;, NotificationType.TRAY);
    }
}</programlisting>Здесь объявлен класс <code>HelloAction</code>, экземпляр которого добавляется в список действий таблицы. </para>
            </listitem>
            <listitem>
              <para>Действие таблицы, отслеживающее наличие выбранной строки:<programlisting language="java">@Inject
private Table table;

@Override
public void init(Map&lt;String, Object&gt; params) {
    table.addAction(new ItemTrackingAction(&quot;hello&quot;) {
        @Override
        public void actionPerform(Component component) {
            showNotification(&quot;Hello &quot; + table.getSelected().iterator().next(), NotificationType.TRAY);
        }    
    });
}</programlisting>Здесь для реализации действия используется класс <code>ItemTrackingAction</code>, который слушает изменение состояния источника данных таблицы, и делает действие недоступным, если ни одна строка не выбрана.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="dialogs_and_notifications">
      <title>Диалоговые окна и уведомления</title>
      <para>Для вывода сообщений пользователю можно использовать диалоговые окна и уведомления. </para>
      <para>Диалоговые окна имеют заголовок с кнопкой закрытия и отображаются всегда в центре главного окна приложения. Уведомления могут отображаться как в центре, так и в углу приложения, и автоматически исчезать.</para>
      <section id="dialogs">
        <title>Диалоговые окна</title>
        <para>Диалоговые окна вызываются методами  <code>showMessageDialog()</code> и <code>showOptionDialog()</code> интерфейса <code>IFrame</code>. Этот интерфейс реализуется <link linkend="screen_controller">контроллером экрана</link>, поэтому данные методы можно вызывать напрямую в коде контроллера.</para>
        <itemizedlist>
          <listitem>
            <para><code>showMessageDialog()</code> предназначен для отображения сообщения. Метод принимает следующие параметры:<itemizedlist>
                <listitem>
                  <para><code>title</code> - заголовок диалогового окна.</para>
                </listitem>
                <listitem>
                  <para><code>message</code> - сообщение. Можно использовать символы <code>\n</code> для переноса строки. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте.</para>
                </listitem>
                <listitem>
                  <para><code>messageType</code> - тип сообщения. Возможные типы:<itemizedlist>
                      <listitem>
                        <para><code>CONFIRMATION</code>, <code>CONFIRMATION_HTML</code> - диалог подтверждения. </para>
                      </listitem>
                      <listitem>
                        <para><code>WARNING</code>, <code>WARNING_HTML</code> - диалог преупреждения.</para>
                      </listitem>
                    </itemizedlist></para>
                  <para>Различие типов сообщений отражается только в пользовательском интерфейсе десктоп-приложений.</para>
                </listitem>
              </itemizedlist>Пример вызова диалога:<programlisting language="java">showMessageDialog(&quot;Warning&quot;, &quot;Something is wrong&quot;, MessageType.WARNING);</programlisting></para>
          </listitem>
          <listitem>
            <para><code>showOptionDialog()</code> предназначен для отображения сообщения и кнопок для выбора пользователем. Метод в дополнение к параметрам, описанным для <code>showMessageDialog()</code>, принимает массив или список <link linkend="gui_Action">действий</link>. Для каждого действия в диалоге создается кнопка, при нажатии на которую пользователем диалог закрывается и вызывается метод <code>actionPerform()</code> данного действия.</para>
            <para>В качестве кнопок со стандартными названиями и значками удобно использовать анонимные классы, унаследованные от <code>DialogAction</code>. Поддерживаются пять видов действий, определяемых перечислением <code>DialogAction.Type</code>: <code>OK</code>, <code>CANCEL</code>, <code>YES</code>, <code>NO</code>, <code>CLOSE</code>. Названия соответствующих кнопок извлекаются из <link linkend="main_message_pack">главного пакета</link> локализованных сообщений.</para>
            <para>Пример вызова диалога с кнопками <guibutton>Да</guibutton> и <guibutton>Нет</guibutton> и с заголовком и сообщением, взятыми из пакета локализованных сообщений текущего экрана:<programlisting language="java">showOptionDialog(
        getMessage(&quot;confirmCopy.title&quot;),
        getMessage(&quot;confirmCopy.msg&quot;),
        MessageType.CONFIRMATION,
        new Action[]{
                new DialogAction(DialogAction.Type.YES) {
                    public void actionPerform(Component component) {
                        copySettings();
                    }
                },
                new DialogAction(DialogAction.Type.NO)
        }
);</programlisting></para>
          </listitem>
        </itemizedlist>
      </section>
      <section id="notifications">
        <title>Уведомления</title>
        <para>Уведомления вызываются методом <code>showNotification()</code> интерфейса <code>IFrame</code>. Этот интерфейс реализуется <link linkend="screen_controller">контроллером экрана</link>, поэтому данный метод можно вызывать напрямую в коде контроллера.</para>
        <para>Метод <code>showNotification()</code> принимает следующие параметры:<itemizedlist>
            <listitem>
              <para><code>caption</code> - текст уведомления. Можно использовать символы <code>\n</code> для переноса строки. В случае HTML-типа (см. ниже) в сообщении можно использовать теги HTML для форматирования. При использовании HTML обязательно экранируйте данных из БД во избежание code injection в веб-клиенте.</para>
            </listitem>
            <listitem>
              <para><code>description</code> - опциональное описание, которое будет отображено ниже <code>caption</code>. Также можно использовать символы <code>\n</code> и  HTML-форматирование.</para>
            </listitem>
            <listitem>
              <para><code>type</code> - тип уведомления. Возможные типы:<itemizedlist>
                  <listitem>
                    <para><code>TRAY</code>, <code>TRAY_HTML</code> - уведомление показывается в правом нижнем углу приложения и исчезает автоматически. </para>
                  </listitem>
                  <listitem>
                    <para><code>HUMANIZED</code>, <code>HUMANIZED_HTML</code> - стадартное уведомление в центре экрана, исчезает автоматически.</para>
                  </listitem>
                  <listitem>
                    <para><code>WARNING</code>, <code>WARNING_HTML</code> - предупреждение. Исчезает при клике пользователя.</para>
                  </listitem>
                  <listitem>
                    <para><code>ERROR</code>, <code>ERROR_HTML</code> - уведомление об ошибке. Исчезает при клике пользователя.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>Примеры вызова уведомлений:<programlisting language="java">showNotification(getMessage(&quot;selectBook.text&quot;), NotificationType.HUMANIZED);

showNotification(&quot;Validation error&quot;, &quot;&lt;b&gt;Date&lt;/b&gt; is incorrect&quot;, NotificationType.TRAY_HTML);</programlisting></para>
      </section>
    </section>
    <section id="background_tasks">
      <title>Фоновые задачи</title>
      <para>Фоновые задачи используются на клиентском уровне для асинхронного выполнения длительных операций без заморозки пользовательского интерфейса. </para>
      <section><title>Использование фоновых задач</title><orderedlist>
          <listitem>
            <para>Задача описывается как наследник абстрактного класса <code>BackgroundTask</code>. В конструктор задачи необходимо передать ссылку на контроллер экрана, с которым будет связана задача, и значение таймаута ее выполнения.</para>
            <para>Если экран указан, то при его закрытии пользователем активная задача будет прервана. Кроме того, задача будет автоматически прервана по истечении указанного таймаута.</para>
            <para>Собственно действия, выполняемые задачей, реализуются в методе <code>run()</code>.</para>
          </listitem>
          <listitem>
            <para>Создается объект управления задачей − <code>BackgroundTaskHandler</code>. Для этого экземпляр задачи необходимо передать методу <code>handle()</code> бина <code>BackgroundWorker</code>. Ссылку на <code>BackgroundWorker</code> можно получить инжекцией в <link linkend="screen_controller">контроллер экрана</link>, либо статическим методом класса <code>AppBeans</code>.</para>
          </listitem>
          <listitem>
            <para>Выполняется запуск задачи.</para>
          </listitem>
        </orderedlist>Пример:<programlisting language="java">@Inject
protected BackgroundWorker backgroundWorker;

@Override
public void init(Map&lt;String, Object&gt; params) {
    // Create task with 10 sec timeout and this screen as owner
    BackgroundTask&lt;Integer, Void&gt; task = new BackgroundTask&lt;Integer, Void&gt;(10, this) {
        @Override
        public Void run(TaskLifeCycle&lt;Integer&gt; taskLifeCycle) throws Exception {
            // Do something in background thread
            for (int i = 0; i &lt; 5; i++) {
                TimeUnit.SECONDS.sleep(1); // time consuming computations
                taskLifeCycle.publish(i); // publish current progress to show it in progress() method
            }
            return null;
        }

        @Override
        public void canceled() {
            // Do something in UI thread if the task is canceled
        }

        @Override
        public void done(Void result) {
            // Do something in UI thread when the task is done
        }

        @Override
        public void progress(List&lt;Integer&gt; changes) {
            // Show current progress in UI thread
        }
    };
    // Get task handler object and run the task
    BackgroundTaskHandler taskHandler = backgroundWorker.handle(task);
    taskHandler.execute();
}</programlisting><para>Подробная информация о назначении методов приведена в JavaDocs классов <code>BackgroundTask</code>, <code>TaskLifeCycle</code>, <code>BackgroundTaskHandler</code>. </para><para>Ниже приведены моменты, на которые следует обратить внимание:</para><itemizedlist>
          <listitem>
            <para><code>BackgroundTask&lt;T, V&gt;</code> − параметризованный класс:</para>
            <itemizedlist>
              <listitem>
                <para><code>T</code> − тип объектов, показывающих прогресс задачи. Объекты этого типа передаются в метод <code>progress()</code> задачи при вызове <code>TaskLifeCycle.publish()</code> в рабочем потоке.</para>
              </listitem>
              <listitem>
                <para><code>V</code> − тип результата задачи, он передается в метод <code>done()</code>. Его также можно получить вызовом метода  <code>BackgroundTaskHandler.getResult()</code>, что приведет к ожиданию завершения задачи.</para>
              </listitem>
            </itemizedlist>
          </listitem>
          <listitem>
            <para>Метод <code>canceled()</code> вызывается только в случае управляемой отмены задачи, то есть при вызове <code>cancel()</code> у <code>TaskHandler</code>.</para>
          </listitem>
          <listitem>
            <para>Если у задачи истек таймаут, или было закрыто окно, в котором она исполнялась, то задача будет завершена без уведомлений. В блоке <structname>Web Client</structname> завершение по таймауту производится с задержкой, задаваемой свойством приложения <property>
                <link linkend="cuba.backgroundWorker.maxClientLatencySeconds">cuba.backgroundWorker.maxClientLatencySeconds</link>
              </property>.</para>
          </listitem>
          <listitem>
            <para>Метод <code>run()</code> задачи должен поддерживать возможность прерывания извне. Для этого в долгих процессах желательно периодически проверять флаг <code>TaskLifeCycle.isInterrupted()</code>, и соответственно завершать выполнение. Кроме того, нельзя тихо проглатывать исключение <code>InterruptedException</code> (или вообще все исключения). Вместо этого нужно либо вообще не перехватывать его, либо выполнять корректный выход из метода.</para>
          </listitem>
          <listitem>
            <para>Объекты <code>BackgroundTask</code> не имеют состояния. Если при реализации конкретного класса задачи не заводить полей для хранения промежуточных данных, то можно запускать несколько параллельно работающих процессов, используя единственный экземпляр задачи.</para>
          </listitem>
          <listitem>
            <para>Объект <code>BackgroundHandler</code> можно запускать (т.е. вызывать его метод <code>execute()</code>) всего один раз. Если требуется частый перезапуск задачи, то используйте класс <code>BackgroundTaskWrapper</code>.</para>
          </listitem>
          <listitem>
            <para>Для  показа пользователю модального окна с прогрессом и кнопкой <guibutton>Отмена</guibutton> используйте классы <code>BackgroundWorkWindow</code> или <code>BackgroundWorkProgressWindow</code> с набором статических методов.
Для окна можно задать режим отображения прогресса и разрешить или запретить отмену фоновой задачи.</para>
          </listitem>
          <listitem>
            <para>Если внутри потока задачи необходимо использовать некоторые значения визуальных компонентов, то нужно реализовать их получение в  методе <code>getParams()</code>, который выполняется  в потоке UI один раз при запуске задачи. В методе <methodname>run()</methodname> эти параметры будут доступны через метод <code>getParams()</code>  объекта <code>TaskLifeCycle</code>.</para>
          </listitem>
          <listitem>
            <para>При возникновении исключительных ситуаций в потоке UI вызывается метод <code>BackgroundTask.handleException()</code>,  в котором можно отобразить ошибку.</para>
          </listitem>
        </itemizedlist></section>
      <section>
        <title>Настройка окружения</title>
        <para>Для корректной работы фоновых задач в проекте приложения необходимо произвести следующие настройки:</para>
        <itemizedlist>
          <listitem>
            <para>Прерывание задач по таймауту реализуется бином <code>WatchDog</code>. Для его периодического вызова в файлы <filename>
                <link linkend="spring.xml">spring.xml</link>
              </filename> блоков <structname>Web Client</structname> и <structname>Desktop Client</structname> необходимо добавить следующее объявление:<programlisting language="xml">&lt;bean id=&quot;backgroundWorkerScheduler&quot; class=&quot;org.springframework.scheduling.concurrent.ThreadPoolTaskScheduler&quot;&gt;
    &lt;property name=&quot;daemon&quot; value=&quot;true&quot;/&gt;
    &lt;property name=&quot;poolSize&quot; value=&quot;1&quot;/&gt;
&lt;/bean&gt;

&lt;task:scheduled-tasks scheduler=&quot;backgroundWorkerScheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;cuba_BackgroundWorker_WatchDog&quot; method=&quot;cleanupTasks&quot; fixed-delay=&quot;2000&quot;/&gt;
&lt;/task:scheduled-tasks&gt; </programlisting></para>
          </listitem>
          <listitem>
            <para>В блоке <structname>Web Client</structname> опрос состояния задачи инициируется клиентским кодом, выполняющимся в  веб-браузере. Периодичность опроса задается свойством приложения <property>
                <link linkend="cuba.backgroundWorker.uiCheckInterval">cuba.backgroundWorker.uiCheckInterval</link>
              </property>, по умолчанию - 2 сек.</para>
            <para>Кроме того, на выполнение фоновых задач в блоке <structname>Web Client</structname> влияют свойства приложения <property>
                <link linkend="cuba.backgroundWorker.maxActiveTasksCount">cuba.backgroundWorker.maxActiveTasksCount</link>
              </property> и <property>
                <link linkend="cuba.backgroundWorker.maxClientLatencySeconds">cuba.backgroundWorker.maxClientLatencySeconds</link>
              </property>.</para>
          </listitem>
        </itemizedlist>
      </section>
    </section>
    <section id="gui_themes">
      <title>Создание темы приложения</title>
      <para>Тема служит для управления визуальным представлением приложения. </para>
      <section id="web_theme">
        <title>Тема в веб-приложениях</title>
        <para>Тема веб-приложения состоит из файлов SCSS и других ресурсов, в том числе файлов изображений.</para>
        <section id="web_theme_usage">
          <title>Использование существующих тем</title>
          <para>Платформа включает в себя две готовые темы: Halo и Havana. Приложение будет по умолчанию использовать ту из них, которая указана в свойстве приложения <link linkend="cuba.web.theme">cuba.web.theme</link>. Пользователь может выбрать другую доступную тему в стандартном экране <guimenu>Help</guimenu> -&gt; <guimenu>Settings</guimenu>. Если вы не хотите, чтобы пользователи имели возможность сами выбирать тему, зарегистрируйте экран <code>settings</code> в файле <link linkend="screens.xml">web-screens.xml</link> проекта с параметром <code>changeThemeEnabled = false</code>:
          <programlisting language="xml">&lt;screen id=&quot;settings&quot; template=&quot;/com/haulmont/cuba/web/app/ui/core/settings/settings-window.xml&quot;&gt;
    &lt;param name=&quot;changeThemeEnabled&quot; value=&quot;false&quot;/&gt;
&lt;/screen&gt;          </programlisting></para>
          <para>При использовании существующих тем можно настроить некоторые параметры фирменного стиля (branding): пиктограммы и заголовки окна логина и главного окна, пиктограмму вебсайта <filename>favicon.ico</filename>. Для этого необходимо выполнить следующее:<orderedlist>
              <listitem>
                <para>Создайте следующую файловую структуру внутри каталога <filename>modules/web</filename> проекта:<programlisting>VAADIN/
  themes/
    havana/
      branding/
        myapp-login.png
        myapp-menu.png
      favicon.ico</programlisting></para>
                <para>Здесь <filename>havana</filename> - каталог с именем используемой темы, <filename>favicon.ico</filename> - пиктограмма вебсайта, <filename>myapp-login.png</filename> - изображение для окна логина, <filename>myapp-menu.png</filename> - изображение для главного окна. </para>
              </listitem>
              <listitem>
                <para>В <application>CUBA Studio</application> откройте <guimenu>Project properties</guimenu> -&gt; <guimenu>Edit</guimenu> и нажмите кнопку <guibutton>Branding</guibutton> внизу страницы. Используя  ссылки <guibutton>Set application logo image</guibutton> и <guibutton>Set login window logo image</guibutton> задайте путь к файлам пиктограмм соответственно главного окна и окна логина. Путь указывается относительно каталога темы. Остальные ссылки служат для задания заголовков окон и текста приглашения окна логина.</para>
                <para>Данные параметры сохраняются в <link linkend="main_message_pack">главном пакете сообщений</link> модуля <structname>gui</structname> (то есть в файле <filename>modules/gui/&lt;root_package&gt;/gui/messages.properties</filename> и его вариантах для разных локалей). Использование пакетов сообщений дает возможность использовать разные файлы изображений для разных локалей пользователей. Пример содержимого файла <filename>messages.properties</filename>:<programlisting>application.caption = MyApp
application.logoImage = branding/myapp-menu.png

loginWindow.caption = MyApp Login
loginWindow.welcomeLabel = Welcome to MyApp!
loginWindow.logoImage = branding/myapp-login.png</programlisting></para>
                <para>Путь к <code>favicon.ico</code> указывать не нужно, он должен обязательно находится в корне каталога с именем темы.</para>
              </listitem>
            </orderedlist>В существующую тему можно также добавить файлы изображений для использования в свойствах <link linkend="gui_attr_basic_icon">icon</link> <link linkend="gui_Action">действий</link> и визуальных компонентов, например <link linkend="gui_Button">Button</link>. </para>
          <para>Например, чтобы добавить в тему Havana пиктограмму, достаточно в описанный выше каталог <filename>modules/web/VAADIN/themes/havana</filename>  добавить файл изображения (желательно в некоторый подкаталог): <programlisting>VAADIN/
  themes/
    havana/
      images/
        address-book.png</programlisting>После этого можно использовать эту пиктограмму, указывая в свойстве <code>icon</code> путь к ней относительно каталога темы:<programlisting language="xml">&lt;action id=&quot;adresses&quot;
        icon=&quot;images/address-book.png&quot;/&gt;</programlisting></para>
          <para>Вместо файлов изображений для пиктограмм можно использовать элементы шрифта <ulink url="http://fortawesome.github.io/Font-Awesome">Font Awesome</ulink>. Для этого достаточно указать в свойстве <code>icon</code> имя нужной константы перечисления <code>com.vaadin.server.FontAwesome</code> с префиксом <code>font-icon:</code>, например:<programlisting>&lt;action id=&quot;adresses&quot;
        icon=&quot;font-icon:BOOK&quot;/&gt;</programlisting></para>
          <para>В  проекте можно заменить изображения, используемые в стандартных действиях и экранах платформы. Для замены пиктограммы темы Havana достаточно положить в каталог <filename>modules/web/VAADIN/themes/havana/icons</filename> проекта нужный файл изображения. Например, для замены пиктограммы стандартного действия <code>create</code> это будет файл с именем  <filename>create.png</filename> (имя файла легко определить по URL соответствующего  HTML-элемента <code>img</code> в работающем приложении):<programlisting>VAADIN/
  themes/
    havana/
      icons/
        create.png</programlisting></para>
          <para>В теме Halo по умолчанию (при включенном свойстве приложения <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link>) пиктограммы стандартных действий и экранов платформы загружаются из  шрифта <application>Font Awesome</application>. В этом случае заменить стандартную пиктограмму можно только создав свою тему на базе Halo (см. <link linkend="web_theme_creation">далее</link>) и задав в файле <filename>&lt;your_theme&gt;-theme.properties</filename> нужное соответствие между именем пиктограммы и именем элемента шрифта, например:<programlisting>cuba.web.icons.create.png = PLUS</programlisting></para>
          <para>При выключенном свойстве <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link> пиктограммы стандартных действий и экранов платформы для темы Halo загружаются так же, как и для темы Havana - из файлов изображений в подкаталоге <filename>icons</filename>. Поэтому их можно заменить описанным для Havana способом.</para>
        </section>
        <section id="web_theme_extension">
          <title>Расширение существующей темы</title>
          <para>Существующая в платформе тема может быть изменена в  проекте приложения. Тема описывается в файлах <ulink url="http://sass-lang.com">SCSS</ulink> в определенной файловой структуре, поэтому простейший способ адаптации - изменение базовых переменных SCSS, влияющих на цвет фона, размеры компонентов и отступы между ними. Для изменения параметров отдельных компонентов требуется знание CSS.</para>
          <para>Для адаптации (расширения) темы в проекте необходимо создать специальную файловую структуру в модуле <structname>web</structname>. Это удобно сделать с помощью <application>CUBA Studio</application>: откройте секцию <guimenu>Project properties</guimenu> и нажмите ссылку <guibutton>Create theme extension</guibutton>. В диалоговом окне выберите тему, которую вы хотите расширить. В результате в проекте будет создана структура каталогов, аналогичная описанной в <link linkend="web_theme_usage">предыдущем</link> разделе. Кроме того, скрипт сборки <link linkend="build.gradle">build.gradle</link> будет дополнен задачей <code>buildScssThemes</code>, автоматически запускаемой при сборке модуля <structname>web</structname>.</para>
          <para>Рассмотрим пример расширения  темы Halo, так как она основана на теме <ulink url="https://vaadin.com/valo">Valo</ulink> фреймворка <application>Vaadin</application>, и предоставляет максимальные возможности адаптации.</para>
          <para>Файл <filename>themes/halo/halo-ext-defaults.scss</filename> предназначен для размещения в нем переменных темы. Большинство переменных Halo соответствует описанным в <ulink url="https://vaadin.com/api/valo">документации по Valo</ulink>, ниже приведены основные:<programlisting language="">$v-background-color: #fafafa;        /* цвет фона компонентов */
$v-app-background-color: #e7ebf2;    /* цвет фона приложения */
$v-panel-background-color: #fff;     /* цвет фона панелей */
$v-focus-color: #3b5998;             /* цвет выделения компонентов в фокусе */
$v-error-indicator-color: #ed473b;   /* цвет выделения обязательных незаполненных полей */

$v-line-height: 1.35;                /* высота строк */
$v-font-size: 14px;                  /* размер шрифта */
$v-font-weight: 400;                 /* начертание шрифта */
$v-unit-size: 30px;                  /* базовый размер темы, определяет высоту кнопок, полей и другие размеры компонентов */

$v-font-size--h1: 24px;              /* размер шрифта Label со стилем h1 */
$v-font-size--h2: 20px;              /* размер шрифта Label со стилем h2 */
$v-font-size--h3: 16px;              /* размер шрифта Label со стилем h3 */

/* размеры отступов margin для контейнеров */
$v-layout-margin-top: 10px;
$v-layout-margin-left: 10px;
$v-layout-margin-right: 10px;
$v-layout-margin-bottom: 10px;

/* размер отступа между компонентами в контейнере с включенной опцией spacing */
$v-layout-spacing-vertical: 10px;
$v-layout-spacing-horizontal: 10px;

/* базовые размеры для строк таблицы */
$v-table-row-height: 30px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 7px;

/* стиль фокуса для полей ввода */
$v-focus-style: inset 0px 0px 5px 1px rgba($v-focus-color, 0.5);
/* стиль, применяемый к обязательным полям ввода в фокусе */
$v-error-focus-style: inset 0px 0px 5px 1px rgba($v-error-indicator-color, 0.5);</programlisting></para>
          <para>Пример содержимого файла <filename>halo-ext-defaults.scss</filename> для темы с темным фоном и немного уменьшенными отступами:<programlisting>$v-background-color: #444D50;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;</programlisting>Для изменения параметров отдельных компонентов необходимо добавить соответствующий код CSS в блок <code>@mixin halo-ext {...}</code> файла <filename>halo-ext.scss</filename>. Например, для того, чтобы пункты главного меню отображались жирным шрифтом, содержимое файла <filename>halo-ext.scss</filename> должно быть следующим:<programlisting language="">@import &quot;../halo/halo&quot;;

@mixin halo-ext {
  @include halo;

  .v-menubar-menuitem-caption {
    font-weight: bold;
  }
}</programlisting></para>
        </section>
        <section id="web_theme_creation">
          <title>Создание новой темы</title>
          <para>В проекте можно создать одну или несколько новых  тем и дать возможность пользователям выбирать среди них подходящую. Создание новой темы позволяет также переопределять переменные файла <filename>*-theme.properties</filename>, задающие некоторые параметры, требуемые на стороне сервера:<itemizedlist>
              <listitem>
                <para>Размеры диалоговых окон по умолчанию.</para>
              </listitem>
              <listitem>
                <para>Ширина полей ввода  по умолчанию.</para>
              </listitem>
              <listitem>
                <para>Размеры некоторых компонентов (<link linkend="gui_Filter">Filter</link>, <link linkend="gui_FileMultiUploadField">FileMultiUploadField</link>).</para>
              </listitem>
              <listitem>
                <para>Соответствие между именами пиктограмм и именами констант перечисления <code>com.vaadin.server.FontAwesome</code> для использования элементов шрифта <application>Font Awesome</application> в стандартных действиях и экранах платформы при включенном свойстве <link linkend="cuba.web.useFontIcons">cuba.web.useFontIcons</link>.</para>
              </listitem>
            </itemizedlist></para>
          <para>Рассмотрим пример создания на основе Halo новой темы Facebook, напоминающей интерфейс сайта известной социальной сети.<orderedlist>
              <listitem>
                <para>В <application>CUBA Studio</application> откройте секцию <guimenu>Project properties</guimenu> и нажмите ссылку <guibutton>Create theme extension</guibutton>. В диалоговом окне выберите <code>halo</code> и нажмите <guibutton>Create</guibutton>. В проекте будет создано расширение темы Halo, как описано в предыдущем разделе.</para>
              </listitem>
              <listitem>
                <para>Переименуйте созданный в модуле <structname>web</structname> каталог <filename>themes/halo</filename> в <filename>themes/facebook</filename>, внутри него файл <filename>halo-ext.scss</filename> переименуйте в <filename>facebook.scss</filename>, <filename>halo-ext-defaults.scss</filename> в <filename>facebook-defaults.scss</filename>.</para>
              </listitem>
              <listitem>
                <para>Отредактируйте файл <filename>styles.scss</filename>, заменив в нем импорты <code>halo-ext</code>  и корневой селектор <code>halo</code>:<programlisting language="">@import &quot;halo-defaults&quot;;
@import &quot;facebook-defaults&quot;;
@import &quot;facebook&quot;;

.facebook {
  @include facebook;
}

.v-theme-version {
  display: none;
}</programlisting></para>
              </listitem>
              <listitem>
                <para>Отредактируйте файл  <filename>facebook.scss</filename>, заменив в нем <code>@mixin halo-ext</code>:<programlisting language="">@import &quot;../halo/halo&quot;;

@mixin facebook {
  @include halo;
}</programlisting></para>
              </listitem>
              <listitem>
                <para>Поместите в файл <filename>facebook-defaults.scss</filename> следующие переменные:<programlisting>$v-background-color: #fafafa;
$v-app-background-color: #e7ebf2;
$v-panel-background-color: #fff;
$v-focus-color: #3b5998;

$v-border-radius: 0;
$v-textfield-border-radius: 0;

$v-font-family: Helvetica, Arial, &apos;lucida grande&apos;, tahoma, verdana, arial, sans-serif;
$v-font-size: 14px;
$v-font-color: #37404E;
$v-font-weight: 400;

$v-link-text-decoration: none;
$v-shadow: 0 1px 0 (v-shade 0.2);
$v-bevel: inset 0 1px 0 v-tint;
$v-unit-size: 30px;
$v-gradient: v-linear 12%;
$v-overlay-shadow: 0 3px 8px v-shade, 0 0 0 1px (v-shade 0.7);
$v-shadow-opacity: 20%;
$v-selection-overlay-padding-horizontal: 0;
$v-selection-overlay-padding-vertical: 6px;
$v-selection-item-border-radius: 0;

$v-line-height: 1.35;
$v-font-size: 14px;
$v-font-weight: 400;
$v-unit-size: 25px;

$v-font-size--h1: 22px;
$v-font-size--h2: 18px;
$v-font-size--h3: 16px;

$v-layout-margin-top: 8px;
$v-layout-margin-left: 8px;
$v-layout-margin-right: 8px;
$v-layout-margin-bottom: 8px;

$v-layout-spacing-vertical: 8px;
$v-layout-spacing-horizontal: 8px;

$v-table-row-height: 25px;
$v-table-header-font-size: 13px;
$v-table-cell-padding-horizontal: 5px;

$v-focus-style: inset 0px 0px 1px 1px rgba($v-focus-color, 0.5);
$v-error-focus-style: inset 0px 0px 1px 1px rgba($v-error-indicator-color, 0.5);</programlisting></para>
              </listitem>
              <listitem>
                <para>Создайте в подкаталоге <filename>src</filename> модуля <structname>web</structname> файл <filename>facebook-theme.properties</filename> со следующим содержимым:<programlisting>@include=halo-theme.properties</programlisting></para>
                <para>При необходимости в этом файле можно переопределять server-side переменные темы, заданные в файле <filename>halo-theme.properties</filename> платформы.</para>
              </listitem>
              <listitem>
                <para>В файл <filename>web-app.properties</filename> добавьте следующие свойства:<programlisting>cuba.web.theme = facebook
cuba.web.availableAppThemes = facebook|halo|havana
cuba.themeConfig = havana-theme.properties halo-theme.properties facebook-theme.properties</programlisting></para>
              </listitem>
              <listitem>
                <para>Пересоберите приложение и запустите сервер. Теперь при первом входе пользователь увидит приложение в теме Facebook, и в окне <guimenu>Help</guimenu> -&gt; <guimenu>Settings</guimenu> сможет выирать между темами Facebook, Halo, Havana.</para>
              </listitem>
            </orderedlist></para>
        </section>
      </section>
      <section id="desktop_theme">
        <title>Тема в десктоп-приложениях</title>
        <para>В десктоп-приложениях базовой темой является тема <code>Nimbus</code>.</para>
        <para>Для внесения изменения в стандартную тему нужно создать пакет <code>res.nimbus</code> в пакете <code>com.sample.sales.desktop</code> модуля <structname>desktop</structname>. В пакете <code>res.nimbus</code> будут храниться файлы темы.</para>
        <figure>
          <title/>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/gui_themes_desktop_structure.png"/>
            </imageobject>
          </mediaobject>
        </figure>
        <para>В папке <code>icons</code> хранятся файлы пиктограмм, в файле <filename>nimbus.xml</filename> − описание стиля темы.</para>
        <para>В <link linkend="app_properties">файле свойств</link> для десктоп-приложения нужно установить свойство <property>cuba.desktop.resourceLocations</property> (задает набор директорий, в которых расположены файлы стилей):<programlisting>cuba.desktop.resourceLocations = \
  com/haulmont/cuba/desktop/res \
  com/sample/sales/desktop/res</programlisting></para>
        <para><emphasis role="bold">Примеры</emphasis></para>
        <orderedlist>
          <listitem>
            <para>Добавление пиктограммы.</para>
            <para>Если в десктоп-приложении требуется добавить новую пиктограмму, например, для кнопки,   нужно создать пакет <code>res.nimbus.icons</code> в пакете <code>com.sample.sales.desktop</code> модуля <structname>desktop</structname> и поместить в него требуемое изображение.</para>
            <figure>
              <title/>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_themes_example4.png"/>
                </imageobject>
              </mediaobject>
            </figure>
            <para>Описываем <link linkend="gui_Button">кнопку</link> в <link linkend="screen_xml_glossentry">дескрипторе</link>, указывая в атрибуте <link linkend="gui_attr_basic_icon">icon</link> путь до пиктограммы:</para>
            <programlisting language="xml">&lt;button id=&quot;button1&quot; caption=&quot;Attention&quot;  icon=&quot;icons/attention.png&quot;/&gt;</programlisting>
            <para>Ниже представлена кнопка с  пиктограммой <filename>attention.png</filename></para>
            <figure>
              <title/>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_themes_example5.png"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>
          <listitem>
            <para>Переопределение значений свойств темы, установленных по умолчанию.</para>
            <para>Рассмотрим на примере изменения цвета фона текстовых полей, обязательных для ввода.</para>
            <para>В пакете <code>res.nimbus</code> нужно создать файл <filename>nimbus.xml</filename> следующего содержания:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/desktop-theme.xsd&quot;&gt;
    &lt;ui-defaults&gt;
        &lt;color property=&quot;cubaRequiredBackground&quot; value=&quot;#f78260&quot;/&gt;
    &lt;/ui-defaults&gt;
&lt;/theme&gt;</programlisting></para>
            <para>Элемент <sgmltag>ui-defaults</sgmltag> служит для переопределения значений свойств темы платформы, установленных по умолчанию.</para>
            <para>В элементе <sgmltag>ui-defaults</sgmltag> присутствуют как свойства, содержащиеся в стандартной  теме <code>Nimbus</code> (<ulink url="http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html">http://docs.oracle.com/javase/tutorial/uiswing/lookandfeel/_nimbusDefaults.html</ulink>), так и свойства, созданные в платформе.</para>
            <para>В данном примере переопределено значение свойства платформы <sgmltag>cubaRequiredBackground</sgmltag>, хранящего цвет фона поля, обязательного для заполнения. Данное изменение коснется всех полей, обязательных для ввода.</para>
          </listitem>
          <listitem>
            <para>Создание стиля для элемента с помощью стандартных средств.</para>
            <para>Рассмотрим пример выделения надписи жирным цветом.</para>
            <para>Для того чтобы создать такой стиль, необходимо определить элемент <sgmltag>style</sgmltag> в файле темы <filename>nimbus.xml</filename> следующим образом:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/desktop-theme.xsd&quot;&gt;
    &lt;style name=&quot;boldlabel&quot;&gt;
        &lt;font style=&quot;bold&quot;/&gt;
    &lt;/style&gt;
&lt;/theme&gt;</programlisting></para>
            <para>Элемент <sgmltag>style</sgmltag> может содержать  другие элементы, в которых можно определять те или иные свойства: <sgmltag>background</sgmltag>, <sgmltag>foreground</sgmltag>, <sgmltag>icon</sgmltag>.</para>
            <para>В описании компонента надписи в <link linkend="screen_xml_glossentry">xml-дескрипторе</link>, к которой нужно применить созданный стиль, нужно указать атрибут <link linkend="gui_attr_basic_stylename">stylename</link> с именем стиля:<programlisting language="xml">&lt;label id=&quot;label1&quot; value=&quot;msg://labelVal&quot; stylename=&quot;boldlabel&quot;/&gt;</programlisting></para>
            <para>Таким образом, данный стиль будет применен только к тем надписям, для которых  определен атрибут <link linkend="gui_attr_basic_stylename">stylename</link> со значением <literal>boldlabel</literal>.</para>
          </listitem>
          <listitem>
            <para>Создание пользовательского стиля.</para>
            <para>Если не хватает стандартных средств изменения стиля компонента, есть возможность создать пользовательский стиль. </para>
            <para>Создадим пользовательский стиль, который будет применяться для компонента <link linkend="gui_Label">Label</link>. С помощью стиля содержимое компонента  <link linkend="gui_Label">Label</link> будет отображаться подчеркнутым.</para>
            <para>В первую очередь создадим класс-декоратор <code>UnderlinedLabelDecorator</code>:<programlisting language="java">public class UnderlinedLabelDecorator implements ComponentDecorator {

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public void decorate(Object component, Set&lt;String&gt; state) {
        DesktopLabel item = (DesktopLabel) component;
        JLabel jlabel = item.getComponent();

        Font originalFont = jlabel.getFont();
        Map attributes = originalFont.getAttributes();
        attributes.put(TextAttribute.UNDERLINE, TextAttribute.UNDERLINE_ON);
        jlabel.setFont(originalFont.deriveFont(attributes));
    }
}</programlisting></para>
            <para>Определим пользовательский стиль в файле <filename>nimbus.xml</filename>:<programlisting language="xml">&lt;theme xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/desktop-theme.xsd&quot;&gt;
    &lt;style name=&quot;label-underlined&quot; component=&quot;com.haulmont.cuba.desktop.gui.components.DesktopLabel&quot;&gt;
        &lt;custom class=&quot;com.sample.sales.desktop.gui.decorators.UnderlinedLabelDecorator&quot;/&gt;
    &lt;/style&gt;
&lt;/theme&gt;</programlisting></para>
            <para>В  атрибуте <sgmltag>component</sgmltag> элемента <sgmltag>style</sgmltag> содержится название компонента, к которому может быть применен стиль с названием <literal>label-underlined</literal>.</para>
            <para>В элементе <sgmltag>custom</sgmltag> указывается путь до класса-декоратора, определенного ранее.</para>
            <para>При описании элемента надписи, к которой нужно применить пользовательский стиль, нужно в атрибуте <sgmltag>stylename</sgmltag> указать название стиля:<programlisting language="xml">&lt;label id=&quot;label1&quot; stylename=&quot;label-underlined&quot; value=&quot;Label&quot;/&gt;</programlisting></para>
            <figure>
              <title>Компонент надписи с пользовательским стилем</title>
              <mediaobject>
                <imageobject>
                  <imagedata align="center" fileref="img/gui_themes_example6.png"/>
                </imageobject>
              </mediaobject>
            </figure>
          </listitem>
        </orderedlist>
      </section>
    </section>
    <section id="gui_web">
      <title>Специфика Web Client</title>
      <para>Реализация универсального пользовательского интерфейса в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname> основана на фреймворке <application>Vaadin</application>. Рассмотрим основные классы, входящие в состав инфраструктуры веб клиента.<figure>
          <title>Классы инфраструктуры Web Client</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/WebClientInfrastructure.png"/>
            </imageobject>
          </mediaobject>
        </figure></para>
      <itemizedlist>
        <listitem>
          <para><code>App</code> - центральный класс инфраструктуры приложения. Позволяет получить ссылки на <code>Connection</code>, <code>AppWindow</code> и другие объекты инфраструктуры. Экземпляр <code>App</code> существует в единственном экземпляре для данной HTTP-сессии пользователя.</para>
          <para>В конкретном приложении, как правило, создается собственный класс <code>App</code>, унаследованный от <code>DefaultApp</code> и, соответственно, от базового абстрактного <code>App</code> платформы. Это позволяет переопределить методы <code>createAppWindow()</code> и <code>createLoginWindow()</code> для создания   собственных реализаций главного окна и окна логина.</para>
          <para>Класс <code>App</code> приложения должен быть зарегистрирован в параметре <code>application</code> сервлета <code>app_servlet</code> в файле <link linkend="web.xml">web.xml</link> модуля <structname>web</structname>.</para>
        </listitem>
        <listitem>
          <para><code>Connection</code> - интерфейс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <link linkend="userSession">UserSession</link>. Стандартной реализацией этого интерфейса является класс <code>DefaultConnection</code>.</para>
        </listitem>
        <listitem>
          <para><code>AppUI</code> - класс платформы, унаследованный от класса <code>com.vaadin.ui.UI</code>. Экземпляр данного класса соответствует одной открытой вкладке веб браузера. Содержит ссылку на объект <code>UIView</code> - это может быть либо <code>LoginWindow</code>, либо <code>AppWindow</code>.</para>
          <para>Класс <code>AppUI</code> приложения должен быть зарегистрирован в параметре <code>UI</code> сервлета <code>app_servlet</code> в файле <filename>web/WEB-INF/web.xml</filename> модуля <structname>web</structname>. Как правило используется стандартный класс платформы.</para>
        </listitem>
        <listitem>
          <para><code>LoginWindow</code> - окно, отображаемое до логина пользователя. В конкретном приложении можно создать наследника <code>LoginWindow</code> и переопределить метод <code>createLoginWindow()</code> класса <code>App</code> для его использования.</para>
        </listitem>
        <listitem>
          <para><code>AppWindow</code> - главное окно приложения, отображаемое после логина пользователя. В конкретном приложении можно создать наследника <code>AppWindow</code> и переопределить метод <code>createAppWindow()</code> класса <code>App</code> для его использования.</para>
          <para>Без создания собственного наследника <code>AppWindow</code> можно управлять некоторыми параметрами главного окна с помощью следующих свойств приложения:<itemizedlist>
              <listitem>
                <para><link linkend="cuba.web.useLightHeader">cuba.web.useLightHeader</link> - включает формирование компактной вехней части окна - лого, строка меню, имя пользователя и кнопка логаута в одну строку. В выключенном состоянии методом <code>AppWindow.createTitleLayout()</code> формируется дополнительная область сверху.</para>
              </listitem>
              <listitem>
                <para><link linkend="cuba.web.foldersPaneEnabled">cuba.web.foldersPaneEnabled</link> - включает формирование <link linkend="folders_pane">панели папок</link> методом <code>AppWindow.createFoldersPane()</code>.</para>
              </listitem>
              <listitem>
                <para><link linkend="cuba.web.appWindowMode">cuba.web.appWindowMode</link> - задает начальный режим главного окна: с вкладками или одноэкранный (<code>TABBED</code> или <code>SINGLE</code>). Пользователь впоследствии может задать желаемый режим через экран <guimenu>Help</guimenu> &gt; <guimenu>Settings</guimenu>.</para>
              </listitem>
              <listitem>
                <para><link linkend="cuba.web.maxTabCount">cuba.web.maxTabCount</link> - в режиме представления главного окна с вкладками задает максимальное количество вкладок, которое может открыть пользователь. По умолчанию 7.</para>
              </listitem>
            </itemizedlist></para>
        </listitem>
        <listitem>
          <para><code>WindowManager</code> - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы <code>openWindow()</code>, <code>openEditor()</code>, <code>showMessageDialog()</code> и другие методы интерфейса <code>IFrame</code>, реализуемого <link linkend="screen_controller">контроллерами</link> экранов. Класс <code>WindowManager</code> расположен в общем модуле <structname>gui</structname> платформы и является абстрактным. В модуле <structname>web</structname> имеется конкретный класс <code>WebWindowManager</code>, реализующий специфику веб клиента.</para>
          <para>Как правило, <code>WindowManager</code> не используется в прикладном коде напрямую.</para>
        </listitem>
        <listitem>
          <para><code>ExceptionHandlers</code> - содержит коллекцию <link linkend="exceptionHandlers">обработчиков исключений клиентского уровня</link>.</para>
        </listitem>
      </itemizedlist>
      <section id="webComponentsHelper">
        <title>Работа с компонентами Vaadin </title>
        <para>Для работы непосредственно с компонентами Vaadin, реализующими интерфейсы <link linkend="gui_vcl">библиотеки визуальных компонентов</link> в <link linkend="app_tiers">блоке</link> <structname>Web Client</structname>, необходимо воспользоваться классом <code>WebComponentsHelper</code>. Он имеет два статических метода для получения ссылок на компоненты Vaadin:<itemizedlist>
            <listitem>
              <para><code>unwrap</code> - получить Vaadin-компонент для данного CUBA-компонента.</para>
            </listitem>
            <listitem>
              <para><code>getComposition</code> - получить Vaadin-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <link linkend="gui_Button">Button</link>, этот метод возвращает тот же объект, что и <code>unwrap()</code> - <code>com.vaadin.ui.Button</code>. Для сложных компонентов, например <link linkend="gui_Table">Table</link>, <code>unwrap()</code> вернет соответсвующий объект  <code>com.vaadin.ui.Table</code>, а <code>getComposition()</code> - объект  <code>com.vaadin.ui.VerticalLayout</code>, который содержит таблицу вместе с описанными вместе с ней <link linkend="gui_ButtonsPanel">ButtonsPanel</link> и <code>RowsCount</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Следует иметь в виду, что если экран расположен в модуле <structname>gui</structname> проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать <code>WebComponentsHelper.unwrap()</code> нужно либо расположить весь экран в модуле <structname>web</structname>, либо воспользоваться механизмом <link linkend="companions">компаньонов контроллеров</link>.</para>
      </section>
    </section>
    <section id="gui_desktop">
      <title>Специфика Desktop Client</title>
      <para>Реализация универсального пользовательского интерфейса в <link linkend="app_tiers">блоке</link> <structname>Desktop Client</structname> основана на  <application>Java Swing</application>. Рассмотрим основные классы, входящие в состав инфраструктуры десктоп клиента.<figure>
          <title>Классы инфраструктуры Desktop Client</title>
          <mediaobject>
            <imageobject>
              <imagedata align="center" fileref="img/DesktopClientInfrastructure.png"/>
            </imageobject>
          </mediaobject>
        </figure></para>
      <itemizedlist>
        <listitem>
          <para><code>App</code> - центральный класс инфраструктуры десктоп приложения. Содержит ссылки на <code>Connection</code> и главный <code>TopLevelFrame</code>, а также  методы инициализации и получения параметров приложения (см. ниже). </para>
          <para>В конкретном приложении необходимо  создать собственный класс-наследник <code>App</code> и переопределить в нем следующие методы:<itemizedlist>
              <listitem>
                <para><code>getDefaultAppPropertiesConfig</code> - должен возвращать строку, в которой через пробел перечислены <link linkend="app_properties_files">файлы свойств приложения</link>, например:<programlisting language="java">@Override
protected String getDefaultAppPropertiesConfig() {
    return &quot;/cuba-desktop-app.properties /desktop-app.properties&quot;;
}</programlisting></para>
              </listitem>
              <listitem>
                <para><code>getDefaultHomeDir</code> - должен вовращать путь к каталогу, в котором приложение будет хранить временные и рабочие файлы, например:<programlisting language="java">@Override
protected String getDefaultHomeDir() {
    return System.getProperty(&quot;user.home&quot;) + &quot;/.mycompany/sales&quot;;
}</programlisting></para>
              </listitem>
              <listitem>
                <para><code>getDefaultLog4jConfig</code> - должен возвращать имя файла настройки Log4J, если таковой определен в проекте. Например:<programlisting language="java">@Override
protected String getDefaultLog4jConfig() {
    return &quot;sales-log4j.xml&quot;;
}</programlisting></para>
              </listitem>
            </itemizedlist></para>
          <para>Кроме того, в собственном классе-наследнике <code>App</code> необходимо определить метод <code>main()</code> следующим образом:<programlisting language="java">public static void main(final String[] args) {
    SwingUtilities.invokeLater(new Runnable() {
        public void run() {
            app = new App();
            app.init(args);
            app.show();
            app.showLoginDialog();
        }
    });
}</programlisting></para>
        </listitem>
        <listitem>
          <para><code>Connection</code> - класс, обеспечивающий функциональность подключения к среднему слою и хранящий пользовательскую сессию <link linkend="userSession">UserSession</link>. </para>
        </listitem>
        <listitem>
          <para><code>LoginDialog</code> - диалог логина пользователя. В конкретном приложении можно создать наследника <code>LoginDialog</code> и переопределить метод <code>createLoginDialog()</code> класса <code>App</code> для его использования.</para>
        </listitem>
        <listitem>
          <para><code>TopLevelFrame</code> - наследник <code>JFrame</code>, являющийся окном самого верхнего уровня. В приложении существует как минимум один экземпляр данного класса, создаваемый при старте приложения и содержащий главное меню. Этот экземпляр возвращается методом <code>getMainFrame()</code> класса <code>App</code>.</para>
          <para>При отделении пользователем вкладок главного окна или компонента <link linkend="gui_TabSheet">TabSheet</link> (см. атрибут <code>detachable</code>) создаются дополнительные экземпляры <code>TopLevelFrame</code>, не содержащие главного меню.</para>
        </listitem>
        <listitem>
          <para><code>WindowManager</code> - центральный класс, реализующий логику работы экранов системы. Ему делегируются вызовы <code>openWindow()</code>, <code>openEditor()</code>, <code>showMessageDialog()</code> и другие методы интерфейса <code>IFrame</code>, реализуемого <link linkend="screen_controller">контроллерами</link> экранов. Класс <code>WindowManager</code> расположен в общем модуле <structname>gui</structname> платформы и является абстрактным. В модуле <structname>desktop</structname> имеется конкретный класс <code>DesktopWindowManager</code>, реализующий специфику десктоп клиента.</para>
          <para>Как правило, <code>WindowManager</code> не используется в прикладном коде напрямую.</para>
        </listitem>
        <listitem>
          <para><code>ExceptionHandlers</code> - содержит коллекцию <link linkend="exceptionHandlers">обработчиков исключений клиентского уровня</link>.</para>
        </listitem>
      </itemizedlist>
      <section id="desktopComponentsHelper">
        <title>Работа с компонентами Swing</title>
        <para>Для работы непосредственно с компонентами Swing, реализующими интерфейсы <link linkend="gui_vcl">библиотеки визуальных компонентов</link> в <link linkend="app_tiers">блоке</link> <structname>Desktop Client</structname>, необходимо воспользоваться классом <code>DesktopComponentsHelper</code>. Он имеет два статических метода для получения ссылок на компоненты Swing:<itemizedlist>
            <listitem>
              <para><code>unwrap</code> - получить Swing-компонент для данного CUBA-компонента.</para>
            </listitem>
            <listitem>
              <para><code>getComposition</code> - получить Swing-компонент, который является наиболее внешним контейнером в реализации данного CUBA-компонента. Для простых компонентов, например <link linkend="gui_Button">Button</link>, этот метод возвращает тот же объект, что и <code>unwrap()</code> - <code>javax.swing.JButton</code>. Для сложных компонентов, например <link linkend="gui_Table">Table</link>, <code>unwrap()</code> вернет соответсвующий объект  <code>org.jdesktop.swingx.JXTable</code>, а <code>getComposition()</code> - объект  <code>javax.swing.JPanel</code>, который содержит таблицу вместе с описанными вместе с ней <link linkend="gui_ButtonsPanel">ButtonsPanel</link> и <code>RowsCount</code>.</para>
            </listitem>
          </itemizedlist></para>
        <para>Следует иметь в виду, что если экран расположен в модуле <structname>gui</structname> проекта, то в его контроллере можно работать только с обобщенными интерфейсами CUBA-компонентов. Чтобы использовать <code>DesktopComponentsHelper.unwrap()</code> нужно либо расположить весь экран в модуле <structname>desktop</structname>, либо воспользоваться механизмом <link linkend="companions">компаньонов контроллеров</link>.</para>
      </section>
    </section>
    <section id="own_components">
      <title>Создание собственных компонентов</title>
      <para>В данном разделе рассматривается процесс создания и использования собственных визуальных компонентов приложения. Сначала мы возьмем сторонний компонент, доступный в виде дополнения (add-on) Vaadin, подключим его в проект и будем использовать в экране непосредственно. Затем выполним более тесную интеграцию - создадим для компонента новый <link linkend="gui_framework">GUI</link>-интерфейс  и загрузчик из XML, что позволит использовать его аналогично всем остальным компонентам платформы. </para>
      <section id="vaadin_addon">
        <title>Использование сторонних компонентов Vaadin</title>
        <para>В веб клиенте приложения можно использовать сторонние компоненты Vaadin, распространяемые в виде дополнений (add-ons). На данный момент в репозитории <ulink url="https://vaadin.com/directory">https://vaadin.com/directory</ulink> находится около 200 визуальных компонентов, совместимых с CUBA. Основное условие совместимости - компонент должен поддерживать Vaadin версии 7 и выше. </para>
        <para>Для подключения стороннего компонента в проекте необходимо выполнить следующее:<orderedlist>
            <listitem>
              <para>Добавить в проект модуль <structname>web-toolkit</structname>, выполняющий интеграцию с клиентской (браузерной) частью Vaadin-компонентов. Проще всего это сделать в <application>CUBA Studio</application>, выполнив команду <guibutton>Create web toolkit module</guibutton> секции <guilabel>Project properties</guilabel> навигатора. </para>
            </listitem>
            <listitem>
              <para>В <link linkend="build.gradle">build.gradle</link> проекта добавить зависимость модуля <structname>web</structname> от нужного add-on, например:<programlisting>configure(webModule) {
    ...
    dependencies {
        ...
        compile(&quot;org.vaadin.addons:some-addon:1.2.3&quot;)
    }</programlisting></para>
            </listitem>
            <listitem>
              <para>В созданный на шаге 1 файл <filename>AppWidgetSet.gwt.xml</filename> подключить набор виджетов add-on:<programlisting>&lt;module&gt;
    ...
    &lt;inherits name=&quot;org.vaadin.someaddon.widgetset.SomeAddonWidgetset&quot; /&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>В экране модуля <structname>web</structname> (либо в соответствующем <link linkend="companions">компаньоне</link>) получить ссылку на контейнер Vaadin с помощью класса <link linkend="webComponentsHelper">WebComponentsHelper</link>, создать экземпляр нового компонента, и добавить его в контейнер.</para>
            </listitem>
            <listitem>
              <para>Для изменения внешнего вида подключенного компонента можно создать в проекте <link linkend="web_theme">расширение темы</link> и внести в файл <filename>&lt;theme&gt;-ext.scss</filename> нужные изменения. Файлы темы проще всего создать в <application>Studio</application> командой <guibutton>Create theme extension</guibutton> секции <guilabel>Project properties</guilabel> навигатора.</para>
            </listitem>
          </orderedlist></para>
        <para>В <xref linkend="vaadin_addon_sample"/> рассмотрен процесс подключения и использования Vaadin-дополнения <application>Stepper</application>, содержащего визуальный компонент для пошагового изменения значения.</para>
      </section>
      <section id="own_gui_component">
        <title>Интеграция компонентов в Generic UI</title>
        <para>Интеграция &quot;нативного&quot; компонента в универсальный пользовательский интерфейс позволяет использовать его в большом количестве экранов с минимумом усилий - так же как и базовые компоненты платформы. Для полной интеграции необходимо выполнить следующие шаги:<orderedlist>
            <listitem>
              <para>Создать интерфейс компонента. Обычно интерфейсы располагаются в модуле <structname>gui</structname>, чтобы быть доступными обоим типам клиентов - веб и десктоп. Если же вы уверены, что компонент будет реализован только для одного типа клиента, интерфейс можно расположить в соответствующем модуле - <structname>web</structname> или <structname>desktop</structname>. Далее предполагается что компонент реализован только для веб клиента.</para>
              <para>Интерфейс компонента должен быть унаследован от <code>com.haulmont.cuba.gui.components.Component</code> или какого-либо его наследника, например <code>DatasourceComponent</code> или <code>Field</code>:<programlisting language="java">package com.company.myproject.gui.components;

import com.haulmont.cuba.gui.components.Component;

public interface MyComponent extends Component {

    String NAME = &quot;myComponent&quot;;

    int getSomeParameter();
    void setSomeParameter(int value);
}</programlisting></para>
              <para>В интерфейсе желательно определить константу <code>NAME</code>, содержащую строковое имя компонента для его получения через <code>ComponentsFactory</code>. Это же имя используется обычно как имя XML-элемента для работы с компонентом в XML-дескрипторах экранов.</para>
            </listitem>
            <listitem>
              <para>Создать класс имплементации компонента в модуле <structname>web</structname>.</para>
              <para>Класс компонента  рекомендуется унаследовать от <code>com.haulmont.cuba.web.gui.components.WebAbstractComponent</code> или какого-либо его наследника, например <code>WebAbstractField</code>. В конструкторе класса создается экземпляр &quot;нативного&quot; компонента, и ему делегируются вызовы методов GUI-интерфейса:<programlisting language="java">package com.company.myproject.web.components;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.web.gui.components.WebAbstractComponent;

public class WebMyComponent 
        extends WebAbstractComponent&lt;org.vaadin.someaddon.SomeComponent&gt; 
        implements MyComponent {

    public WebMyComponent() {
        component = new org.vaadin.someaddon.SomeComponent();
    }

    @Override
    public int getSomeParameter() {
        return component.getSomeParameter();
    }

    @Override
    public void setSomeParameter(boolean value) {
        component.setSomeParameter(value);
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Создать класс, имплементирующий интерфейс <code>ComponentPalette</code>, и из его метода <code>getComponents()</code> вернуть мэп имен своих компонентов на их классы реализации:<programlisting language="java">package com.company.myproject.web;

import com.company.myproject.gui.components.MyComponent;
import com.company.myproject.web.components.WebMyComponent;
import com.haulmont.cuba.gui.ComponentPalette;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.ComponentLoader;
import java.util.HashMap;
import java.util.Map;

public class AppComponentPalette implements ComponentPalette {

    @Override
    public Map&lt;String, Class&lt;? extends Component&gt;&gt; getComponents() {
        Map&lt;String, Class&lt;? extends Component&gt;&gt; components = new HashMap&lt;&gt;();
        components.put(MyComponent.NAME, WebMyComponent.class);
        return components;
    }

    @Override
    public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
        return Collections.emptyMap();
    }
}</programlisting></para>
              <para>Экземпляр палитры компонентов необходимо зарегистрировать в приложении. Это можно сделать в блоке инициализации класса <link linkend="gui_web">App</link>:<programlisting language="java">package com.company.myproject.web;

import com.haulmont.cuba.web.DefaultApp;
import com.haulmont.cuba.web.gui.WebUIPaletteManager;

public class App extends DefaultApp {

    static {
        WebUIPaletteManager.registerPalettes(new AppComponentPalette());
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>На данном этапе новый GUI-компонент доступен для получения через <code>ComponentsFactory</code>:<programlisting language="java" lang="">@Inject
private BoxLayout box;
@Inject
private ComponentsFactory componentsFactory;

@Override
public void init(Map&lt;String, Object&gt; params) {
    MyComponent myComponent = componentsFactory.createComponent(MyComponent.NAME);
    box.addComponent(myComponent);
    ...
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Для поддержки объявления компонента в XML-дескрипторах экранов необходимо создать класс-загрузчик компонента, реализующий интерфейс <code>com.haulmont.cuba.gui.xml.layout.ComponentLoader</code>. Класс-загрузчик рекомендуется унаследовать от класса <code>com.haulmont.cuba.gui.xml.layout.loaders.ComponentLoader</code> или какого-либо его наследника. Загрузчик оперирует только с GUI-интерфейсом компонента, поэтому он является общим для всех типов клиентов и  его можно разместить в модуле <structname>gui</structname>. В загрузчике достаточно вызвать унаследованный метод <code>loadComponent()</code>, который создает экземпляр компонента и устанавливает ему из XML общие свойства, такие как идентификатор, размеры и пр. После этого можно проинициализировать специфические свойства компонента:<programlisting language="java">package com.company.myproject.gui.loaders;

import com.company.myproject.gui.components.MyComponent;
import com.haulmont.cuba.gui.components.Component;
import com.haulmont.cuba.gui.xml.layout.*;
import org.dom4j.Element;

public class MyComponentLoader extends ComponentLoader {

    public MyComponentLoader(Context context, LayoutLoaderConfig config, ComponentsFactory factory) {
        super(context, config, factory);
    }

    @Override
    public Component loadComponent(ComponentsFactory factory, Element element, Component parent) {
        MyComponent component = (MyComponent) super.loadComponent(factory, element, parent);

        String someParameter = element.attributeValue(&quot;someParameter&quot;);
        if (someParameter != null) {
            component.setSomeParameter(Integer.valueOf(someParameter));
        }
        return component;
    }
}</programlisting></para>
              <para>Для того, чтобы система нашла загрузчик, необходимо зарегистрировать его с помощью метода <code>getLoaders()</code> созданной ранее палитры компонентов:<programlisting language="java">public class AppComponentPalette implements ComponentPalette {
    ...
    
    @Override
    public Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; getLoaders() {
        Map&lt;String, Class&lt;? extends ComponentLoader&gt;&gt; loaders = new HashMap&lt;&gt;();
        loaders.put(MyComponent.NAME, MyComponentLoader.class);
        return loaders;
    }
}</programlisting></para>
            </listitem>
            <listitem>
              <para>Теперь компонент можно использовать и в XML-дескрипторах экранов проекта:<programlisting language="xml">&lt;layout&gt;
    &lt;myComponent id=&quot;someId&quot; width=&quot;100%&quot; someParameter=&quot;10&quot;/&gt;
&lt;/layout&gt;</programlisting></para>
              <para>Для того, чтобы IDE подсказывала имя компонента и его атрибуты, можно определить собственную XSD и включать ее в экранах:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/window.xsd&quot;
        xmlns:app=&quot;http://schemas.company.com/app/0.1/app-components.xsd&quot;
        ...&gt;

    &lt;layout&gt;
        &lt;app:myComponent id=&quot;someId&quot; width=&quot;100%&quot; someParameter=&quot;10&quot;/&gt;
    &lt;/layout&gt;</programlisting></para>
            </listitem>
          </orderedlist></para>
        <para>В <xref linkend="own_gui_component_sample"/> рассмотрен процесс интеграции в универсальный  UI компонента <application>IntStepper</application>, предназначенного для пошагового изменения целого значения.</para>
      </section>
    </section>
    <section id="shortcuts">
      <title>Горячие клавиши</title>
      <para>В данном разделе приведена информация обо всех горячих клавишах (shortcuts), которые используются по умолчанию в универсальном пользовательском интерфейсе приложения. Все перечисленные ниже <link linkend="app_properties">свойства приложения</link> принадлежат интерфейсу <code>ClientConfig</code> и используются в блоках <structname>Web Client</structname> и <structname>Desktop Client</structname>. </para>
      <itemizedlist>
        <listitem>
          <para>Главное окно приложения.</para>
          <itemizedlist>
            <listitem>
              <para><keycap>CTRL-SHIFT-PAGE_DOWN</keycap> - переход на следующую вкладку. Настраивается свойством приложения <code>cuba.gui.nextTabShortcut</code>.</para>
            </listitem>
            <listitem>
              <para><keycap>CTRL-SHIFT-PAGE_UP</keycap> - переход на предыдущую вкладку. Настраивается свойством приложения <code>cuba.gui.previousTabShortcut</code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>Экраны.</para>
          <itemizedlist>
            <listitem>
              <para><keycap>ESCAPE</keycap> - закрыть текущий <link linkend="abstractWindow">экран</link>. Настраивается свойством приложения <code>cuba.gui.closeShortcut</code>.</para>
            </listitem>
            <listitem>
              <para><keycap>CTRL-ENTER</keycap> - закрыть текущий <link linkend="abstractEditor">экран редактирования</link> с  сохранением изменений. Настраивается свойством приложения <code>cuba.gui.commitShortcut</code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>Стандартные действия компонента-списка (<link linkend="gui_Table">Table</link>, <link linkend="gui_GroupTable">GroupTable</link>, <link linkend="gui_TreeTable">TreeTable</link>, <link linkend="gui_Tree">Tree</link>). Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом <code>setShortcut()</code>.</para>
          <itemizedlist>
            <listitem>
              <para><keycap>CTRL-INSERT</keycap> - вызов действия <link linkend="createAction">CreateAction</link>. Настраивается свойством приложения <code>cuba.gui.tableInsertShortcut</code>. </para>
            </listitem>
            <listitem>
              <para><keycap>CTRL-ALT-INSERT</keycap> - вызов действия <link linkend="addAction">AddAction</link>. Настраивается свойством приложения <code>cuba.gui.tableAddShortcut</code>.</para>
            </listitem>
            <listitem>
              <para><keycap>ENTER</keycap> - вызов действия <link linkend="editAction">EditAction</link>. Настраивается свойством приложения <code>cuba.gui.tableEditShortcut</code>.</para>
            </listitem>
            <listitem>
              <para><keycap>CTRL-DELETE</keycap> - вызов действий <link linkend="removeAction">RemoveAction</link> и <link linkend="excludeAction">ExcludeAction</link>. Настраивается свойством приложения <code>cuba.gui.tableRemoveShortcut</code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
        <listitem>
          <para>Стандартные действия поля выбора (<link linkend="gui_PickerField">PickerField</link>, <link linkend="gui_LookupPickerField">LookupPickerField</link>, <link linkend="gui_SearchPickerField">SearchPickerField</link>).  Кроме указанных свойств приложения горячая клавиша для конкретного экземпляра действия может быть установлена его методом <code>setShortcut()</code>.</para>
          <itemizedlist>
            <listitem>
              <para><keycap>CTRL-ALT-L</keycap> - вызов действия <link linkend="lookupAction">LookupAction</link>. Настраивается свойством приложения <code>cuba.gui.pickerShortcut.lookup</code>.</para>
            </listitem>
            <listitem>
              <para><keycap>CTRL-ALT-O</keycap> - вызов действия <link linkend="openAction">OpenAction</link>. Настраивается свойством приложения <code>cuba.gui.pickerShortcut.open</code>.</para>
            </listitem>
            <listitem>
              <para><keycap>CTRL-ALT-C</keycap> - вызов действия <link linkend="clearAction">ClearAction</link>. Настраивается свойством приложения <code>cuba.gui.pickerShortcut.clear</code>.</para>
            </listitem>
          </itemizedlist>
          <para>В полях выбора кроме вышеперечисленных горячих клавиш поддерживается вызов действий сочетанием <keycap>CTRL-ALT-1</keycap>, <keycap>CTRL-ALT-2</keycap> и так далее по количеству действий. То есть при нажатии сочетания клавиш <keycap>CTRL-ALT-1</keycap> произойдет вызов действия, которое описано первым в списке действий, при нажатии сочетания клавиш <keycap>CTRL-ALT-2</keycap> − вызов второго действия и так далее. Сочетание <keycap>CTRL-ALT</keycap> можно заменить другим, указав его в свойстве приложения <code>cuba.gui.pickerShortcut.modifiers</code>.</para>
        </listitem>
        <listitem>
          <para>Компонент <link linkend="gui_Filter">Filter</link>.</para>
          <itemizedlist>
            <listitem>
              <para><keycap>SHIFT-ENTER</keycap> - применить выбранный фильтр. Настраивается свойством приложения <code>cuba.gui.filterApplyShortcut</code>.</para>
            </listitem>
          </itemizedlist>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section id="portal">
    <title>Компоненты портала</title>
    <para>В данном руководстве <firstterm>порталом</firstterm> называется клиентский <link linkend="app_tiers">блок</link>, способный решать следующие задачи:<itemizedlist>
        <listitem>
          <para>предоставлять альтернативный веб-интерфейс, как правило, предназначенный для пользователей за пределами организации;</para>
        </listitem>
        <listitem>
          <para>предоставлять интерфейс для интеграции с мобильными приложениями и со сторонними системами.</para>
        </listitem>
      </itemizedlist></para>
    <para>Конкретное приложение может содержать несколько портальных модулей, предназначенных для различных целей, например, в случае приложения, автоматизирующего бизнес такси, это может быть публичный веб-сайт для клиентов, интеграционный модуль мобильного приложения заказа такси, интеграционный модуль мобильного приложения водителей, и т.д. </para>
    <para><link linkend="base_projects">Базовый проект</link> <structname>cuba</structname> платформы содержит в своем составе модуль <structname>portal</structname>, который является заготовкой для создания порталов в проектах. Он, во-первых, предоставляет базовую функциональность клиентского блока для работы с <structname>Middleware</structname>, а во-вторых, включает в себя универсальный <link linkend="rest_api">REST API</link> для работы с сущностями.</para>
    <section>
      <title>Базовая функциональность</title>
      <para>Рассмотрим основные компоненты, предоставляемые платформой для построения портала.<itemizedlist>
          <listitem>
            <para><code>PortalAppContextLoader</code> - загрузчик <code>
                <link linkend="appContext">AppContext</link>
              </code>, должен быть зарегистрирован в элементе <sgmltag>listener</sgmltag> файла <filename>web.xml</filename>.</para>
          </listitem>
          <listitem>
            <para><code>PortalDispatcherServlet</code> - центральный сервлет, распределяющий запросы по контроллерам <application>Spring MVC</application>, как для веб-интерфейса, так и для REST API. Набор файлов конфигурации контекста Spring определяется свойством приложения <property>
                <link linkend="cuba.dispatcherSpringContextConfig">cuba.dispatcherSpringContextConfig</link>
              </property>. Данный сервлет должен быть зарегистрирован в <filename>web.xml</filename> и отображен на корневой URL веб-приложения.</para>
          </listitem>
          <listitem>
            <para><code>App</code> - объект, содержащий информацию о текущем HTTP запросе и ссылку на объект <code>Connection</code>. Экземпляр <code>App</code> может быть получен в прикладном коде вызовом статического метода <code>App.getInstance()</code>.</para>
          </listitem>
          <listitem>
            <para><code>Connection</code> - позволяет выполнять логин и логаут пользователя на <structname>Middleware</structname>.</para>
          </listitem>
          <listitem>
            <para><code>PortalSession</code> - специфичесий для портала объект <link linkend="userSession">пользовательской сессии</link>. Возвращается интерфейсом инфраструктуры <code>
                <link linkend="userSessionSource">UserSessionSource</link>
              </code>, а также статическим методом <code>PortalSessionProvider.getUserSession()</code>.</para>
            <para>Имеет дополнительный метод <code>isAuthenticated()</code>, возвращающий <code>true</code>, если данная сессия принадлежит неанонимному, т.е. явно зарегистрировавшемуся с логином и паролем, пользователю.</para>
            <para>При первом обращении некоторого пользователя к порталу <code>SecurityContextHandlerInterceptor</code> создает для него (или привязывает уже имеющуюся) анонимную сессию, регистрируясь на <structname>Middleware</structname> с именем пользователя, указанным в свойстве приложения <property>
                <link linkend="cuba.portal.anonymousUserLogin">cuba.portal.anonymousUserLogin</link>
              </property>. Регистрация производится методом <code>
                <link linkend="login">loginTrusted()</link>
              </code>, поэтому в блоке портала необходимо установить также свойство <property>
                <link linkend="cuba.trustedClientPassword">cuba.trustedClientPassword</link>
              </property>. Таким образом, любой анонимный пользователь портала может работать с сервисами <structname>Middleware</structname> с правами пользователя <property>cuba.portal.anonymousUserLogin</property>.</para>
            <para>Если портал содержит страницу регистрации пользователя с именем и паролем, то после выполнения <code>Connection.login()</code> при обработке запросов <code>SecurityContextHandlerInterceptor</code> устанавливает в потоке выполнения пользовательскую сессию явно зарегистрированного пользователя, и работа с <structname>Middleware</structname> происходит от его имени.</para>
          </listitem>
          <listitem>
            <para><code>PortalLogoutHandler</code> - обрабатывает навигацию на страницу логаута. Должен быть зарегистрирован в файле <filename>portal-security-spring.xml</filename> проекта.</para>
          </listitem>
        </itemizedlist></para>
      <para>Пример портала, содержащего страницу регистрации пользователей, включен в шаблон проекта,  рассмотренный в  <xref linkend="qs_setup"/></para>
    </section>
    <section id="rest_api">
      <title>REST API</title>
      <para>Универсальный REST API платформы позволяет выполнять загрузку и сохранение  любых сущностей модели данных приложения посредством отправки простых HTTP запросов. Это открывает возможность легкой интеграции со сторонними приложениями самого широкого спектра − от JavaScript кода, выполняющегося в  браузере, до произвольных систем, работающих на Java, .NET, PHP или любой другой платформе. </para>
      <para>Основные возможности API:<itemizedlist>
          <listitem>
            <para>загрузка экземпляров сущностей из базы данных по идентификатору или по JPQL запросу с параметрами</para>
          </listitem>
          <listitem>
            <para>сохранение новых и измененных экземпляров, удаление экземпляров</para>
          </listitem>
          <listitem>
            <para>получение описания модели данных в формате HTML</para>
          </listitem>
          <listitem>
            <para>представление данных в форматах JSON и XML на выбор</para>
          </listitem>
          <listitem>
            <para>аутентификация пользователя</para>
          </listitem>
        </itemizedlist></para>
      <para>Все функции работают с данными в кодировке UTF-8. </para>
      <section>
        <title>Включение в проект</title>
        <para>REST API реализован в модуле <structname>portal</structname> базового проекта <structname>cuba</structname>, поэтому для его использования необходимо создать модуль <structname>portal</structname> в проекте приложения. Пример содержится в шаблоне проекта,  рассмотренном в  <xref linkend="qs_setup"/> </para>
        <para>Основные элементы настройки:<itemizedlist>
            <listitem>
              <para>Добавить контроллеры REST API в контекст Spring, определяемый файлом <filename>
                  <link linkend="dispatcher-spring.xml">portal-dispather-spring.xml</link>
                </filename>:<programlisting language="xml">&lt;context:component-scan base-package=&quot;com.haulmont.cuba.portal.restapi&quot;/&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Установить режим доступа в <filename>portal-security-spring.xml</filename>:<programlisting language="xml">&lt;intercept-url pattern=&quot;/api/**&quot; access=&quot;IS_AUTHENTICATED_ANONYMOUSLY&quot;/&gt;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Описание функций</title>
        <para>При стандартных настройках модуля <structname>portal</structname> все запросы к REST API должны иметь URL, начинающийся с <literal>{host:port}/app-portal/api</literal>.</para>
        <para>Все функции требуют наличия сессии аутентифицированного пользователя, то есть сначала  необходимо выполнить логин, и передавать полученный идентификатор сессии в последующие запросы.</para>
        <section id="rest_api.login">
          <title>Логин</title>
          <para>Логин можно выполнить либо GET, либо POST запросом.</para>
          <variablelist>
            <varlistentry>
              <term>GET запрос</term>
              <listitem>
                <para>В случае GET запроса сформируйте URL <code>{host:port}/app-portal/api/login</code> с параметрами:</para>
                <itemizedlist>
                  <listitem>
                    <para><emphasis role="bold">u</emphasis> − логин пользователя</para>
                  </listitem>
                  <listitem>
                    <para><emphasis role="bold">p</emphasis> − пароль пользователя</para>
                  </listitem>
                  <listitem>
                    <para><emphasis role="bold">l</emphasis> −  локаль пользователя (опционально)</para>
                  </listitem>
                </itemizedlist>
                <para>Например:</para>
                <programlisting>http://localhost:8080/app-portal/api/login?u=admin&amp;p=admin&amp;l=ru</programlisting>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>POST запрос</term>
              <listitem>
                <para>Для выполнения логина через POST необходимо выполнить запрос по адресу <code>{host:port}/app-portal/api/login</code>, при этом в теле запроса передается JSON (заголовок <code>Content-Type</code> имеет значение <code>application/json</code>) или форма (заголовок <code>Content-Type</code> имеет значение <code>application/x-www-form-urlencoded</code>)</para>
                <para>Пример  формата JSON:</para>
                <programlisting language="json">{
    &quot;username&quot; : &quot;admin&quot;,
    &quot;password&quot; : &quot;admin&quot;,
    &quot;locale&quot; : &quot;en&quot;
}</programlisting>
                <para>Пример формы:</para>
                <programlisting>username: admin
password: admin
locale: en</programlisting>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>В ответ сервис вернет <code>userSessionId</code> в теле ответа и статус 200, либо статус 401, если аутентификация не удалась.</para>
        </section>
        <section id="rest_api.logout">
          <title>Логаут</title>
          <para>Логаут также можно выполнить либо GET, либо POST запросом.</para>
          <variablelist>
            <varlistentry>
              <term>GET запрос</term>
              <listitem>
                <para>В случае GET запроса сформируйте URL <code>{host:port}/app-portal/api/logout</code> с параметром <emphasis role="bold">session</emphasis> - идентификатором текущей сессии, полученным вызовом <code>login</code>.</para>
                <para>Например:</para>
                <programlisting>http://localhost:8080/app-portal/api/logout?session=64f7d59d-2cf5-acfb-f4d3-f55b7882da72</programlisting>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>POST запрос</term>
              <listitem>
                <para>Для выполнения логина через POST необходимо выполнить запрос по адресу <code>{host:port}/app-portal/api/logout</code>, при этом в теле запроса передается JSON (заголовок <code>Content-Type</code> имеет значение <code>application/json</code>) или форма (заголовок <code>Content-Type</code> имеет значение <code>application/x-www-form-urlencoded</code>)</para>
                <para>Пример  формата JSON:</para>
                <programlisting language="json">{
    &quot;session&quot; : &quot;64f7d59d-2cf5-acfb-f4d3-f55b7882da72&quot;
}</programlisting>
                <para>Пример формы:</para>
                <programlisting>session: 64f7d59d-2cf5-acfb-f4d3-f55b7882da72</programlisting>
              </listitem>
            </varlistentry>
          </variablelist>
          <para>В ответ сервис вернет  статус 200.</para>
        </section>
        <section id="rest_api.find">
          <title>Загрузка экземпляра персистентного объекта из базы данных по идентификатору</title>
          <para>Для получения объекта необходимо выполнить GET запрос <code>{host:port}/app-portal/api/find.&lt;format&gt;?e=&lt;entityRef&gt;&amp;s=&lt;sessionId&gt;</code> с параметрами:</para>
          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">e</emphasis> − описание требуемого объекта в формате <code>&lt;entity-id&gt;</code> или <code>&lt;entity-id-view&gt;</code>(см. класс <code>EntityLoadInfo</code>), например, <code>sales$Order-43c61345-d23c-48fe-ab26-567504072f05-_local</code>. То есть формат позволяет указать  требуемое <link linkend="views">представление</link> загруженного объекта.</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">s</emphasis> − идентификатор текущей сессии.</para>
            </listitem>
          </itemizedlist>
          <para>Элемент запроса <emphasis role="bold">format</emphasis>  задает формат получения результата. Принимает два значения: <code>xml</code> или <code>json</code>.</para>
          <para>Пример запроса, возвращающего результат в формате <code>xml</code>:</para>
          <programlisting>http://localhost:8080/app-portal/api/find.xml?e=sales$Order-60885987-1b61-4247-94c7-dff348347f93-orderWithCustomer&amp;s=c38f6bf4-fae7-4ee6-a412-9d93ff243f23</programlisting>
          <para>Пример запроса, возвращающего результат в формате <code>json</code></para>
          <programlisting>http://localhost:8080/app-portal/api/find.json?e=sales$Order-60885987-1b61-4247-94c7-dff348347f93-orderWithCustomer&amp;s=c38f6bf4-fae7-4ee6-a412-9d93ff243f23</programlisting>
        </section>
        <section id="rest_api.query">
          <title>Выполнение JPQL запроса для выборки данных</title>
          <para>Для выполнения запроса необходимо выполнить GET запрос <code>{host:port}/app-portal/api/query.&lt;format&gt;?e=&lt;entity&gt;&amp;s=&lt;sessionId&gt;&amp;q=&lt;encoded query string&gt;&amp;param1=&lt;value 1&gt;$param1_type=&lt;type 1&gt;&amp;paramN=&lt;value N&gt;&amp;paramN_type=&lt;type N&gt;&amp;view=&lt;viewName&gt;&amp;firstResult=&lt;firstResult&gt;&amp;maxResults=&lt;maxResults&gt;</code> с параметрами:</para>
          <itemizedlist>
            <listitem>
              <para><emphasis role="bold">e</emphasis> − имя сущности</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">q</emphasis> − строка запроса к данным на <link linkend="jpql">JPQL</link>. Запрос может содержать параметры. Их значения указываются как значения одноименных параметров HTTP запроса.</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">s</emphasis> − идентификатор текущей сессии</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">view</emphasis> −  опционально, <link linkend="views">представление</link>, с которым требуется загружать данные</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">max</emphasis> − опционально, максимальное количество строк возвращаемых данных (аналогично JPA   <code>setMaxResults</code>)</para>
            </listitem>
            <listitem>
              <para><emphasis role="bold">first</emphasis> − опционально, номер первой строки возвращаемых данных (аналогично JPA <code>setFirstResult</code>)</para>
            </listitem>
          </itemizedlist>
          <para><emphasis role="bold">format</emphasis>  задает формат получения результата. Принимает два значения: <code>xml</code> или <code>json</code>.</para>
          <para>Например:</para>
          <programlisting>http://localhost:8080/app-portal/api/query.json?e=sales$Customer&amp;q=select%20c%20from%20sales$Customer%20c&amp;s=748e5d3f-1eaf-4b38-bf9d-8d838587367d&amp;view=_local</programlisting>
          <programlisting>http://localhost:8080/app-portal/api/query.json?e=sales$Customer&amp;q=select%20c%20from%20sales$Customer%20c%20where%20c.name=:specName&amp;s=748e5d3f-1eaf-4b38-bf9d-8d838587367d&amp;specName=Петров</programlisting>
          <para>Для каждого из передаваемых параметров можно явно указать его тип, добавив в запрос одноименный параметр с суффиксом <code>_type</code>. Например:</para>
          <programlisting>http://localhost:8080/app-portal/api/query.json?e=sales$Customer&amp;q=select%20c%20from%20sales$Customer%20c%20where%20c.name=:specName&amp;s=748e5d3f-1eaf-4b38-bf9d-8d838587367d&amp;specName=Петров&amp;specName_type=string</programlisting>
          <para>Указание типа параметра не является обязательным, но позволяет  избежать ошибок парсинга, если система не сможет определить тип.</para>
          <para>В общем случае тип стоит указывать лишь для строковых параметров, которые по какой-либо причине имеют формат более узких типов (дат, чисел, uuid), но должны интерпретироваться именно как строки.</para>
          <para>Список доступных типов можно увидеть в описании мета-модели (пункт меню <guimenu>Помощь</guimenu> −&gt; <guimenu>Модель данных</guimenu>) или получив <link linkend="getHTMLModel">HTML-описание модели</link>.</para>
        </section>
        <section id="rest_api.commit">
          <title>Коммит новых и измененных экземпляров, удаление</title>
          <para>Функция коммита позволяет выполнять операции над переданными ей объектами и возвращает их старое и новое состояния. Формат результата определяется тем, какой формат (JSON или XML) был использован для запроса (заголовок <code>Content-Type</code>). </para>
          <variablelist>
            <varlistentry>
              <term>Формат JSON</term>
              <listitem>
                <para>В качестве заголовка  <code>Content-Type</code> следует использовать  значение <code>application/json</code></para>
                <para>Создание  сущности покупателя с автоматически сгенерированным идентификатором:</para>
                <programlisting language="json">{
    &quot;commitInstances&quot;: [{
        &quot;id&quot;: &quot;NEW-sales$Customer&quot;,
        &quot;name&quot;: &quot;Saltikov&quot;,
        &quot;email&quot;: &quot;saltikov@mail.com&quot;
        }
    ]
}</programlisting>
                <para>Создание  сущности покупателя с указанным идентификатором:</para>
                <programlisting language="json">{
    &quot;commitInstances&quot;: [{
        &quot;id&quot;: &quot;NEW-sales$Customer-b32a6412-d4d9-11e2-a20b-87b22b1460c7&quot;,
        &quot;name&quot;: &quot;Titov&quot;,  
        &quot;email&quot;: &quot;titov@mail.com&quot;
        }
    ]
}</programlisting>
                <para>Создание  сущности заказа с указанием ссылки на новую сущность покупателя и заполнение атрибутами сущности данного покупателя:</para>
                <programlisting language="json">{
    &quot;commitInstances&quot;: [{
        &quot;id&quot;: &quot;NEW-sales$Order&quot;,
        &quot;amount&quot;: 15,
        &quot;customer&quot;: 
            {&quot;id&quot;: &quot;NEW-sales$Customer-b32e43e8-d4d9-11e2-8c8b-2b2939d67fff&quot;
            } 
        },{
            &quot;id&quot;: &quot;sales$Customer-b32e43e8-d4d9-11e2-8c8b-2b2939d67fff&quot;,
            &quot;name&quot;: &quot;Dudkin&quot;,
            &quot;email&quot;: &quot;dudkin@mail.com&quot;
           }
    ]
}</programlisting>
                <para>Изменение одновременно двух сущностей покупателей:</para>
                <programlisting language="json">{
    &quot;commitInstances&quot;: [{
          &quot;id&quot;: &quot;sales$Customer-b32e43e8-d4d9-11e2-8c8b-2b2939d67fff&quot;,
          &quot;email&quot;: &quot;dudkin@mail.ru&quot;      
        },
        {
          &quot;id&quot;: &quot;sales$Customer-32261b09-b7f7-4b8c-88cc-6dee6fa8e6ab&quot;,
          &quot;email&quot;: &quot;saltikov@mail.ru&quot;      
        }
    ]
}</programlisting>
                <para>Удаление сущности покупателя с поддержкой <link linkend="soft_deletion">мягкого удаления</link>:</para>
                <programlisting language="json">{
    &quot;removeInstances&quot;: [{
        &quot;id&quot;: &quot;sales$Customer-b32e43e8-d4d9-11e2-8c8b-2b2939d67fff&quot;
        }
    ],
    &quot;softDeletion&quot;: &quot;true&quot;
}</programlisting>
                <itemizedlist>
                  <listitem>
                    <para>Массив <code>commitInstances</code> содержит создаваемые или изменяемые сущности. </para>
                    <itemizedlist>
                      <listitem>
                        <para>При создании  сущности в качестве значения поля <code>id</code> указывается значение  <code>NEW-&lt;entityName&gt;</code> или <code>NEW-&lt;entityName&gt;-&lt;entityId&gt;</code>.</para>
                      </listitem>
                      <listitem>
                        <para>При изменении сущности в качестве значения поля <code>id</code> указывается значение <code>&lt;entityName&gt;-&lt;entityId&gt;</code>.</para>
                      </listitem>
                      <listitem>
                        <para>Далее в списке элементов через запятую указываются названия атрибутов создаваемой или изменяемой сущности и их значения.</para>
                      </listitem>
                    </itemizedlist>
                  </listitem>
                  <listitem>
                    <para>Массив <code>removeInstances</code> содержит удаляемые объекты. При удалении объекта обязательно указывать значение поля <code>id</code>. Перед удалением будет выполнен <code>merge()</code> переданных объектов, что позволяет, например, проверить, не изменилась ли версия удаляемого объекта.</para>
                  </listitem>
                  <listitem>
                    <para>Поле <code>softDeletion</code> управляет режимом <link linkend="soft_deletion">мягкого удаления</link>.</para>
                  </listitem>
                </itemizedlist>
                <para>Функция вызывается посредством POST обращения к <code>{host:port}/app-portal/api/commit?s=&lt;sessionId&gt;</code>.  JSON передается в теле запроса. Функция возвращает массив пар объектов JSON. Например, при изменении поля <code>email</code> у сущности  покупателя будет возвращен следующий массив пар объектов JSON:</para>
                <programlisting language="json">[
    [
        {&quot;id&quot;:&quot;sales$Customer-32261b09-b7f7-4b8c-88cc-6dee6fa8e6ab&quot;,
            &quot;createTs&quot;:null,
            &quot;createdBy&quot;:null,
            &quot;deleteTs&quot;:null,
            &quot;deletedBy&quot;:null,
            &quot;email&quot;:&quot;saltikovvvv@mail.ru&quot;,
            &quot;name&quot;:null,
            &quot;updateTs&quot;:null,
            &quot;updatedBy&quot;:null,
            &quot;version&quot;:null
        },
        {&quot;id&quot;:&quot;sales$Customer-32261b09-b7f7-4b8c-88cc-6dee6fa8e6ab&quot;,
            &quot;createTs&quot;:&quot;2013-06-14T14:07:15.040&quot;,
            &quot;createdBy&quot;:&quot;admin&quot;,
            &quot;deleteTs&quot;:null,
            &quot;deletedBy&quot;:null,
            &quot;email&quot;:&quot;saltikovvvv@mail.ru&quot;,
            &quot;name&quot;:&quot;Saltikov&quot;,
            &quot;updateTs&quot;:&quot;2013-06-14T15:07:03.463&quot;,
            &quot;updatedBy&quot;:&quot;admin&quot;,
            &quot;version&quot;:&quot;3&quot;
        }
    ]
]</programlisting>
                <para>Первым внутри пары возвращается переданный объект, вторым −  модифицированный объект.</para>
              </listitem>
            </varlistentry>
            <varlistentry>
              <term>Формат XML</term>
              <listitem>
                <para>В качестве заголовка  <code>Content-Type</code> следует использовать  значение <code>text/xml</code></para>
                <para>Пример формата XML</para>
                <programlisting language="xml">&lt;CommitRequest&gt;
    &lt;commitInstances&gt;
        &lt;instance id=&quot;sales$Customer-9873c8a8-d4e7-11e2-85c0-33423bc08c84&quot;&gt;
            &lt;basic name=&quot;name&quot;&gt;Sidorov&lt;/basic&gt;
            &lt;basic name=&quot;email&quot;&gt;sidorov@mail.com&lt;/basic&gt;
        &lt;/instance&gt;
    &lt;/commitInstances&gt;
    &lt;removeInstances&gt;
        &lt;instance id=&quot;sales$Order-d67c10f0-4d28-4904-afca-4bc45654985d&quot;/&gt;
    &lt;/removeInstances&gt;
    &lt;softDeletion&gt;true&lt;/softDeletion&gt;
&lt;/CommitRequest&gt;</programlisting>
                <para>Семантика полей XML-документа определяется в схеме <ulink url="http://schemas.haulmont.com/cuba/5.3/restapi-commit.xsd">http://schemas.haulmont.com/cuba/5.3/restapi-commit.xsd</ulink>.</para>
                <para>Функция вызывается посредством POST обращения к <code>{host:port}/app-portal/api/commit?s=&lt;sessionId&gt;</code>. XML  передается в теле запроса. Функция возвращает массив пар объектов  XML вида</para>
                <programlisting language="xml">&lt;mapping&gt;
    &lt;pair&gt;
        &lt;instance ...&gt;
        &lt;instance ...&gt;
    &lt;/pair&gt;
&lt;/mapping&gt;</programlisting>
                <para>Схема, содержащая  описание результата вызова функции, находится  по адресу <ulink url="http://schemas.haulmont.com/cuba/5.3/restapi-instances.xsd">http://schemas.haulmont.com/cuba/5.3/restapi-instances.xsd</ulink></para>
              </listitem>
            </varlistentry>
          </variablelist>
        </section>
        <section id="rest_download_file">
          <title>Загрузка файла из хранилища</title>
          <para>Для загрузки файла из <link linkend="file_storage">FileStorage</link> необходимо выполнить GET запрос <code>{host:port}/app-portal/api/download?f=&lt;fileDescriptorId&gt;&amp;s=&lt;sessionId&gt;</code> с параметрами:<itemizedlist>
              <listitem>
                <para><emphasis role="bold">f</emphasis> − идентификатор соответствующего экземпляра <code>FileDescriptor</code>.</para>
              </listitem>
              <listitem>
                <para><emphasis role="bold">s</emphasis> − идентификатор текущей сессии.</para>
              </listitem>
            </itemizedlist></para>
        </section>
        <section id="getHTMLModel">
          <title>Получение описания модели данных в формате HTML</title>
          <para>Обращение GET по адресу <code>/printDomain?s=&lt;sessionId&gt;</code> позволяет разработчику получить описание модели данных. Сервис возвращает простой HTML, содержайщий список имен базовых типов данных, описание всех сущностей метамодели, их атрибутов и определенных для сущностей <link linkend="views">представлений</link>.</para>
        </section>
        <section id="rest_api.deployViews">
          <title>Cоздание новых представлений на сервере</title>
          <para>Запрос POST по адресу <code>/deployViews?s=&lt;sessionId&gt;</code> позволяет загрузить на сервер нужные клиенту определения объектов-<link linkend="views">представлений</link>. Объекты-представления отсылаются в виде стандартного xml-описания представления, используемого в платформе. XML помещается в тело запроса. Подробнее о формате см. <xref linkend="views"/></para>
        </section>
      </section>
    </section>
  </section>
  <section id="optional_components">
    <title>Механизмы платформы</title>
    <para>В данной главе рассматриваются различные опциональные возможности, предоставляемые платформой.</para>
    <section id="scheduled_tasks">
      <title>Выполнение задач по расписанию</title>
      <para>Платформа предлагает два способа запуска задач по расписанию:<itemizedlist>
          <listitem>
            <para>Использование стандартного механизма <code>TaskScheduler</code> фреймворка <application>Spring</application></para>
          </listitem>
          <listitem>
            <para>Использование собственного механизма выполнения назначенных заданий</para>
          </listitem>
        </itemizedlist></para>
      <section id="scheduled_tasks_spring">
        <title>Spring TaskScheduler</title>
        <para>Данный механизм подробно описан в разделе <application>Task Execution and Scheduling</application> руководства <application>Spring Framework</application>.</para>
        <para><code>TaskScheduler</code> можно использовать для запуска методов произвольных бинов Spring в любом <link linkend="app_tiers">блоке</link> приложения - как на <structname>Middleware</structname>, так и на клиентском уровне.</para>
        <para>Пример конфигурации в файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename>:<programlisting language="xml">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
       xmlns:task=&quot;http://www.springframework.org/schema/task&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd
        http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task-3.0.xsd&quot;&gt;

    ...
    
    &lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
        &lt;task:scheduled ref=&quot;sales_Processor&quot; method=&quot;someMethod&quot; fixed-rate=&quot;60000&quot;/&gt;
        &lt;task:scheduled ref=&quot;sales_Processor&quot; method=&quot;someOtherMethod&quot; cron=&quot;0 0 1 * * MON-FRI&quot;/&gt;
    &lt;/task:scheduled-tasks&gt;
&lt;/beans&gt;</programlisting></para>
        <para>Здесь объявлены две задачи, запускающие на выполнение методы <code>someMethod()</code> и <code> someOtherMethod()</code> бина <code>sales_Processor</code>. При этом <code>someMethod()</code> запускается с момента старта приложения через фиксированные промежутки времени - 60 сек. Метод <code>someOtherMethod()</code> запускается в соответствии с расписанием, заданным выражением Cron (описание формата таких выражений см. <ulink url="http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger">http://quartz-scheduler.org/documentation/quartz-1.x/tutorials/crontrigger</ulink> ).</para>
        <para>Собственно запуск задач выполняет бин типа <code>TaskScheduler</code>, заданный в атрибуте <sgmltag>scheduler</sgmltag> элемента <sgmltag>scheduled-tasks</sgmltag>. В данном случае используется бин <code>CubaThreadPoolTaskScheduler</code> с именем <code>scheduler</code>, который сконфигурирован в модулях <structname>core</structname> и <structname>web</structname> базового проекта <structname>cuba</structname> (см. <filename>cuba-spring.xml</filename>, <filename>cuba-web-spring.xml</filename>). Этот класс содержит специфическую реализацию, выполняющую очистку <code>
            <link linkend="securityContext">SecurityContext</link>
          </code> в запускаемых на выполнение потоках.</para>
      </section>
      <section id="scheduled_tasks_cuba">
        <title>Назначенные задания CUBA</title>
        <para>Механизм назначенных заданий <application>CUBA</application> предназначен для запуска по расписанию методов произвольных бинов Spring в блоке <structname>Middleware</structname>. Целью данного механизма и отличием его от вышеупомянутого стандартного механизма <application> Spring Framework</application> являются: <itemizedlist>
            <listitem>
              <para>возможность конфигурирования заданий во время работы приложения   без остановки сервера</para>
            </listitem>
            <listitem>
              <para>координация выполнения синглтон-заданий в кластере <structname>Middleware</structname>, в том числе: <itemizedlist>
                  <listitem>
                    <para>надежная защита от одновременного выполнения </para>
                  </listitem>
                  <listitem>
                    <para>привязка заданий к серверам по приоритетам</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>Под <firstterm>синглтон</firstterm>-заданием понимается задача, которая должна выполняться в некоторый момент времени только на одном сервере. Пример - чтение из очереди и отсылка email.</para>
        <section>
          <title>Регистрация задания</title>
          <para>Задания регистрируются в таблице <code>SYS_SCHEDULED_TASK</code> базы данных, соответствующей сущности <code>ScheduledTask</code>. Для работы с заданиями существуют экраны просмотра и редактирования, доступные через меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Назначенные задания</guimenuitem>. </para>
          <para>Рассмотрим атрибуты задания:<itemizedlist>
              <listitem>
                <para><guilabel>Defined by</guilabel> - каким программным объектом реализуется задание. Возможные значения:<itemizedlist>
                    <listitem>
                      <para><guilabel>Bean</guilabel> - задание реализуется методом бина Spring. Дополнительные атрибуты:<itemizedlist>
                          <listitem>
                            <para><guilabel>Bean name</guilabel> - имя бина. Бин отображается в списке и доступен для выбора, только если у него есть интерфейс, содержащий подходящие для вызова из задания методы. Бины без интерфейса не поддерживаются.</para>
                          </listitem>
                          <listitem>
                            <para><guilabel>Method name</guilabel> - метод интерфейса бина для выполнения. Метод должен либо не иметь параметров, либо иметь все параметры типа <code>String</code>.</para>
                          </listitem>
                          <listitem>
                            <para><guilabel>Method parameters</guilabel> - параметры выбранного метода. Поддерживаются только параметры типа <code>String</code>.</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                    <listitem>
                      <para><guilabel>Class</guilabel> - задание представляет собой класс, реализующий интерфейс <code>java.util.concurrent.Callable</code>. Класс должен иметь открытый конструктор без параметров. Дополнительные атрибуты:<itemizedlist>
                          <listitem>
                            <para><guilabel>Class name</guilabel> - имя класса</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                    <listitem>
                      <para><guilabel>Script</guilabel> - задание представляет собой скрипт Groovy. Скрипт выполняется через <code>Scripting.<link linkend="scripting.runGroovyScript">runGroovyScript</link>()</code>. Дополнительные атрибуты:<itemizedlist>
                          <listitem>
                            <para><guilabel>Script name</guilabel> - имя скрипта.</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><guilabel>User name</guilabel> - имя пользователя, от имени которого будет будет выполняться задание. Если не задано, то задание будет выполнено от имени пользователя, указанного в свойстве приложения <property>
                    <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
                  </property>.</para>
              </listitem>
              <listitem>
                <para><guilabel>Singleton</guilabel> - признак, является ли задание синглтоном, т.е. выполняющимся только на одном сервере системы.</para>
              </listitem>
              <listitem>
                <para><guilabel>Scheduling type</guilabel> - способ планирования задачи:<itemizedlist>
                    <listitem>
                      <para><guilabel>Cron</guilabel> - с помощью Cron-выражения, представляющего собой последовательность из шести полей, разделенных пробелами: секунда, минута, час, день, месяц, день недели. Месяц и день недели могут быть представлены первыми тремя буквами английского названия. Примеры выражений:<itemizedlist>
                          <listitem>
                            <para>0 0 * * * * - начало каждого часа каждого дня.</para>
                          </listitem>
                          <listitem>
                            <para>*/10 * * * * * - каждые 10 секунд.</para>
                          </listitem>
                          <listitem>
                            <para>0 0 8-10 * * * - в 8, 9 и 10 часов каждого дня.</para>
                          </listitem>
                          <listitem>
                            <para>0 0/30 8-10 * * * - 8:00, 8:30, 9:00, 9:30 и 10 часов каждого дня.</para>
                          </listitem>
                          <listitem>
                            <para>0 0 9-17 * * MON-FRI - каждый час с 9 до 17 по рабочим дням.</para>
                          </listitem>
                          <listitem>
                            <para>0 0 0 7 1 ? - каждое Рождество в полночь.</para>
                          </listitem>
                        </itemizedlist></para>
                    </listitem>
                    <listitem>
                      <para><guilabel>Period</guilabel> - с помощью интервала между выполнениями.</para>
                    </listitem>
                  </itemizedlist></para>
              </listitem>
              <listitem>
                <para><guilabel>Period</guilabel> - период запуска задания в секундах для Scheduling type = Period. </para>
              </listitem>
              <listitem>
                <para><guilabel>Timeout</guilabel> - время в секундах, по истечении которого считается, что задание закончило выполнение, независимо от того, есть ли информация о завершении задания, или нет. Если  timeout не задан явно, он принимается равным 3 часам. </para>
              </listitem>
              <listitem>
                <para><guilabel>Start date</guilabel> - дата/время первого запуска для Scheduling type = Period. Если не установлено, то задание запускается сразу при старте сервера. Если установлено, то задание запускается в момент <code>startDate + period * N</code>, где N - целое число. </para>
                <para>Start date имеет смысл указывать только для &quot;нечастых&quot; заданий - раз в 1 час, 1 сутки и т.п. </para>
              </listitem>
              <listitem>
                <para><guilabel>Time frame</guilabel> - в случае заданного Start date или Cron expression определяет временное окно в секундах, в течение которого будет запущено задание, если время <code>startDate + period * N</code> прошло. Если Time frame не задано явно, оно принимается равным <code>period / 2</code>. </para>
                <para>Если Start date не указано, то Time frame не принимается во внимание, т.е. задание будет запущено в любое время после прохождения промежутка времени Period после предыдущего выполнения задания. </para>
              </listitem>
              <listitem>
                <para><guilabel>Permitted servers</guilabel>
- список перечисленных через запятую <link linkend="serverId">идентификаторов серверов</link>, на которых возможен запуск данного задания. Если список не задан, то задание может выполняться на любом сервере. </para>
                <para>Для синглтон-заданий порядок перечисления серверов указывает их приоритет - первый имеет больший приоритет чем последний. Сервер с большим приоритетом перехватит выполнение синглтона следующим образом: если сервер с большим приоритетом обнаруживает, что предыдущий раз задание было выполнено сервером с меньшим приоритетом, то он запускает задание независимо от того, пройден ли Period или нет. <warning>
                    <para>Приоритет серверов работает только в случае Scheduling type = Period и не указанного атрибута Start date. Если Start date указан, старт происходит в одно и то же время, и перехват невозможен.</para>
                  </warning></para>
              </listitem>
              <listitem>
                <para><guilabel>Log start</guilabel> - признак регистрации факта запуска задания в таблице <code>SYS_SCHEDULED_EXECUTION</code>, соответствующей сущности <code>ScheduledExecution</code>. </para>
                <para>Если задание является синглтоном, то в текущей реализации регистрация факта запуска производится в любом случае, независимо от данного признака. </para>
              </listitem>
              <listitem>
                <para><guilabel>Log finish</guilabel> - признак регистрации факта завершения задания в таблице <code>SYS_SCHEDULED_EXECUTION</code>, соответствующей сущности <code>ScheduledExecution</code>. </para>
                <para>Если задание является синглтоном, то в текущей реализации регистрация факта завершения производится в любом случае, независимо от данного признака. </para>
              </listitem>
              <listitem>
                <para><guilabel>Description</guilabel> - произвольное текстовое описание задания.</para>
              </listitem>
            </itemizedlist></para>
          <para>Задание также имеет признак активности, который устанавливается в экране списка заданий. Неактивные задания не запускаются. </para>
        </section>
        <section>
          <title>Управление обработкой заданий</title>
          <itemizedlist>
            <listitem>
              <para>Для запуска обработки назначенных заданий необходимо перед стартом сервера установить свойство приложения <property>
                  <link linkend="cuba.schedulingActive">cuba.schedulingActive</link>
                </property> в значение <code>true</code>.</para>
            </listitem>
            <listitem>
              <para>Для оперативного управления обработкой заданий можно использовать JMX-бин <code>app-core.cuba:type=Scheduling</code>, атрибут <code>Active</code> которого запускает/останавливает обработку заданий для текущего сеанса работы сервера. После перезапуска сервера обработка будет запущена только при установленном в <code>true</code> свойстве приложения <property>cuba.schedulingActive</property>.</para>
            </listitem>
            <listitem>
              <para>Все изменения в заданиях, сделанные через экраны системы, вступают в силу немедленно для всех серверов кластера. </para>
            </listitem>
            <listitem>
              <para>Для  удаления старой истории выполнения заданий можно использовать метод <code>removeExecutionHistory()</code> JMX-бина <code>app-core.cuba:type=Scheduling</code>. У него имееется два параметра:<itemizedlist>
                  <listitem>
                    <para><code>age</code> - время в часах, прошедшее после выполнения задания.</para>
                  </listitem>
                  <listitem>
                    <para><code>maxPeriod</code> - максимальный период заданий в часах, выполнения которых надо удалять. Это позволяет удалять только историю &quot;частых&quot; задач, а историю выполняемых, например, раз в сутки и реже, хранить без ограничений.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Данный метод можно вызывать автоматически, для этого достаточно создать новое задание и установить для него следующие параметры:<itemizedlist>
                  <listitem>
                    <para><guilabel>Bean name</guilabel> - cuba_SchedulingMBean</para>
                  </listitem>
                  <listitem>
                    <para><guilabel>Method name</guilabel> - removeExecutionHistory(String age, String maxPeriod) </para>
                  </listitem>
                  <listitem>
                    <para><guilabel>Method parameters</guilabel> - например age = 72, maxPeriod = 12.</para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist>
        </section>
        <section>
          <title>Особенности реализации</title>
          <itemizedlist>
            <listitem>
              <para>Период вызова обработки заданий (метода <code>SchedulingAPI.processScheduledTasks()</code>) задается в <filename>cuba-spring.xml</filename> и по умолчанию равен 1 сек. Он задает минимальное значение периода запуска задания, которое должно быть в 2 раза больше, т.е. 2 сек. Уменьшать эти времена не рекомендуется. </para>
            </listitem>
            <listitem>
              <para>Текущая реализация планировщика основана на синхронизации с помощью блокировки строк в таблице базы данных. Это означает, что при значительной нагрузке БД может не успевать вовремя отвечать планировщику, и необходимо увеличивать период запуска (&gt;1сек), и, соответственно, минимальный период запуска заданий также будет увеличиваться.</para>
            </listitem>
            <listitem>
              <para>Синглтон-задания в случае незаданного атрибута Permitted servers выполняются только на мастер-узле кластера (при выполнении прочих условий). Следует иметь в виду, что отдельный  сервер вне кластера также является мастером. </para>
            </listitem>
            <listitem>
              <para>Задание не запускается, если оно в данный момент не закончило предыдущее выполнение, и не истек указанный Timeout. Для синглтон-заданий в текущей реализации это обеспечивается информацией в базе данных, для не-синглтонов поддерживается таблица статуса выполнения в памяти сервера. </para>
            </listitem>
            <listitem>
              <para>Механизм выполнения создает и кэширует <link linkend="userSession">пользовательские сессии</link> в соответствии с указанными для заданий User name, либо свойством приложения <property>
                  <link linkend="cuba.jmxUserLogin">cuba.jmxUserLogin</link>
                </property>. Сессия доступна в потоке выполнения запускаемого задания обычным способом - через интерфейс <code>
                  <link linkend="userSessionSource">UserSessionSource</link>
                </code>.</para>
            </listitem>
          </itemizedlist>
          <warning>
            <para>Для нормальной работы синглтон-заданий необходима точная синхронизация серверов <structname>Middleware</structname> по времени!</para>
          </warning>
        </section>
      </section>
    </section>
    <section id="email_sending">
      <title>Отправка email</title>
      <para>Платформа предоставляет средства отправки сообщений электронной почты со следующими возможностями:<itemizedlist>
          <listitem>
            <para>Синхронная или асинхронная отправка. В случае синхронной отправки вызывающий код ожидает, пока сообщение не будет передано на SMTP сервер. При асинхронной отправке сообщение сохраняется в базе данных, и управление немедленно возвращается вызывающему коду. Отправка производится позже путем вызова из <link linkend="scheduled_tasks">назначенного задания</link>.  </para>
          </listitem>
          <listitem>
            <para>Надежная фиксация факта отправки и ошибок в базе данных, как для синхронной, так и для асинхронной отправки.</para>
          </listitem>
          <listitem>
            <para>Пользовательский интерфейс для поиска и просмотра информации о посылаемых сообщениях, включая все атрибуты и содержимое сообщений, а также статус отправки и количество предпринятых попыток.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Методы отправки</title>
        <para>Для отправки email на <structname>Middleware</structname> следует использовать бин <code>EmailerAPI</code>, на клиентском уровне - сервис <code>EmailService</code>.</para>
        <para>Рассмотрим основные методы этих компонентов:<itemizedlist>
            <listitem>
              <para><code>sendEmail()</code> -  синхронная отправка сообщения. Вызывающий код блокируется на время отправки сообщения SMTP серверу.</para>
              <para>Сообщение может быть передано как в виде набора параметров (список адресатов через запятую, тема, содержимое, массив вложений), так и в виде специального объекта <code>EmailInfo</code>, инкапсулирующего всю эту информацию, плюс позволяющего явно задать адрес отправителя и сформировать тело письма по шаблону <application>FreeMarker</application>.</para>
              <para>При синхронной отправке может быть сгенерировано исключение <code>EmailException</code>, несущее в себе информацию о том, по каким адресам отправка не удалась, и соответствующие им сообщения об ошибках.</para>
              <para>В процессе работы метода для каждого адресата в базе данных создается экземпляр сущности <code>SendingMessage</code>, который сначала получает статус <code>SendingStatus.SENDING</code>, а после успешной отправки - <code>SendingStatus.SENT</code>. В случае ошибки отправки статус сообщения меняется на <code>SendingStatus.NOTSENT</code>.</para>
            </listitem>
            <listitem>
              <para><code>sendEmailAsync()</code> - асинхронная отправка сообщения. Данный метод возвращает список (по числу получателей) экземпляров <code>SendingMessage</code> со статусом <code>SendingStatus.QUEUE</code>, созданных  в базе данных. Собственно отправка производится при последующем вызове метода <code>EmailManagerAPI.queueEmailsToSend()</code>, который необходимо зарегистрировать в механизме <link linkend="scheduled_tasks">назначенных заданий</link> с желаемой периодичностью.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Вложения</title>
        <para>Объект <code>EmailAttachment</code> - обёртка, хранящая вложение в виде массива байт (поле <code>data</code>), имя файла (поле <code>name</code>), и при необходимости, уникальный для данного сообщения идентификатор вложения (необязательное, но полезное поле <code>contentId</code>). </para>
        <para>Идентификатор вложения  может быть использован для вставки в сообщение изображений следующим образом:
при создании <code>EmailAttachment</code> задаётся уникальный <code>contentId</code>, например, <code>myPic</code>. В теле письма для вставки вложения необходимо в качестве пути использовать запись вида: <code>cid:myPic</code>. Т.е. для вставки изображения нужно указать следующий элемент HTML:<programlisting language="xml">&lt;img src=&quot;cid:myPic&quot;/&gt;</programlisting></para>
      </section>
      <section id="email_sending_properties">
        <title>Настройка параметров отправки email</title>
        <para>Параметры отправки  email могут быть настроены с помощью перечисленных ниже <link linkend="app_properties">свойств приложения</link>. Все они являются параметрами времени выполнения и хранятся в базе данных, однако могут быть переопределены для конкретного блока <structname>Middleware</structname> в его файле <filename>app.properties</filename>.</para>
        <para>Все параметры отправки email доступны через конфигурационный интерфейс <code>EmailerConfig</code>.</para>
        <itemizedlist>
          <listitem>
            <para><property>cuba.email.fromAddress</property> - адрес отправителя по умолчанию. Принимается во внимание, если не указан атрибут <code>EmailInfo.from</code>.</para>
            <para>Значение по умолчанию: <literal>DoNotReply@localhost</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpHost</property> - адрес SMTP сервера.</para>
            <para>Значение по умолчанию: <literal>test.host</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpPort</property> - порт SMTP сервера.</para>
            <para>Значение по умолчанию: <literal>25</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpAuthRequired</property> - требуется ли аутентификация на SMTP сервере. Соответствует параметру <literal>mail.smtp.auth</literal>, передаваемому при создании объекта <code>javax.mail.Session</code>.</para>
            <para>Значение по умолчанию: <literal>false</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpStarttlsEnable</property> - задает использование команды <literal>STARTTLS</literal> при аутентификации на SMTP сервере. Соответствует параметру <literal>mail.smtp.starttls.enable</literal>, передаваемому при создании объекта <code>javax.mail.Session</code>.</para>
            <para>Значение по умолчанию: <literal>false</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpUser</property> - имя пользователя для аутентификации на SMTP сервере.</para>
          </listitem>
          <listitem>
            <para><property>cuba.email.smtpPassword</property> - пароль пользователя для аутентификации на SMTP сервере.</para>
          </listitem>
          <listitem>
            <para><property>cuba.email.delayCallCount</property> - используется при асинхронной отправке email из очереди для пропуска нескольких первых вызовов <code>EmailManager.queueEmailsToSend()</code> сразу после старта сервера, чтобы снизить нагрузку во время инициализации приложения. Отправка email начнется следующим вызовом.</para>
            <para>Значение по умолчанию: <literal>2</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.messageQueueCapacity</property> - при асинхронной отправке количество сообщений, читаемое из очереди и отправляемое за один вызов <code>EmailManager.queueEmailsToSend()</code>.</para>
            <para>Значение по умолчанию: <literal>100</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.defaultSendingAttemptsCount</property> - при асинхронной отправке email количество попыток отправки по умолчанию. Принимается во внимание, если при вызове <code>Emailer.sendEmailAsync()</code> не указан параметр <code>attemptsCount</code>.</para>
            <para>Значение по умолчанию: <literal>10</literal></para>
          </listitem>
          <listitem>
            <para>cuba.email.maxSendingTimeSec - максимальное предполагаемое время в секундах, требуемое для отправки сообщения на SMTP сервер. Используется при асинхронной отправке для оптимизации выборки объектов <code>SendingMessage</code> из очереди в БД.</para>
            <para>Значение по умолчанию: 120</para>
          </listitem>
          <listitem>
            <para><property>cuba.email.sendAllToAdmin</property> - указывает, что все сообщения должны отправляться на адрес <property>cuba.email.adminAddress</property>, независимо от указанного адреса получателя. Этот параметр рекомендуется использовать во время отладки системы.</para>
            <para>Значение по умолчанию: <literal>false</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.email.adminAddress</property> - адрес, на который отправляются все сообщения при включенном свойстве <property>cuba.email.sendAllToAdmin</property>.</para>
            <para>Значение по умолчанию: <literal>admin@localhost</literal></para>
          </listitem>
          <listitem>
            <para><property>cuba.emailerUserLogin</property> - логин пользователя системы, под которым регистрируется механизм асинхронной отправки email для того, чтобы иметь возможность сохранить информацию в базе данных. Рекомендуется создать отдельного пользователя (например <literal>emailer</literal>) без пароля, чтобы под его именем нельзя было войти через пользовательский интерфейс приложения. Это полезно для поиска в логе сервера сообщений, касаемых отсылки email.</para>
            <para>Значение по умолчанию: <literal>admin</literal></para>
          </listitem>
        </itemizedlist>
        <para>Просмотреть текущие значения параметров, а также отправить тестовое сообщение, можно с помощью JMX-бина <code>app-core.cuba:type=Emailer</code>.</para>
      </section>
    </section>
    <section id="runtime_properties">
      <title>Динамические атрибуты</title>
      <para>Механизм динамических атрибутов предназначен для описания новых свойств сущностей на этапе настройки и эксплуатации системы. При этом для одного типа сущности может быть задано несколько наборов динамических атрибутов.</para>
      <figure>
        <title>Диаграмма классов механизма динамических атрибутов</title>
        <mediaobject>
          <imageobject>
            <imagedata align="center" fileref="img/RuntimeProperties.png"/>
          </imageobject>
        </mediaobject>
      </figure>
      <para>Рассмотрим приведенные на диаграмме классы.</para>
      <itemizedlist>
        <listitem>
          <para><code>CategorizedEntity</code> - базовый класс сущностей, которые могут иметь динамические атрибуты. Содержит ссылку на объект <code>Category</code>, т.е. каждый экземпляр сущности <code>SomeEntity</code> может быть отнесен к одной из определенных заранее категорий.</para>
        </listitem>
        <listitem>
          <para><code>Category</code> - определяет категорию объектов и соответствующий набор динамических атрибутов. Категория должна быть отнесена к некоторому типу сущности.</para>
          <para>Например, имеется сущность типа <userinput>Автомобиль</userinput>. Для нее можно определить две категории: <userinput>Грузовой</userinput> и <userinput>Пассажирский</userinput>. При этом категория <userinput>Грузовой</userinput>  будет содержать атрибуты <userinput>Грузоподъемность</userinput> и <userinput>Вид кузова</userinput>, а категория <userinput>Пассажирский</userinput> - атрибуты <userinput>Количество мест</userinput> и <userinput>Наличие детского сидения</userinput>.</para>
          <para>Атрибут <code>isDefault</code> указывает, что при создании нового экземпляра сущности для него автоматически выбирается данная категория.</para>
          <para>Атрибут <code>special</code> указывает, что данная категория обрабатывается в приложении специальным образом, и не отображается в универсальном UI редактирования категорий.</para>
        </listitem>
        <listitem>
          <para><code>CategoryAttribute</code> - определяет динамический атрибут, относящийся к некоторой категории. Содержит значение по умолчанию для различных типов данных. Значение перечислений задается в виде списка строк через запятую.</para>
        </listitem>
        <listitem>
          <para><code>CategoryAttributeValue</code> - значение динамического атрибута для конкретного экземпляра сущности.</para>
        </listitem>
      </itemizedlist>
      <para>Управление категориями и описаниями атрибутов осуществляется с помощью специальных экранов, доступных через меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Категории</guimenuitem>.</para>
      <section>
        <title>Применение</title>
        <para>Для того чтобы некоторая сущность могла иметь динамические атрибуты, ее класс необходимо унаследовать от <code>CategorizedEntity</code>, и, соответственно, обеспечить в таблице наличие поля <database>CATEGORY_ID</database> типа <code>UUID</code>.</para>
        <para>Для включения  динамических атрибутов в экран редактирования сущности необходимо выполнить следующее:<itemizedlist>
            <listitem>
              <para>В секции <sgmltag>dsContext</sgmltag> необходимо объявить два источника данных:<itemizedlist>
                  <listitem>
                    <para><sgmltag>runtimePropsDatasource</sgmltag> - специфический источник, в который будут загружены экземпляры <code>CategoryAttributeValue</code>. Атрибут <sgmltag>mainDs</sgmltag> должен ссылаться на главный источник данных, содержащий редактируемую сущность.</para>
                  </listitem>
                  <listitem>
                    <para>обычный <sgmltag>collectionDatasource</sgmltag> для загрузки списка категорий данного типа сущности</para>
                  </listitem>
                </itemizedlist></para>
              <para>Например:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;carDs&quot; 
                class=&quot;com.sample.app.entity.Car&quot; 
                view=&quot;carEdit&quot;/&gt;

    &lt;runtimePropsDatasource id=&quot;runtimePropsDs&quot; 
                            mainDs=&quot;carDs&quot;/&gt;

    &lt;collectionDatasource id=&quot;categories&quot; 
                          class=&quot;com.haulmont.cuba.core.entity.Category&quot; 
                          view=&quot;_local&quot;&gt;
        &lt;query&gt;
            select c from sys$Category c where c.entityType=&apos;app$Car&apos;
        &lt;/query&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;</programlisting></para>
            </listitem>
            <listitem>
              <para>Для отображения списка категорий и собственно динамических атрибутов используется визуальный компонент <sgmltag>runtimeProperties</sgmltag>:<programlisting language="xml">&lt;runtimeProperties id=&quot;runtimePropsFrame&quot; 
                   runtimeDs=&quot;runtimePropsDs&quot; 
                   categoriesDs=&quot;categories&quot; 
                   width=&quot;100%&quot;/&gt;</programlisting></para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section>
      <title>Пессимистичная блокировка</title>
      <para>В данном разделе описано применение пессимистичной блокировки  в CUBA-приложениях.</para>
      <section>
        <title>Блокировка редактирования сущностей</title>
        <para>Пессимистичная блокировка сущностей применяется, если велика вероятность одновременного редактирования одного и того же экземпляра, и стандартная <link linkend="optimistic_locking">оптимистичная блокировка</link>, основанная на версионности сущностей, порождает слишком много коллизий.</para>
        <para>Пессимистичная блокировка использует явное блокирование экземпляра сущности при открытии его в <link linkend="screen_edit">экране редактирования</link>. В результате только один пользователь  в некоторый момент времени может редактировать данный экземпляр сущности.</para>
        <para>Режим пессимистичной блокировки может быть задан для любого класса сущности в процессе настройки или эксплуатации системы. Для этого достаточно выполнить следующие действия:<itemizedlist>
            <listitem>
              <para>вставить в таблицу <database>SYS_LOCK_CONFIG</database> запись со следующими значениями полей:<itemizedlist>
                  <listitem>
                    <para><database>ID</database> - произвольный идентификатор типа UUID.</para>
                  </listitem>
                  <listitem>
                    <para><database>NAME</database> - наименование блокируемого объекта. Для сущности это должно быть имя ее <link linkend="metaClass">мета-класса</link>. </para>
                  </listitem>
                  <listitem>
                    <para><database>TIMEOUT_SEC</database> - таймаут истечения блокировки в секундах.</para>
                  </listitem>
                </itemizedlist></para>
              <para>Например: <programlisting>insert into sys_lock_config (id, create_ts, name, timeout_sec) values (newid(), current_timestamp, &apos;sales$Order&apos;, 300)</programlisting></para>
            </listitem>
            <listitem>
              <para>перезапустить сервер или выполнить метод <code>reloadConfiguration()</code> JMX-бина <code>app-core.cuba:type=LockManager</code>.</para>
            </listitem>
          </itemizedlist></para>
      </section>
      <section>
        <title>Блокировка произвольных процессов</title>
        <para>Механизм пессимистичной блокировки можно использовать также для управления совместным выполнением произвольных процессов. Причем блокировки являются распределенными, т.к. информация о них реплицируется в кластере  <structname>Middleware</structname>. </para>
        <para>Подробнее см. JavaDoc интерфейсов <code>LockManagerAPI</code> и <code>LockService</code>.</para>
      </section>
      <section>
        <title>Мониторинг блокировок</title>
        <para>Текущее состояние блокировок можно отслеживать через JMX-бин <code>app-core.cuba:type=LockManager</code>, или через специальный экран, доступный в меню <guimenu>Администрирование</guimenu> -&gt; <guimenuitem>Блокировки</guimenuitem>. Экран также позволяет разблокировать любой объект принудительно. </para>
      </section>
    </section>
    <section id="entity_statistics">
      <title>Статистика сущностей</title>
      <para>Механизм статистики сущностей  предоставляет данные о текущем количестве экземпляров сущностей в базе данных. Эти данные используются для автоматического принятия решений о выборе способа поиска связанных сущностей и ограничении размера выборок в экранах пользовательского интерфейса.</para>
      <para>Статистика хранится  в таблице <database>SYS_ENTITY_STATISTICS</database>, соответствующей сущности <code>EntityStatistics</code>. Заполнить статистику можно как вручную, внося соответствующие записи в таблицу, так и автоматически с помощью метода <code>refreshStatistics()</code> JMX-бина <code>
          <link linkend="persistenceManagerMBean">PersistenceManagerMBean</link>
        </code>. При указании в качестве параметра имени сущности статистика будет собрана только для данной сущности, в противном случае - для всех. Сбор статистики может занять значительное время и вызвать нежелательную нагрузку на БД, поэтому выполнять его нужно либо вручную, либо <link linkend="scheduled_tasks_cuba">назначенным заданием</link>   в подходящее время.</para>
      <para>Программный доступ к статистике осуществляется с помощью интерфейса <code>PersistenceManagerAPI</code> на <structname>Middleware</structname> и <code>PersistenceManagerService</code> на клиентском уровне. Статистика кэшируется в памяти, поэтому если изменения статистики вносятся напрямую в базу данных, для вступления их в силу необходимо перезапустить сервер или вызвать метод <code>PersistenceManagerMBean.flushStatisticsCache()</code>.</para>
      <para>Рассмотрим атрибуты <code>EntityStatistics</code> и их влияние на поведение системы.<itemizedlist>
          <listitem>
            <para><code>name</code> (колонка <database>NAME</database>) - тип сущности в виде имени <link linkend="metaClass">мета-класса</link>, например, <code>sales$Customer</code>.</para>
          </listitem>
          <listitem>
            <para><code>instanceCount</code> (колонка <database>INSTANCE_COUNT</database>) - примерное текущее количество экземпляров сущности. </para>
          </listitem>
          <listitem>
            <para><code>fetchUI</code> (колонка <database>FETCH_UI</database>) - размер страницы данных, предлагаемый пользователю при извлечении списков сущностей. </para>
            <para>Например, компонент <link linkend="gui_Filter">
                <code>Filter</code>
              </link> устанавливает это число в поле <guilabel>Показывать N строк</guilabel>.</para>
          </listitem>
          <listitem>
            <para><code>maxFetchUI</code> (колонка <database>MAX_FETCH_UI</database>) - максимальное количество экземпляров сущности, которое может быть извлечено и передано на клиентский уровень. </para>
            <para>Данный параметр играет роль при отображении списков сущностей в компонентах типа <code>
                <link linkend="gui_LookupField">LookupField</link>
              </code> и <code>
                <link linkend="gui_LookupPickerField">LookupPickerField</link>
              </code>, а также в таблицах без универсального <link linkend="gui_Filter">фильтра</link>, то есть когда на связанный <link linkend="datasources">источник данных</link> не налагается ограничений методом <code>CollectionDatasource.setMaxResults()</code>.  В этом случае сам источник данных ограничивает количество извлекаемых экземпляров значением <code>maxFetchUI</code>.</para>
          </listitem>
          <listitem>
            <para><code>lookupScreenThreshold</code> (колонка <database>LOOKUP_SCREEN_THRESHOLD</database>) - порог количества экземпляров сущности, при превышении которого в универсальных механизмах пользовательского интерфейса для поиска связанных сущностей будут использоваться <link linkend="screen_lookup">экраны выбора</link>  вместо выпадающих списков. </para>
            <para>В частности, этот параметр принимается во внимание компонентом <code>
                <link linkend="gui_Filter">Filter</link>
              </code> при выборе параметров фильтрации: до достижения порога используется компонент <code>
                <link linkend="gui_LookupField">LookupField</link>
              </code>, при превышении порога - компонент <code>
                <link linkend="gui_PickerField">PickerField</link>
              </code>. Поэтому, если необходимо заставить фильтр отображать выбор параметра некоторого типа через экран выбора, достаточно внести запись статистики для этой сущности со значением <code>lookupScreenThreshold</code> меньшим, чем <code>instanceCount</code>.</para>
          </listitem>
        </itemizedlist></para>
      <para>JMX-бин <code>PersistenceManagerMBean</code> в атрибутах <code>DefaultFetchUI</code>, <code>DefaultMaxFetchUI</code>, <code>DefaultLookupScreenThreshold</code> позволяет задать значения вышеперечисленных параметров по умолчанию. В результате, если для некоторой сущности статистика отсутствует (что является обычной ситуацией), будет использоваться соответствующий параметр по умолчанию. </para>
      <para>Кроме того, JMX-бин <code>PersistenceManagerMBean</code> позволяет ввести данные статистики для конкретной сущности с помощью операции <code>enterStatistics()</code>. Например, для того, чтобы для сущности <code>sales$Customer</code> установить размер страницы данных по умолчанию в 1000, а максимальное количество извлекаемых экземпляров в компонентах <link linkend="gui_LookupField">LookupField</link> в 30000, следует вызвать операцию <code>enterStatistics()</code> со следующими параметрами:<programlisting>entityName: sales$Customer
fetchUI: 1000
maxFetchUI: 30000</programlisting></para>
    </section>
    <section id="entity_log">
      <title>Журнал изменений сущностей</title>
      <para>Механизм журналирования предназначен для отслеживания изменений атрибутов произвольных сущностей в процессе работы приложения. Измененные значения сохраняются в специальной таблице базы данных, список изменений для конкретного экземпляра сущности может быть отображен в пользовательском интерфейсе.</para>
      <para>Данный механизм перехватывает сохранение сущностей в БД  на уровне <link linkend="entity_listeners">Entity Listeners</link>, т.е. гарантированно отслеживаются все изменения, проходящие через персистентный контекст <code>
          <link linkend="entityManager">EntityManager</link>
        </code>. Непосредственное изменение сущностей в базе данных с помощью SQL, в том числе изнутри системы через <link linkend="nativeQuery">
          <code>NativeQuery</code>
        </link> и <code>
          <link linkend="queryRunner">QueryRunner</link>
        </code>, в журнал не попадает.  </para>
      <para>Измененные экземпляры сущностей перед сохранением в БД отправляются в  методы <code>registerCreate()</code>, <code>registerModify()</code>, <code>registerDelete()</code> бина <code>EntityLogAPI</code>. Параметр <code>auto</code> этих методов позволяет отделить автоматическое журналирование посредством Entity Listeners от ручного вызова этих же методов в прикладном коде. При вызове из Entity Listeners в параметре <code>auto</code> передается <code>true</code>. </para>
      <para>Журнал содержит информация о том, кто и  когда изменил данный экземпляр, а также новые значения измененных атрибутов. Записи журнала сохраняются в таблице <database>SEC_ENTITY_LOG</database> базы данных, соответствующей сущности <code>EntityLogItem</code>. Измененные значения атрибутов хранятся в этой же таблице в колонке <database>CHANGES</database>, а при чтении на <structname>Middleware</structname> преобразуются в экземпляры сущности <code>EntityLogAttr</code>. </para>
      <section>
        <title>Настройка журналирования</title>
        <para>Аудит настраивается при помощи сущностей <code>LoggedEntity</code> и <code>LoggedAttribute</code> (соответствующих таблицам <database>SEC_LOGGED_ENTITY</database> и <database>SEC_LOGGED_ATTR</database>).</para>
        <para><code>LoggedEntity</code> описывает тип сущности, изменения которой необходимо журналировать. Атрибуты <code>LoggedEntity</code>:</para>
        <itemizedlist>
          <listitem>
            <para><code>name</code> (колонка <database>NAME</database>) - тип сущности в виде имени <link linkend="metaClass">мета-класса</link>, например, <code>sales$Customer</code>.</para>
          </listitem>
          <listitem>
            <para><code>auto</code> (колонка <database>AUTO</database>) - нужно ли журналировать изменения при вызове <code>EntityLogAPI</code> с параметром <code>auto = true</code> (т.е. из <link linkend="entity_listeners">Entity Listeners</link>).</para>
          </listitem>
          <listitem>
            <para><code>manual</code> (колонка <database>MANUAL</database>) - нужно ли журналировать изменения при вызове <code>EntityLogAPI</code> с параметром <code>auto = false</code>.</para>
          </listitem>
        </itemizedlist>
        <para><code>LoggedAttribute</code> описывает журналируемый атрибут сущности и содержит ссылку на <code>LoggedEntity</code> и имя атрибута.</para>
        <para>Для настройки журналирования некоторой сущности достаточно внести соответствующие записи в таблицы <database>SEC_LOGGED_ENTITY</database> и <database>SEC_LOGGED_ATTR</database>. Например, для ведения журнала изменений атрибутов <code>name</code>  и <code>grade</code> сущности <code>Customer</code>, необходимо выполнить:<programlisting>insert into SEC_LOGGED_ENTITY (ID, CREATE_TS, CREATED_BY, NAME, AUTO, MANUAL) 
values (&apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, now(), &apos;admin&apos;, &apos;sales$Customer&apos;, true, true);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME) 
values (newid(), now(), &apos;admin&apos;, &apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, &apos;name&apos;);

insert into SEC_LOGGED_ATTR (ID, CREATE_TS, CREATED_BY, ENTITY_ID, NAME) 
values (newid(), now(), &apos;admin&apos;, &apos;25eeb644-e609-11e1-9ada-3860770d7eaf&apos;, &apos;grade&apos;);</programlisting></para>
        <para>Для активации механизма журналирования необходимо установить в <code>true</code> атрибут <code>Enabled</code> JMX-бина <code>app-core.cuba:type=EntityLog</code>. Для вступления в силу изменений настройки журналирования, произведенных во время работы приложения, необходимо перезапустить сервер или вызвать метод <code>invalidateCache()</code> этого же бина.</para>
      </section>
      <section>
        <title>Отображение журнала</title>
        <para>Для просмотра журнала изменений некоторого экземпляра сущности достаточно обычным способом загрузить в источники данных экрана коллекцию экземпляров <code>EntityLogItem</code> и ассоциированных с ними <code>EntityLogAttr</code>, и  создать визуальные компоненты, связанные с этими источниками. Например:<programlisting language="xml">&lt;dsContext&gt;
    &lt;datasource id=&quot;customerDs&quot; 
                class=&quot;com.sample.sales.entity.Customer&quot; 
                view=&quot;customerEdit&quot;/&gt;

    &lt;collectionDatasource id=&quot;logDs&quot; 
                          class=&quot;com.haulmont.cuba.security.entity.EntityLogItem&quot; 
                          view=&quot;logView&quot;&gt;
        &lt;query&gt;
            select i from sec$EntityLog i 
            where i.entityId = :ds$customerDs order by i.eventTs
        &lt;/query&gt;

        &lt;collectionDatasource id=&quot;logAttrDs&quot; 
                              property=&quot;attributes&quot;/&gt;
    &lt;/collectionDatasource&gt;
&lt;/dsContext&gt;
&lt;layout&gt;
...
    &lt;split orientation=&quot;vertical&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;

        &lt;table id=&quot;logTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
            &lt;columns&gt;
                &lt;column id=&quot;eventTs&quot;/&gt;
                &lt;column id=&quot;user.login&quot;/&gt;
                &lt;column id=&quot;type&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;logDs&quot;/&gt;
        &lt;/table&gt;

        &lt;table id=&quot;logAttrTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
            &lt;columns&gt;
                &lt;column id=&quot;name&quot;/&gt;
                &lt;column id=&quot;value&quot;/&gt;
            &lt;/columns&gt;
            &lt;rows datasource=&quot;logAttrDs&quot;/&gt;
        &lt;/table&gt;

    &lt;/split&gt;
...
&lt;/layout&gt;</programlisting></para>
        <para>Для отображения локализованных значений журналируемых атрибутов эти атрибуты должны содержать аннотацию <link linkend="localizedValue_annotation">
            <code>@LocalizedValue</code>
          </link>. При ее наличии механизм журналирования заполняет поле <code>EntityLogAttr.messagesPack</code>, и таблица, отображающая значения атрибутов из примера выше может использовать колонку <code>locValue</code> вместо <code>value</code>:<programlisting language="xml">&lt;table id=&quot;logAttrTable&quot; width=&quot;100%&quot; height=&quot;100%&quot;&gt;
    &lt;columns&gt;
        &lt;column id=&quot;name&quot;/&gt;
        &lt;column id=&quot;locValue&quot;/&gt;
    &lt;/columns&gt;
    &lt;rows datasource=&quot;logAttrDs&quot;/&gt;
&lt;/table&gt;</programlisting></para>
      </section>
    </section>
    <section id="entity_snapshots">
      <title>Снимки сущностей</title>
      <para>Механизм сохранения снимков сущностей, так же как и <link linkend="entity_log">журнал изменений</link>, предназначен для отслеживания изменений данных в процессе работы приложения. Его отличительными особенностями являются:<itemizedlist>
          <listitem>
            <para>Сохраняются не изменения некоторых атрибутов одного экземпляра, а состояние (снимок) целого графа сущностей, определяемого заданным <link linkend="views">представлением</link>.</para>
          </listitem>
          <listitem>
            <para>Процесс сохранения снимка вызывается явно из кода клиентского уровня.</para>
          </listitem>
          <listitem>
            <para>Платформа предоставляет возможность просмотра  и сравнения между собой сохраненных снимков.</para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Сохранение снимков</title>
        <para>Для сохранения снимка некоторого графа сущностей достаточно вызвать метод <code>EntitySnapshotService.createSnapshot()</code> и передать ему основную сущность графа и  <link linkend="views">представление</link>, описывающее граф. Снимок создается по загруженной сущности, никаких обращений к базе данных не производится, поэтому снимок в результате содержит не больше полей, чем представление, с которым была загружена основная сущность.</para>
        <para>Граф Java объектов преобразуется в XML и сохраняется в базе данных вместе со ссылкой на основную сущность в таблице <database>SYS_ENTITY_SNAPSHOT</database>, соответствующей сущности <code>EntitySnapshot</code>.  </para>
        <para>Как правило, снимки требуется сохранять после коммита <link linkend="screen_edit">экрана редактирования</link>. Для этого можно переопределить метод <code>postCommit()</code> контроллера экрана, например:<programlisting language="java">public class CustomerEditor extends AbstractEditor&lt;Customer&gt; {

    @Inject
    protected Datasource&lt;Customer&gt; customerDs;

    @Inject
    protected EntitySnapshotService entitySnapshotService;

...
    @Override
    protected boolean postCommit(boolean committed, boolean close) {
        if (committed) {
            entitySnapshotService.createSnapshot(customerDs.getItem(), customerDs.getView());
        }
        return super.postCommit(committed, close);
    }
}</programlisting></para>
      </section>
      <section>
        <title>Отображение снимков</title>
        <para>Для отображения сохраненных для некоторой сущности снимков можно использовать фрейм <filename>com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml</filename>, например:<programlisting language="xml">&lt;iframe id=&quot;diffFrame&quot; 
        src=&quot;/com/haulmont/cuba/gui/app/core/entitydiff/diff-view.xml&quot;
        width=&quot;100%&quot; 
        height=&quot;100%&quot;/&gt;</programlisting></para>
        <para>В контроллере экрана редактирования необходимо вызвать загрузку снимков во фрейм:<programlisting language="java">public class CustomerEditor extends AbstractEditor&lt;Customer&gt; {

    @Inject
    protected EntityDiffViewer diffFrame;

...
    @Override
    protected void postInit() {
        if (!PersistenceHelper.isNew(getItem())) {
            diffFrame.loadVersions(getItem());
        }
    }
}</programlisting></para>
        <para>Фрейм <filename>diff-view.xml</filename> отображает список сохраненных для данной сущности снимков с возможностью их сравнения. Для каждого снимка указывается пользователь, дата и время сохранения. При выборе из списка некоторого снимка сущности в таблице сравнения показываются изменения  данных по сравнению с предыдущим снимком. В первом снимке измененными считаются все атрибуты. Если выбрано два снимка, то в таблицу   выводится результат их сравнения.
</para>
        <para>В таблице сравнения отображаются имена атрибутов и их новые значения, при выборе строки показывается детальная информация по изменениям атрибута в двух снимках. Ссылочные поля выводятся в соответствии с их шаблоном <link linkend="namePattern">
            <code>@NamePattern</code>
          </link>. При сравнении коллекций добавленные и удаленные элементы выделяются цветом (зеленый, красный), а элементы с измененными атрибутами остаются без выделения. Изменение позиций элементов не учитывается.  </para>
      </section>
    </section>
    <section id="file_storage">
      <title>Хранилище файлов</title>
      <para>Хранилище файлов обеспечивает загрузку, хранение и выгрузку произвольных файлов, ассоциированных с сущностями системы. Стандартная реализация сохраняет файлы вне основной базы данных, в специальной структуре файловой системы.</para>
      <para>Механизм работы с  файлами состоит из следующих частей:<itemizedlist>
          <listitem>
            <para>Сущность <code>FileDescriptor</code> - описатель загруженного файла (не путать с <code>java.io.FileDescriptor</code>), позволяющий ссылаться на файл из объектов модели данных.</para>
          </listitem>
          <listitem>
            <para>Интерфейс <code>FileStorageAPI</code> - доступ к хранилищу файлов на <link linkend="app_tiers">уровне</link> <structname>Middleware</structname>. Основные методы:<itemizedlist>
                <listitem>
                  <para><code>saveStream()</code> - сохранить содержимое файла, переданное в <code>InputStream</code>, по данным указанного <code>FileDescriptor</code>.</para>
                </listitem>
                <listitem>
                  <para><code>openStream()</code> - вернуть содержимое файла, указанного объектом <code>FileDescriptor</code>,  в виде открытого <code>InputStream</code>.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Класс <code>FileUploadController</code> - контроллер Spring MVC, позволяющий отправлять файлы с клиентского    уровня на  <structname>Middleware</structname> посредством HTTP POST запросов.</para>
          </listitem>
          <listitem>
            <para>Класс <code>FileDownloadController</code> - контроллер Spring MVC, позволяющий получать файлы с <structname>Middleware</structname> на клиентский уровень посредством HTTP GET запросов.</para>
          </listitem>
          <listitem>
            <para>Визуальные компоненты <code>
                <link linkend="gui_FileUploadField">FileUpload</link>
              </code> и <code>
                <link linkend="gui_FileMultiUploadField">FileMultiUpload</link>
              </code> - позволяют загрузить файлы с компьютера пользователя на клиентский уровень приложения, и затем организовать их передачу на <structname>Middleware</structname>.</para>
          </listitem>
          <listitem>
            <para>Интерфейс <code>FileUploadingAPI</code> - промежуточное хранилище загружаемых файлов на клиентском уровне. Используется вышеупомянутыми компонентами для загрузки файлов на клиентский уровень. В прикладном коде используется метод <code>putFileIntoStorage()</code>, перемещающий файл в постоянное хранилище на <structname>Middleware</structname>.</para>
          </listitem>
          <listitem>
            <para><code>ExportDisplay</code> - интерфейс клиентского уровня, позволяющий выгружать различные ресурсы приложения на компьютер пользователя. Для получения файлов из хранилища можно использовать метод <code>show()</code>, принимающий <code>FileDescriptor</code>. Экземпляр <code>ExportDisplay</code> можно получить либо вызовом статического метода <code>AppConfig.createExportDisplay()</code>, либо <link linkend="screen_controller_injection">инжекцией</link> в класс контроллера.</para>
          </listitem>
        </itemizedlist></para>
      <para>Передача файлов между пользовательским компьютером и хранилищем в обе стороны производится только путем копирования данных между потоками ввода-вывода. Ни на каком уровне приложения файл не оказывается целиком в памяти, поэтому возможна передача файлов практически любых размеров.</para>
      <section id="file_upload">
        <title>Загрузка файлов</title>
        <para>Для загрузки файлов с компьютера пользователя в хранилище следует использовать компоненты <code>
            <link linkend="gui_FileUploadField">FileUpload</link>
          </code> и <code>
            <link linkend="gui_FileMultiUploadField">FileMultiUpload</link>
          </code>. Примеры использования приведены в описании компонентов.</para>
        <para>Промежуточное хранилище клиентского уровня <code>FileUploadingAPI</code> для хранения временных файлов использует каталог, заданный свойством приложения <property>
            <link linkend="cuba.tempDir">cuba.tempDir</link>
          </property>.  В случае сбоев в нем могут оставаться временные файлы, для  удаления которых желательно в клиентских блоках приложения периодически вызывать метод <code>clearTempDirectory()</code> бина <code>cuba_FileUploading</code>. Это можно сделать, создав задание планировщика в файле <filename>
            <link linkend="spring.xml">spring.xml</link>
          </filename> модуля <structname>web</structname> (и/или <structname>desktop</structname>) проекта приложения, например:<programlisting language="xml">&lt;task:scheduled-tasks scheduler=&quot;scheduler&quot;&gt;
    &lt;task:scheduled ref=&quot;cuba_FileUploading&quot; method=&quot;clearTempDirectory&quot; cron=&quot;0 0 0 * * 2,4,6&quot;/&gt;
&lt;/task:scheduled-tasks&gt;</programlisting></para>
        <para>В данном случае очистка будет производиться в 00:00:00 каждый вторник, четверг и субботу.</para>
      </section>
      <section id="file_download">
        <title>Выгрузка данных</title>
        <para>Для выгрузки файлов на клиентском уровне следует использовать интерфейс <code>ExportDisplay</code>, получив ссылку на него вызовом статического метода <code>AppConfig.createExportDisplay()</code>, либо <link linkend="screen_controller_injection">инжекцией</link> в класс контроллера. Например:<programlisting language="java">AppConfig.createExportDisplay(this).show(fileDescriptor);</programlisting></para>
        <para>Метод <code>show()</code> может принимать дополнительный параметр типа <code>ExportFormat</code>, в котором можно задать тип содержимого и расширение имени файла. Если формат не передан, расширение берется из <code>FileDescriptor</code>, а типом содержимого принимается <code>application/octet-stream</code>. </para>
        <para>При использовании пользователем веб-интерфейса от расширения имени файла зависит, будет ли файл выгружаться через диалог сохранения или открытия файлов браузера (<code>Content-Disposition = attachment</code>), или браузер попытается отобразить содержимое прямо в своем окне (<code>Content-Disposition = inline</code>). Список расширений файлов, отображаемых в окне браузера, задается свойством приложения <property>
            <link linkend="cuba.web.viewFileExtensions">cuba.web.viewFileExtensions</link>
          </property>.</para>
      </section>
      <section id="file_storage_impl">
        <title>Стандартная реализация хранилища</title>
        <para>Стандартная реализация хранит файлы в специальной структуре каталогов на одном или нескольких файловых ресурсах.</para>
        <para>Корни структуры можно задать в свойстве приложения <property>
            <link linkend="cuba.fileStorageDir">cuba.fileStorageDir</link>
          </property>. Формат - список путей через запятую. Например: <programlisting>cuba.fileStorageDir=/work/sales/filestorage,/mnt/backup/filestorage</programlisting></para>
        <para>Если данное свойство не задано, хранилище будет создано в подкаталоге <filename>filestorage</filename> <link linkend="work_dir">рабочего каталога</link> <structname>Middleware</structname>. В стандартном варианте развертывания в Tomcat это каталог <filename>tomcat/work/app-core/filestorage</filename>. </para>
        <para>В случае указания нескольких ресурсов хранилище ведет себя следующим образом: <itemizedlist>
            <listitem>
              <para>Первый каталог в списке является <firstterm>основным</firstterm>, остальные - <firstterm>резервными</firstterm>. </para>
            </listitem>
            <listitem>
              <para>Запись сохраняемых файлов производится в основной каталог, а затем файл копируется во все резервные каталоги. </para>
              <para>Перед записью проверяется доступность каждого каталога. Если недоступен основной каталог, выбрасывается исключение и запись не производится. Если недоступен какой-то из резервных каталогов, запись все равно производится, в лог выводится сообщение об ошибке. </para>
            </listitem>
            <listitem>
              <para>Чтение производится из основного каталога. </para>
              <para>При недоступности основного каталога чтение производится из первого резервного каталога, в котором имеется данный файл. В лог выводится сообщение об ошибке. </para>
            </listitem>
          </itemizedlist></para>
        <para>Файловая структура хранилища организована следующим образом:<itemizedlist>
            <listitem>
              <para>Имеется три уровня каталогов, соответствующих дате загрузки файла - год, месяц, день.</para>
            </listitem>
            <listitem>
              <para>Файл сохраняется в каталоге дня. Именем файла является  идентификатор соответствующего объекта <code>FileDescriptor</code>. Расширение файла - исходное.</para>
            </listitem>
            <listitem>
              <para>В корне структуры хранилища ведется файл <filename>storage.log</filename>, содержащий информацию о том, какой файл, когда и каким пользователем был записан в хранилище. Этот журнал не несет никакой функциональности, но может быть полезен при поиске проблем.</para>
            </listitem>
          </itemizedlist></para>
        <para>JMX-бин <code>app-core.cuba:type=FileStorage</code> отображает текущий список корней хранилища, а также предоставляет следующие методы для поиска проблем:<itemizedlist>
            <listitem>
              <para><code>findOrphanDescriptors()</code> - найти в базе данных все экземпляры <code>FileDescriptor</code>, для которых не имеется соответствующего файла в хранилище.</para>
            </listitem>
            <listitem>
              <para><code>findOrphanFiles()</code> - найти файлы в хранилище, для которых не имеется соответствующего экземпляра <code>FileDescriptor</code> в БД.</para>
            </listitem>
          </itemizedlist></para>
      </section>
    </section>
    <section id="uniqueNumbers">
      <title>Генерация последовательностей</title>
      <para>Данный механизм позволяет  генерировать уникальные последовательности чисел через единый API, независимо от используемой СУБД. </para>
      <para>Основной частью данного механизма является <link linkend="managed_beans">бин</link> <code>UniqueNumbers</code> с интерфейсом <code>UniqueNumbersAPI</code>, доступный в блоке Middleware. Методы интерфейса:<itemizedlist>
          <listitem>
            <para><code>getNextNumber()</code> - получить следующее значение последовательности. Механизм позволяет вести одновременно несколько последовательностей, идентифицируемых простыми строками. Имя последовательности, из которой нужно получить значение, передается в параметре <code>domain</code>.</para>
            <para>Последовательности не требуют предварительной  инициализации - при первом вызове <code>getNextNumber()</code> соответствующая последовательность будет создана и вернет значение 1. </para>
          </listitem>
          <listitem>
            <para><code>getCurrentNumber()</code> - получить текущее, то есть последнее сгенерированное, значение последовательности. Параметр <code>domain</code> - имя последовательности.</para>
          </listitem>
          <listitem>
            <para><code>setCurrentNumber()</code> - установить текущее значение последовательности. Следующий вызов <code>getNextNumber()</code> вернет значение, увеличенное на 1.</para>
          </listitem>
        </itemizedlist></para>
      <para>Пример получения следующего значения последовательности в бине блока Middleware:<programlisting language="java">@Inject
private UniqueNumbersAPI uniqueNumbers;

private long getNextValue() {
    return uniqueNumbers.getNextNumber(&quot;mySequence&quot;);
}</programlisting></para>
      <para>Для получения значений последовательностей в клиентских блоках используется метод <code>getNextNumber()</code><link linkend="services"> сервиса</link> <code>UniqueNumbersService</code>.</para>
      <para>Для управления последовательностями можно использовать <link linkend="jmx_beans">JMX-бин</link> <code>app-core.cuba:type=UniqueNumbers</code> с методами, дублирующими методы <code>UniqueNumbersAPI</code>.</para>
      <para>Реализация механизма генерации последовательностей зависит от типа используемой СУБД. Для <application>HSQL</application>, <application>PostgreSQL, <application>Microsoft SQL Server 2012+</application></application> и <application>Oracle</application> каждой  последовательности <code>UniqueNumbersAPI</code> соответствует последовательность (sequence) <code>sec_un_{domain}</code> в базе данных. Для <application>Microsoft SQL Server</application> версии ниже 2012 каждой последовательности соответствует таблица <code>sec_un_{domain}</code> с автоинкрементным полем. В связи с этим управлять параметрами последовательности можно также напрямую в БД.</para>
    </section>
    <section id="queryRunner">
      <title>Выполнение SQL с помощью QueryRunner</title>
      <para><code>QueryRunner</code> - класс, предназначенный для выполнения SQL. Его следует использовать вместо <application>JDBC</application> везде, где есть необходимость работы с SQL и нежелательно применение аналогичных <link linkend="nativeQuery">средств ORM</link>. </para>
      <para>QueryRunner платформы является вариантом <ulink url="http://commons.apache.org/dbutils/apidocs/org/apache/commons/dbutils/QueryRunner.html">Apache DbUtils QueryRunner</ulink>, усовершенствованным для использования Java Generics.</para>
      <para>Пример использования: <programlisting language="java">

QueryRunner runner = new QueryRunner(persistence.getDataSource());
try {
    Set&lt;String&gt; scripts = runner.query(&quot;select SCRIPT_NAME from SYS_DB_CHANGELOG&quot;,
            new ResultSetHandler&lt;Set&lt;String&gt;&gt;() {
                public Set&lt;String&gt; handle(ResultSet rs) throws SQLException {
                    Set&lt;String&gt; rows = new HashSet&lt;String&gt;();
                    while (rs.next()) {
                        rows.add(rs.getString(1));
                    }
                    return rows;
                }
            });
    return scripts;
} catch (SQLException e) {
    throw new RuntimeException(e);
}</programlisting></para>
      <para>Есть два варианта использования <code>QueryRunner</code> - либо в текущей транзакции, либо в отдельной в режиме autocommit.<itemizedlist>
          <listitem>
            <para>Для выполнения запроса в текущей транзакции необходимо  создать экземпляр <code>QueryRunner</code> конструктором без параметров, не передавая <code>DataSource</code>. После этого нужно вызывать методы <code>query()</code> или <code>update()</code>, передавая в них <code>Connection</code>, полученный вызовом <code>EntityManager.getConnection()</code>. После выполнения закрывать <code>Connection</code> не нужно, он будет закрыт при коммите транзакции. </para>
          </listitem>
          <listitem>
            <para>Для выполнения запроса в отдельной транзакции необходимо создать экземпляр <code>QueryRunner</code> конструктором с параметром <code>DataSource</code>, получив экземпляр <code>DataSource</code> вызовом <code>Persistence.getDataSource()</code>. После этого нужно вызывать методы <code>query()</code> или <code>update()</code> без передачи какого-либо <code>Connection</code>, оно будет создано из указанного <code>DataSource</code> и затем сразу закрыто.</para>
          </listitem>
        </itemizedlist> </para>
    </section>
    <section>
      <title>Интеграция с MyBatis</title>
      <para>В состав платформы включен фреймворк <ulink url="http://www.mybatis.org">MyBatis</ulink>, обладающий, по сравнению с <link linkend="nativeQuery">ORM</link> и <link linkend="queryRunner">QueryRunner</link>,  более  широкими возможностями по выполнению SQL и отображению результатов на объекты предметной области.</para>
      <para>Для использование MyBatis в проекте необходимо добавить следующие бины в файл <filename>
          <link linkend="spring.xml">spring.xml</link>
        </filename> модуля <structname>core</structname>:<programlisting language="xml">&lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;
    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;
    &lt;property name=&quot;configLocation&quot; value=&quot;cuba-mybatis.xml&quot;/&gt;
    &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath*:com/sample/sales/core/sqlmap/*.xml&quot;/&gt;
&lt;/bean&gt;

&lt;bean id=&quot;sqlSession&quot; class=&quot;org.mybatis.spring.SqlSessionTemplate&quot;&gt;
    &lt;constructor-arg index=&quot;0&quot; ref=&quot;sqlSessionFactory&quot; /&gt;
&lt;/bean&gt;</programlisting></para>
      <para>В параметре <code>mapperLocations</code> задается путь (по правилам интерфейса <code>ResourceLoader</code> <application>Spring</application>)  к файлам отображений <application>MyBatis</application>. </para>
      <para>Пример файла отображения для загрузки экземпляра сущности <code>Заказ</code> вместе со связанным <code>Покупателем</code> и коллекцией <code>Пунктов заказа</code>:<programlisting language="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.sample.sales&quot;&gt;

    &lt;select id=&quot;selectOrder&quot; resultMap=&quot;orderResultMap&quot;&gt;
        select
            o.ID as order_id,
            o.DATE as order_date,
            o.AMOUNT as order_amount,
            c.ID as customer_id,
            c.NAME as customer_name,
            c.EMAIL as customer_email,
            i.ID as item_id,
            i.QUANTITY as item_quantity,
            p.ID as product_id,
            p.NAME as product_name    
        from
            SALES_ORDER o
            left join SALES_CUSTOMER c on c.ID = o.CUSTOMER_ID
            left join SALES_ITEM i on i.ORDER_ID = o.id and i.DELETE_TS is null
            left join SALES_PRODUCT p on p.ID = i.PRODUCT_ID
        where
            c.id = #{id}
    &lt;/select&gt;

    &lt;resultMap id=&quot;orderResultMap&quot; type=&quot;com.sample.sales.entity.Order&quot;&gt;
        &lt;id property=&quot;id&quot; column=&quot;order_id&quot;/&gt;
        &lt;result property=&quot;date&quot; column=&quot;order_date&quot;/&gt;
        &lt;result property=&quot;amount&quot; column=&quot;order_amount&quot;/&gt;

        &lt;association property=&quot;customer&quot; column=&quot;customer_id&quot; javaType=&quot;com.sample.sales.entity.Customer&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;customer_id&quot;/&gt;
            &lt;result property=&quot;name&quot; column=&quot;customer_name&quot;/&gt;
            &lt;result property=&quot;email&quot; column=&quot;customer_email&quot;/&gt;
        &lt;/association&gt;

        &lt;collection property=&quot;items&quot; ofType=&quot;com.sample.sales.entity.Item&quot;&gt;
            &lt;id property=&quot;id&quot; column=&quot;item_id&quot;/&gt;
            &lt;result property=&quot;quantity&quot; column=&quot;item_quantity&quot;/&gt;
            &lt;association property=&quot;product&quot; column=&quot;product_id&quot; javaType=&quot;com.sample.sales.entity.Product&quot;&gt;
                &lt;id property=&quot;id&quot; column=&quot;product_id&quot;/&gt;
                &lt;result property=&quot;name&quot; column=&quot;product_name&quot;/&gt;
            &lt;/association&gt;
        &lt;/collection&gt;
    &lt;/resultMap&gt;

&lt;/mapper&gt;</programlisting></para>
      <para>Для получения результатов запроса в приведенном выше примере можно использовать следующий код:<programlisting language="java">Transaction tx = persistence.createTransaction();
try {
    SqlSession sqlSession = AppBeans.get(&quot;sqlSession&quot;);
    Order order = (Order) sqlSession.selectOne(&quot;com.sample.sales.selectOrder&quot;, orderId);
    tx.commit();
} finally {
    tx.end();
}</programlisting></para>
      <tip>
        <para>Объекты, загруженные с помощью <application>MyBatis</application>, можно изменять и передавать в <code>EntityManager.merge()</code> для сохранения в базе данных. При этом в апдейт будут включены только не-<code>null</code> атрибуты, то есть если атрибут не был загружен, или специально установлен в значение <code>null</code>, соответствующее поле в БД не будет изменено.</para>
        <para>Такое поведение определяется параметром ORM <code>openjpa.DetachState=loaded</code>, установленным по умолчанию.</para>
      </tip>
    </section>
    <section id="folders_pane">
      <title>Панель папок</title>
      <para>Панель папок предназначена для быстрого доступа пользователя к часто используемой информации. Она представляет собой скрываемую панель в левой части главного окна приложения, в которой располагается иерархическая структура, нажатие на элементы которой (папки) приводит к отображению соответствующих экранов системы с определенными параметрами.</para>
      <para>На момент написания данного руководства панель папок реализована  только для <link linkend="app_tiers">
          <structname>Web Client</structname>
        </link>. </para>
      <para>Платформа поддерживает три вида папок: <firstterm>папки приложения</firstterm>, <firstterm>папки поиска</firstterm> и <firstterm>наборы</firstterm> записей. Папки приложения отображаются в верхней части панели в отдельной иерархии, папки поиска и наборы - в нижней части панели в совместной иерархии. <itemizedlist>
          <listitem>
            <para id="application_folder">Папки приложения:<itemizedlist>
                <listitem>
                  <para>Открывают  экраны с <link linkend="gui_Filter">фильтром</link> или без него.</para>
                </listitem>
                <listitem>
                  <para>Набор папок может зависеть от текущего сеанса пользователя. Видимость конкретной папки определяется путем выполнения скрипта Groovy.</para>
                </listitem>
                <listitem>
                  <para>Пользователь может создавать или изменять папки приложения, только если у него есть специальное право.</para>
                </listitem>
                <listitem>
                  <para>В заголовке папки может отображаться текущее количество входящих в папку записей, вычисляемое скриптом Groovy. </para>
                </listitem>
                <listitem>
                  <para>Заголовки папок приложения обновляются по таймеру, тем самым может изменяться счетчик записей и стиль отображения каждой папки.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para id="search_folder">Папки поиска:<itemizedlist>
                <listitem>
                  <para>Открывают экраны с <link linkend="gui_Filter">фильтром</link>. </para>
                </listitem>
                <listitem>
                  <para>Могут быть как локальными - доступными только пользователю, их создавшему, так и глобальными - доступными всем пользователям.</para>
                </listitem>
                <listitem>
                  <para>Локальные папки может создавать и изменять любой пользователь, глобальные - только имеющий специальное право.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>Наборы: <itemizedlist>
                <listitem>
                  <para>Открывают экраны с <link linkend="gui_Filter">фильтром</link>, содержащим условие отбора отдельных записей по их идентификаторам.</para>
                </listitem>
                <listitem>
                  <para>Содержимое набора редактируется с помощью специальных <link linkend="gui_Action">действий</link> таблицы: <guibutton>Добавить в набор</guibutton>, <guibutton>Удалить из набора</guibutton>.</para>
                </listitem>
                <listitem>
                  <para>Наборы локальны, то есть доступны только создавшему их пользователю.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>На функционирование панели папок влияют следующие свойства приложения:<itemizedlist>
          <listitem>
            <para><link linkend="cuba.web.foldersPaneEnabled">
                <property>cuba.web.foldersPaneEnabled</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.foldersPaneVisibleByDefault">
                <property>cuba.web.foldersPaneVisibleByDefault</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.foldersPaneDefaultWidth">
                <property>cuba.web.foldersPaneDefaultWidth</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.appFoldersRefreshPeriodSec">
                <property>cuba.web.appFoldersRefreshPeriodSec</property>
              </link></para>
          </listitem>
          <listitem>
            <para><link linkend="cuba.web.showFolderIcons">
                <property>cuba.web.showFolderIcons</property>
              </link></para>
          </listitem>
        </itemizedlist></para>
      <section>
        <title>Папки приложения</title>
        <para>Для создания папок приложения пользователь должен иметь специфическое право <guilabel>Создание/изменение папок приложения</guilabel> (код <literal>cuba.gui.appFolder.global</literal>).</para>
        <para>Простейшая папка приложения может быть создана из контекстного меню панели папок. Такая папка не связана с экранами системы и предназначена только для группировки других папок в иерархии.</para>
        <para>Для создания папки, открывающей некоторый экран с фильтром, необходимо выполнить следующее:<itemizedlist>
            <listitem>
              <para>Открыть экран и отобрать записи по нужному фильтру.</para>
            </listitem>
            <listitem>
              <para>В меню кнопки <guibutton>Фильтр...</guibutton> выбрать команду <guimenuitem>Сохранить как папку приложения</guimenuitem>.</para>
            </listitem>
            <listitem>
              <para>В окне добавления заполнить атрибуты папки:<itemizedlist>
                  <listitem>
                    <para>Наименование папки</para>
                  </listitem>
                  <listitem>
                    <para>Заголовок окна - строка, добавляемая к заголовку окна, когда он открывается из папки</para>
                  </listitem>
                  <listitem>
                    <para>Родительская папка - определяет место создаваемой папки в иерархии</para>
                  </listitem>
                  <listitem>
                    <para>Скрипт видимости - скрипт Groovy, выполняемый в начале сеанса пользователя, и определяющий доступность для него данной папки. </para>
                    <para>Скрипт должен вернуть булевское значение. Если скрипт не задан, либо возвращает null, папка доступна. Пример:<programlisting>userSession.currentOrSubstitutedUser.login == &apos;admin&apos;</programlisting></para>
                  </listitem>
                  <listitem>
                    <para>Cкрипт количества - скрипт Groovy, выполняемый в начале сеанса пользователя и по таймеру, для вычисления количества записей для данной папки и ее стиля отображения.</para>
                    <para>Скрипт должен вернуть числовое значение, целая часть которого будет использована в качестве счетчика. Если скрипт не задан, либо возвращает <code>null</code>, счетчик не будет отображаться. Кроме возвращаемого значения скрипт может установить переменную <code>style</code>, которая будет использована как имя стиля отображения папки. Пример:<programlisting language="java">import com.haulmont.cuba.core.EntityManager
import com.haulmont.cuba.core.Query

EntityManager em = persistence.getEntityManager()
Query q = em.createQuery(&apos;select count(o) from sales$Order o&apos;)
Number count = q.getSingleResult()

style = count &gt; 0 ? &apos;emphasized&apos; : null
return count</programlisting></para>
                    <para>Для отображения указанного скриптом стиля тема приложения должна содержать описание этого стиля для элемента  <code>v-tree-node</code> внутри  <code>folderspane</code>, например:<programlisting language="css">.folderspane .v-tree-node.emphasized {
    font-weight: bold;
}</programlisting></para>
                  </listitem>
                </itemizedlist></para>
            </listitem>
          </itemizedlist></para>
        <para>В скриптах доступны следующие переменные, установленные в контексте <code>groovy.lang.Binding</code>:<itemizedlist>
            <listitem>
              <para><code>folder</code>  - экземпляр сущности <code>AppFolder</code> - папка, для которой выполняется скрипт</para>
            </listitem>
            <listitem>
              <para><code>userSession</code> - экземпляр <code>UserSession</code> - текущая <link linkend="userSession">пользовательская сессия</link> </para>
            </listitem>
            <listitem>
              <para><code>persistence</code> - реализация интерфейса <link linkend="persistence">
                  <code>Persistence</code>
                </link></para>
            </listitem>
            <listitem>
              <para><code>metadata</code> - реализация интерфейса <link linkend="metadata">
                  <code>Metadata</code>
                </link></para>
            </listitem>
          </itemizedlist>При обновлении папок для всех скриптов используется один экземпляр <code>groovy.lang.Binding</code>, поэтому между ними можно передавать переменные для исключения дублирующихся запросов и повышения производительности. </para>
        <para>Тексты скриптов могут содержаться либо непосредственно в атрибутах сущности <code>AppFolder</code>, либо в отдельных файлах. В последнем случае атрибут должен содержать путь к файлу скрипта (обязательно с расширением &quot;.groovy&quot;) по правилам интерфейса <code>
            <link linkend="resources">Resources</link>
          </code>. Таким образом, если содержимое атрибута представляет собой строку, заканчивающуюся на &quot;.groovy&quot;, текст скрипта загружается из указанного файла, в противном случае в качестве скрипта используется само содержимое атрибута.</para>
        <para>Папки приложения представляют собой экземпляры сущности <code>AppFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SYS_APP_FOLDER</database>.</para>
      </section>
      <section>
        <title>Папки поиска</title>
        <para>Папки поиска создаются пользователями аналогично папкам приложения - группирующие папки непосредственно из контекстного меню панели папок, связанные с экранами - из меню кнопки <guibutton>Фильтр...</guibutton> экрана командой <guimenuitem>Сохранить как папку поиска</guimenuitem>.</para>
        <para>Для создания глобальной папки пользователь должен иметь специфическое право <guilabel>Создание/изменение глобальных папок поиска</guilabel> (код <literal>cuba.gui.searchFolder.global</literal>). </para>
        <para>Фильтр папки поиска можно изменить после ее создания - для этого достаточно открыть папку и  в экране изменить фильтр <guilabel>Папка: {имя папки}</guilabel>. После сохранения фильтра он будет изменен и в папке тоже.</para>
        <para>Папки поиска  представляют собой экземпляры сущности <code>SearchFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SEC_SEARCH_FOLDER</database>.</para>
      </section>
      <section>
        <title>Наборы</title>
        <para>Использование наборов в экране возможно, если для компонента <code>
            <link linkend="gui_Filter">Filter</link>
          </code> в атрибуте <sgmltag>applyTo</sgmltag> указан соответствующий компонент <code>
            <link linkend="gui_Table">Table</link>
          </code>. Например:<programlisting language="xml">&lt;layout&gt;
    &lt;filter id=&quot;customerFilter&quot; 
            datasource=&quot;customersDs&quot; 
            applyTo=&quot;customersTable&quot;/&gt;

    &lt;groupTable id=&quot;customersTable&quot; 
                width=&quot;100%&quot;&gt;
        &lt;buttonsPanel&gt;
            &lt;button action=&quot;customersTable.create&quot;/&gt;
...
        &lt;/buttonsPanel&gt;
...</programlisting></para>
        <para>При этом в контекстном меню таблицы появятся команды <guibutton>Добавить в набор</guibutton> или <guibutton>Добавить в тек. набор</guibutton> / <guibutton>Удалить из набора</guibutton>. Если таблица содержит внутри себя компонент <sgmltag>buttonsPanel</sgmltag> (как в приведенном выше примере), команды контекстного меню будут продублированы соответствующими кнопками.</para>
        <para>Наборы  представляют собой экземпляры сущности <code>SearchFolder</code> и хранятся в связанных таблицах <database>SYS_FOLDER</database> и <database>SEC_SEARCH_FOLDER</database>.</para>
      </section>
    </section>
    <section id="link_to_screen">
      <title>Ссылки на экраны</title>
      <para>Блок <link linkend="app_tiers">
          <structname>Web Client</structname>
        </link> позволяет открывать экраны приложения по команде, переданной в URL. Причем если в данный момент в браузере нет сессии приложения с зарегистрированным пользователем, то сначала будет отображено окно логина, и сразу после успешной регистрации - главное окно приложения с требуемым экраном.</para>
      <para>Набор возможных команд указывается в свойстве приложения <property>
          <link linkend="cuba.web.linkHandlerActions">cuba.web.linkHandlerActions</link>
        </property>, по умолчанию это команды  <code>open</code> и <code>o</code>.  При обработке HTTP запроса анализируется последняя часть URL, и если она совпадает с одной из команд, управление передается бину <code>LinkHandler</code>. Стандартная реализация этого бина позволяет указывать следующие параметры:<itemizedlist>
          <listitem>
            <para><code>screen</code> - имя экрана, указанное в <filename>
                <link linkend="screens.xml">screens.xml</link>
              </filename>, например:<programlisting>http://localhost:8080/app/open?screen=sec$User.browse</programlisting></para>
          </listitem>
          <listitem>
            <para><code>item</code> - экземпляр сущности для передачи в <link linkend="screen_edit">экран редактирования</link>, закодированный по правилам класса <code>EntityLoadInfo</code>, т.е. <code>entityName-instanceId</code> или <code>entityName-instanceId-viewName</code>. Примеры:<programlisting>http://localhost:8080/app/open?screen=sec$User.edit&amp;item=sec$User-60885987-1b61-4247-94c7-dff348347f93

http://localhost:8080/app/open?screen=sec$User.edit&amp;item=sec$User-60885987-1b61-4247-94c7-dff348347f93-user.edit</programlisting></para>
          </listitem>
          <listitem>
            <para><code>params</code> - параметры экрана, передаваемые в метод <code>init()</code> <link linkend="screen_controller">контроллера</link>. Параметры кодируются в виде <code>name1:value1,name2:value2</code>. Значениями параметров могут быть экземпляры сущностей, в свою очередь закодированные по правилам класса <code>EntityLoadInfo</code>. Примеры:<programlisting>http://localhost:8080/app/open?screen=sales$Customer.lookup&amp;params=p1:v1,p2:v2

http://localhost:8080/app/open?screen=sales$Customer.lookup&amp;params=p1:sales$Customer-01e37691-1a9b-11de-b900-da881aea47a6</programlisting></para>
          </listitem>
        </itemizedlist></para>
      <para>Бин <code>LinkHandler</code> может быть переопределен в проекте приложения для обеспечения специфической обработки ссылок.</para>
    </section>
    <section>
      <title>Инспектор сущностей</title>
      <para>Инспектор сущностей позволяет работать с любыми объектами предметной области без создания специфических экранов. Инспектор динамически генерирует экраны просмотра списка и редактирования экземпляра выбранной сущности.</para>
      <para>Это дает возможность администратору системы просматривать и редактировать данные, которые недоступны в стандартных экранах в силу их дизайна, а  на этапе прототипирования создать только модель данных и пункты главного меню, ссылающиеся на инспектор сущностей.</para>
      <para>Точкой входа в инспектор является экран <filename>com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml</filename>. </para>
      <para>Если в экран передан параметр <code>entity</code> типа <code>String</code> с именем сущности, то инспектор отобразит список экземпляров этой сущности с возможностью фильтрации, выбора и редактирования экземпляров. Параметр может быть указан при регистрации экрана в <link linkend="screens.xml">
          <filename>screens.xml</filename>
        </link>, например:</para>
      <para><filename>screens.xml</filename><programlisting language="xml">&lt;screen id=&quot;sales$Product.lookup&quot; 
        template=&quot;/com/haulmont/cuba/gui/app/core/entityinspector/entity-inspector-browse.xml&quot;&gt;
    &lt;param name=&quot;entity&quot; 
           value=&quot;sales$Product&quot;/&gt;
&lt;/screen&gt;</programlisting></para>
      <para><filename>menu.xml</filename><programlisting language="xml">&lt;item id=&quot;sales$Product.lookup&quot;/&gt;</programlisting></para>
      <para>Идентификатор экрана вида <code>{имя_сущности}.lookup</code>  дает возможность использовать этот экран компонентам <code>
          <link linkend="gui_PickerField">PickerField</link>
        </code> и <code>
          <link linkend="gui_LookupPickerField">LookupPickerField</link>
        </code> в стандартном действии <code>PickerField.LookupAction</code>.</para>
      <para>В общем случае данный экран можно вызывать без передачи параметров, тогда в его верхней части отображается поле для выбора сущности. В базовом проекте <structname>cuba</structname> экран инспектора зарегистрирован с идентификатором <code>entityInspector.browse</code>, поэтому для его вызова достаточно наличия пункта меню:<programlisting language="xml">&lt;item id=&quot;entityInspector.browse&quot;/&gt;</programlisting></para>
    </section>
    <section id="credits">
      <title>Информация об используемом ПО</title>
      <para>Платформа предоставляет средства для регистрации и отображения в пользовательском интерфейсе информации об используемом в приложении стороннем программном обеспечении (credits). Информация включает в себя название, ссылку на веб-сайт и текст лицензии.</para>
      <para><link linkend="base_projects">Базовые проекты</link> платформы содержат собственные файлы описаний <filename>cuba-credits.xml</filename>, <filename>reports-credits.xml</filename> и т.д. В проекте приложения можно создать аналогичный файл и в свойстве приложения <property>
          <link linkend="cuba.creditsConfig">cuba.creditsConfig</link>
        </property> определить список файлов описаний в зависимости от используемых базовых проектов.</para>
      <para>Структура файла <filename>credits.xml</filename>: <itemizedlist>
          <listitem>
            <para>Элемент <sgmltag>items</sgmltag> - перечисление используемых библиотек с указанием текста лицензии либо во вложенном элементе <sgmltag>license</sgmltag>, либо атрибутом <sgmltag>license</sgmltag> со ссылкой на текст в секции <sgmltag>licenses</sgmltag>.</para>
            <para>Cсылаться можно на лицензии, объявленные не только в этом же файле, но и в любом другом файле, объявленном в переменной <property>cuba.creditsConfig</property> раньше, чем текущий. </para>
          </listitem>
          <listitem>
            <para>Элемент <sgmltag>licenses</sgmltag> - перечисление текстов общеупотребительных лицензий.</para>
          </listitem>
        </itemizedlist></para>
      <para>Для отображения общего списка используемого ПО  предназначен фрейм <filename>com/haulmont/cuba/gui/app/core/credits/credits-frame.xml</filename>, загружающий информацию из файлов, заданных в свойстве <property>cuba.creditsConfig</property>. Пример использования фрейма в экране:<programlisting language="xml">&lt;layout expand=&quot;creditsBox&quot;&gt;
    &lt;groupBox id=&quot;creditsBox&quot; 
              caption=&quot;msg://credits&quot; 
              width=&quot;100%&quot;&gt;
        &lt;iframe id=&quot;credits&quot; 
                src=&quot;/com/haulmont/cuba/gui/app/core/credits/credits-frame.xml&quot; 
                width=&quot;100%&quot; 
                height=&quot;100%&quot;/&gt;
    &lt;/groupBox&gt;
&lt;/layout&gt;</programlisting></para>
      <para>Если экран с фреймом открывается в модальном режиме (<code>WindowManager.OpenType.DIALOG</code>), ему необходимо задать высоту, иначе возможна неправильная работа скроллинга. Это можно сделать, например, в контроллере экрана, выводящего фрейм: <programlisting language="java">@Override
public void init(Map&lt;String, Object&gt; params) {
    getDialogParams().setWidth(500).setHeight(400);
}</programlisting></para>
    </section>
  </section>
  <section id="extension">
    <title>Расширение функциональности </title>
    <para>Платформа позволяет расширять и переопределять свою функциональность в приложениях в следующих аспектах:
<itemizedlist>
        <listitem>
          <para>расширение набора атрибутов сущностей</para>
        </listitem>
        <listitem>
          <para>расширение функциональности экранов</para>
        </listitem>
        <listitem>
          <para>расширение и переопределение бизнес-логики, сосредоточенной в  бинах <application>Spring</application> </para>
        </listitem>
      </itemizedlist></para>
    <para>Рассмотрим две первые задачи на примере добавления поля &quot;Адрес&quot; в сущность <code>User</code> подсистемы безопасности платформы. </para>
    <section id="entity_extension">
      <title>Расширение сущности</title>
      <para>Создадим в проекте приложения класс сущности, унаследованный от <code>com.haulmont.cuba.security.entity.User</code> и добавим в него требуемый атрибут с соответствующими методами доступа: <programlisting language="java">@Entity(name = &quot;sales$User&quot;)
@Extends(User.class)
public class ExtUser extends User {
    
    @Column(name = &quot;ADDRESS&quot;, length = 100)
    private String address;

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }
}</programlisting></para>
      <para>В аннотации <code>
          <link linkend="entity_annotation">@Entity</link>
        </code> должно быть указано новое имя сущности. Так как базовая сущность не объявляет <link linkend="inheritance_annotation">стратегию наследования</link>, то по умолчанию это <code>SINGLE_TABLE</code>. Это означает, что унаследованная сущность будет храниться в той же таблице, что и базовая, и аннотация <code>
          <link linkend="table_annotation">@Table</link>
        </code> не требуется. Другие аннотации базовой сущности - <code>
          <link linkend="namePattern">@NamePattern</link>
        </code>, <code>
          <link linkend="listeners_annotation">@Listeners</link>
        </code> и прочие - автоматически применяются к расширяющей сущности, но могут быть переопределены в ее классе.  </para>
      <para>Важным элементом класса новой сущности является аннотация <code>@Extends</code> с базовым классом в качестве параметра. Она позволяет сформировать реестр расширяющих сущностей, и заставить механизмы платформы использовать их повсеместно вместо базовых. Реестр реализуется классом <code>ExtendedEntities</code>, который является бином <application>Spring</application> с именем <code>cuba_ExtendedEntities</code>, и доступен также через интерфейс <code>
          <link linkend="metadata">Metadata</link>
        </code>.</para>
      <para>Добавим локализованное название нового атрибута в <link linkend="message_packs">пакет</link> <code>com.sample.sales.entity</code>:</para>
      <para><filename>messages.properties</filename><programlisting>ExtUser.address=Address</programlisting></para>
      <para><filename>messages_ru.properties</filename><programlisting>ExtUser.address=Адрес</programlisting></para>
      <para>Зарегистрируем новую сущность в файле <filename>
          <link linkend="persistence.xml">persistence.xml</link>
        </filename> проекта:<programlisting language="xml">&lt;class&gt;com.sample.sales.entity.ExtUser&lt;/class&gt;</programlisting></para>
      <para>Добавим в <link linkend="db_scripts">скрипты создания и обновления базы данных</link> команду модификации соответствующей таблицы:<programlisting>alter table SEC_USER add ADDRESS varchar(100)</programlisting></para>
    </section>
    <section id="screen_extension">
      <title>Расширение экранов</title>
      <para>Платформа позволяет создавать новые <link linkend="screen_xml">XML-дескрипторы</link> экранов путем наследования от существующих.</para>
      <para>Наследование XML выполняется путем указания в корневом элементе <sgmltag>window</sgmltag> атрибута <sgmltag>extends</sgmltag>, содержащего путь к базовому дескриптору.</para>
      <para>Правила переопределения элементов XML экрана:<itemizedlist>
          <listitem>
            <para>Если в расширяющем дескрипторе указан некоторый элемент, в базовом дескрипторе будет произведен поиск соответствующего элемента по следующему алгоритму:<itemizedlist>
                <listitem>
                  <para>Если переопределяющий элемент - <sgmltag>view</sgmltag>, то ищется соответствующий элемент по атрибутам <sgmltag>name</sgmltag>, <sgmltag>class</sgmltag>, <sgmltag>entity</sgmltag>.</para>
                </listitem>
                <listitem>
                  <para>Если переопределяющий элемент - <sgmltag>property</sgmltag>, то ищется соответствующий элемент по атрибуту <sgmltag>name</sgmltag>.</para>
                </listitem>
                <listitem>
                  <para>В других случаях, если в переопределяющем элементе указан атрибут <sgmltag>id</sgmltag>, ищется соответствующий элемент с таким же <sgmltag>id</sgmltag>. </para>
                </listitem>
                <listitem>
                  <para role="bold">Если поиск дал результат, то  найденный элемент <emphasis role="bold">переопределяется</emphasis>.</para>
                </listitem>
                <listitem>
                  <para>Если поиск не дал результата, то определяется, сколько в базовом дескрипторе элементов по данному пути и с данным именем. Если ровно один - он <emphasis role="bold">переопределяется</emphasis>.</para>
                </listitem>
                <listitem>
                  <para>Если поиск не дал результата, и в базовом дескрипторе по данному пути с данным именем нет элементов, либо их больше одного, <emphasis role="bold">добавляется</emphasis> новый элемент.</para>
                </listitem>
              </itemizedlist></para>
          </listitem>
          <listitem>
            <para>В переопределяемом либо добавляемом элементе устанавливается текст из расширяющего элемента. </para>
          </listitem>
          <listitem>
            <para>В переопределяемый либо добавляемый элемент копируются все атрибуты из расширяющего элемента. При совпадении имени атрибута значение берется из расширяющего элемента.</para>
          </listitem>
          <listitem>
            <para>Добавление нового элемента по умолчанию производится в конец списка соседних элементов. Чтобы добавить новый элемент в начало или с произвольным индексом, необходимо выполнить следующее: <itemizedlist>
                <listitem>
                  <para>определить в расширяющем дескрипторе дополнительный namespace: <code>xmlns:ext=&quot;http://schemas.haulmont.com/cuba/5.3/window-ext.xsd&quot;</code></para>
                </listitem>
                <listitem>
                  <para>добавить в расширяющий элемент атрибут <sgmltag>ext:index</sgmltag> с желаемым индексом, например: <code>ext:index=&quot;0&quot;.</code></para>
                </listitem>
              </itemizedlist></para>
          </listitem>
        </itemizedlist></para>
      <para>Для отладки преобразования дескрипторов можно включить вывод в журнал сервера результирующего XML. Делается это путем указания уровня <code>TRACE</code> для логгера <code>com.haulmont.cuba.gui.xml.XmlInheritanceProcessor</code> в файле конфигурации <application>Log4j</application>:<programlisting language="xml">&lt;appender name=&quot;FILE&quot; ...
        &lt;param name=&quot;Threshold&quot; value=&quot;TRACE&quot;/&gt;
...        
&lt;category name=&quot;com.haulmont.cuba.gui.xml.XmlInheritanceProcessor&quot;&gt;
    &lt;priority value=&quot;TRACE&quot;/&gt;
&lt;/category&gt;</programlisting></para>
      <para>Пример XML-дескриптора экрана браузера сущностей <code>ExtUser</code>:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/window.xsd&quot;
        xmlns:ext=&quot;http://schemas.haulmont.com/cuba/5.3/window-ext.xsd&quot;
        extends=&quot;/com/haulmont/cuba/gui/app/security/user/browse/user-browse.xml&quot;&gt;
    &lt;layout&gt;
        &lt;groupTable id=&quot;usersTable&quot;&gt;
            &lt;columns&gt;
                &lt;column id=&quot;address&quot; ext:index=&quot;2&quot;/&gt;
            &lt;/columns&gt;
        &lt;/groupTable&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
      <para>В данном примере дескриптор унаследован от стандартного браузера сущностей <code>User</code> платформы, и в таблицу добавлена колонка <code>address</code> с индексом <code>2</code>, т.е. отображающаяся после <code>login</code> и <code>name</code>.</para>
      <para>Зарегистрируем новый экран в <filename>
          <link linkend="screens.xml">screens.xml</link>
        </filename> с теми же идентификаторами, которые использовались для базового экрана. После этого новый экран будет повсеместно вызываться взамен старого.<programlisting language="xml">&lt;screen id=&quot;sec$User.browse&quot;
        template=&quot;com/sample/sales/gui/extuser/extuser-browse.xml&quot;/&gt;
&lt;screen id=&quot;sec$User.lookup&quot;
        template=&quot;com/sample/sales/gui/extuser/extuser-browse.xml&quot;/&gt;</programlisting></para>
      <para>Аналогично создаем экран редактирования:<programlisting language="xml">&lt;window xmlns=&quot;http://schemas.haulmont.com/cuba/5.3/window.xsd&quot;
        xmlns:ext=&quot;http://schemas.haulmont.com/cuba/5.3/window-ext.xsd&quot;
        extends=&quot;/com/haulmont/cuba/gui/app/security/user/edit/user-edit.xml&quot;&gt;
    &lt;layout&gt;
        &lt;fieldGroup id=&quot;fieldGroup&quot;&gt;
            &lt;column id=&quot;fieldGroupColumn2&quot;&gt;
                &lt;field id=&quot;address&quot; ext:index=&quot;4&quot;/&gt;
            &lt;/column&gt;
        &lt;/fieldGroup&gt;
    &lt;/layout&gt;
&lt;/window&gt;</programlisting></para>
      <para>Регистрируем его в <filename>screens.xml</filename> с идентификатором базового экрана:<programlisting language="xml">&lt;screen id=&quot;sec$User.edit&quot;
        template=&quot;com/sample/sales/gui/extuser/extuser-edit.xml&quot;/&gt;</programlisting></para>
      <para>После выполнения описанных выше действий в приложении вместо платформенной сущности <code>User</code> будет использоваться <code>ExtUser</code> с соответствующими экранами.</para>
      <para>Контроллер экрана  может быть расширен путем создания нового класса, унаследованного от контроллера базового экрана. Имя класса указывается в атрибуте <sgmltag>class</sgmltag> корневого элемента расширяющего XML дескриптора, при этом выполняются обычные правила наследования XML, описанные выше. </para>
    </section>
    <section id="bean_extension">
      <title>Расширение бизнес-логики</title>
      <para>Основная часть бизнес-логики платформы сосредоточена в бинах <application>Spring</application>, что позволяет легко расширить или переопределить ее в приложении.</para>
      <para>Для подмены реализации бина достаточно создать свой класс, реализующий  интерфейс или расширяющий базовый класс платформы, и зарегистрировать его в <link linkend="spring.xml">
          <filename>spring.xml</filename>
        </link> приложения. Аннотацию <code>@ManagedBean</code> в расширяющем классе применять нельзя, переопределение бинов возможно только с помощью конфигурации в XML.</para>
      <para>Рассмотрим пример добавления метода в бин <link linkend="persistenceTools">
          <code>PersistenceTools</code>
        </link>.</para>
      <para>Создаем класс с нужным методом:<programlisting language="java">public class ExtPersistenceTools extends PersistenceTools {

    public Entity reloadInSeparateTransaction(final Entity entity, final String... viewNames) {
        Entity result = persistence.createTransaction().execute(new Transaction.Callable&lt;Entity&gt;() {
            @Override
            public Entity call(EntityManager em) {
                return em.reload(entity, viewNames);
            }
        });
        return result;
    }
}</programlisting></para>
      <para>Регистрируем класс в <filename>spring.xml</filename> модуля <structname>core</structname> проекта с тем же идентификатором, что и бин платформы:<programlisting language="xml">&lt;bean id=&quot;cuba_PersistenceTools&quot; class=&quot;com.sample.sales.core.ExtPersistenceTools&quot;/&gt;</programlisting></para>
      <para>После этого контекст <application>Spring</application>  вместо экземпляра базового класса <code>PersistenceTools</code> будет всегда возвращать <code>ExtPersistenceTools</code>, например:<programlisting language="java">Persistence persistence;
PersistenceTools tools;

persistence = AppBeans.get(Persistence.class);
tools = persistence.getTools();
assertTrue(tools instanceof ExtPersistenceTools);

tools = AppBeans.get(PersistenceTools.class);
assertTrue(tools instanceof ExtPersistenceTools);

tools = AppBeans.get(PersistenceTools.NAME);
assertTrue(tools instanceof ExtPersistenceTools);</programlisting></para>
    </section>
  </section>
</chapter>
